<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>linux常用指令</title>
    <link href="/2024/01/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/01/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="已知进程杀死进程"><a href="#已知进程杀死进程" class="headerlink" title="已知进程杀死进程"></a>已知进程杀死进程</h1><ul><li>ps aux：查看所有进程</li><li>ps aux | grep nginx : 查看nginx进程</li><li>kill -9 pid：杀死pid进程</li></ul><h1 id="已知端口杀死进程"><a href="#已知端口杀死进程" class="headerlink" title="已知端口杀死进程"></a>已知端口杀死进程</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul><li><p>查看哪些端口被占用（tcp，udp）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -tuln<br></code></pre></td></tr></table></figure></li><li><p>杀死端口进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fuser -k 8080<br></code></pre></td></tr></table></figure></li></ul><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><ul><li><p>查看端口的进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i :8080<br><br><span class="hljs-comment">#输出</span><br>COMMAND     PID    USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME<br>httpServe 24009 xiadong    3u  IPv4 1496040      0t0  TCP *:http-alt (LISTEN)<br></code></pre></td></tr></table></figure></li><li><p>杀死这个进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 24009<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake配置</title>
    <link href="/2024/01/03/CMake%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%BA%93%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/01/03/CMake%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%BA%93%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>本文介绍CMake的常用命令以及库的相关概念</p><p>项目地址：<a href="https://github.com/mrxiad/Cmake_project_template">cmake教程</a></p><h1 id="安装Cmake"><a href="#安装Cmake" class="headerlink" title="安装Cmake"></a>安装Cmake</h1><p>在ubuntu18.04下安装cmake</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install cmake<br></code></pre></td></tr></table></figure><p>安装后查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -version<br></code></pre></td></tr></table></figure><h1 id="CMake编写"><a href="#CMake编写" class="headerlink" title="CMake编写"></a>CMake编写</h1><p><a href="https://blog.csdn.net/weixin_43717839/article/details/128032486?ops_request_misc=%7B%22request_id%22:%22170054364016800222888865%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170054364016800222888865&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128032486-null-null.142%5Ev96%5Epc_search_result_base3&utm_term=cmake&spm=1018.2226.3001.4187">【C++】Cmake使用教程（看这一篇就够了）_隐居的遮天恶鬼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43717839/article/details/127991174?spm=1001.2014.3001.5502">【C++】静态库和动态库文件的生成和使用_c++ 生成静态库和动态库命令-CSDN博客</a></p><h2 id="本文项目结构"><a href="#本文项目结构" class="headerlink" title="本文项目结构"></a>本文项目结构</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs makefile">MyProject/<br>|-- CMakeLists.txt          <span class="hljs-comment"># 主CMake文件</span><br>|-- external/               <span class="hljs-comment"># 外部依赖目录</span><br>|   |-- CMakeLists.txt<br>|   `-- libExternal         <span class="hljs-comment"># 模拟的外部库</span><br>|       |-- <span class="hljs-keyword">include</span>/        <span class="hljs-comment"># 外部库的头文件</span><br>|       |   `-- libExternal.h<br>|       `-- src/            <span class="hljs-comment"># 外部库的源文件</span><br>|           `-- libExternal.cpp<br>|-- app/                    <span class="hljs-comment"># 应用程序目录</span><br>|   |-- CMakeLists.txt<br>|   `-- src/<br>|       `-- main.cpp<br>|-- lib/                    <span class="hljs-comment"># 库文件目录</span><br>|   |-- libA/               <span class="hljs-comment"># 静态库A</span><br>|   |   |-- CMakeLists.txt<br>|   |   `-- src/<br>|   |       `-- libA.cpp<br>|   `-- libB/               <span class="hljs-comment"># 动态库B</span><br>|       |-- CMakeLists.txt<br>|       `-- src/<br>|           `-- libB.cpp<br>|-- <span class="hljs-keyword">include</span>/                <span class="hljs-comment"># 公共头文件目录</span><br>|   |-- libA/<br>|   |   `-- libA.h<br>|   `-- libB/<br>|       `-- libB.h<br>|-- tests/                  <span class="hljs-comment"># 测试目录</span><br>|   |-- CMakeLists.txt<br>|   `-- testA/<br>|       |-- CMakeLists.txt<br>|       `-- src/<br>|           `-- testA.cpp<br>|-- docs/                   <span class="hljs-comment"># 文档目录</span><br>|-- README.md<br>`-- .gitignore<br><br></code></pre></td></tr></table></figure><h2 id="需要明确一些点"><a href="#需要明确一些点" class="headerlink" title="需要明确一些点"></a>需要明确一些点</h2><ol><li><p><code>include”head.h”</code>仅仅是将文件内容复制，所以一个项目可以<strong>完全没有</strong>头文件</p></li><li><p>如果指定库文件（或者可执行文件）的头文件<strong>搜索路径</strong>，则首先在库文件搜索路径下找，然后在当前cpp文件目录下，然后在编译器的默认搜索路径中寻找</p></li><li><p>CMake是一个跨平台的自动化构建系统，主要用于生成Makefile，所以一般cmake不会报错，在make的时候会报错</p></li><li><p><strong>无法解析的外部命令</strong></p><ul><li>函数仅在头文件中声明，而没有在任何编译单元（.cpp文件）中实现。</li><li>相应的库文件没有被正确链接到您的项目中。</li><li>如果涉及动态库，可能是动态库没有被正确安装或找不到</li></ul></li><li><p><strong>编译和链接的关系</strong></p><p>每个源文件（.cpp）可以独立编译，生成对象文件。链接阶段将这些对象文件组合成最终的可执行文件或库文件。如果只有函数声明没有实现，编译时不会报错，但链接时会报错，因为链接器找不到这些函数的定义。并且链接器会自动处理依赖关系，不需要指定对象文件的链接顺序。</p></li><li><p><strong>动态库链接的代码执行</strong></p><p> 当您的程序链接了动态库，运行时，操作系统会加载这些库并解析所需的符号。如果您删除了动态库，程序可能无法运行，因为它找不到必要的函数实现。动态库的代码不是写入可执行文件中，而是在运行时动态加载的。</p></li><li><p><strong>库文件和头文件</strong></p><p> 库文件必须包含函数的定义，但<strong>不一定</strong>要包含头文件。头文件通常包含函数声明，使得其他源文件能够知道这些函数的存在。即使不包含头文件，只要函数在库内部定义，链接时就不会报错。</p></li><li><p><strong>动态库搜索</strong>，</p><p> 可执行文件本身不包含库代码，而是包含对库函数的引用。在运行时，操作系统的动态链接器负责找到并加载这些动态库。这通常是通过以下方式实现的：</p><ol><li><strong>链接时信息</strong>: 当可执行文件被创建时，链接器会在可执行文件中存储有关它依赖的动态库的信息（如库的名称和版本）。</li><li><strong>运行时搜索</strong>: 在程序启动时，动态链接器会根据这些信息查找并加载必要的动态库。库的搜索可以基于多个因素，包括操作系统的库搜索路径、环境变量（如 <code>LD_LIBRARY_PATH</code> 在Linux上）等。</li></ol></li></ol><h1 id="cmake知识点"><a href="#cmake知识点" class="headerlink" title="cmake知识点"></a>cmake知识点</h1><h2 id="一些常量"><a href="#一些常量" class="headerlink" title="一些常量"></a>一些常量</h2><ol><li><h3 id="项目和源代码相关"><a href="#项目和源代码相关" class="headerlink" title="项目和源代码相关"></a>项目和源代码相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取包含顶层CMakeLists.txt的目录的路径</span><br><span class="hljs-keyword">set</span>(TOP_LEVEL_SOURCE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取当前处理的CMakeLists.txt的目录的路径</span><br><span class="hljs-keyword">set</span>(CURRENT_LIST_DIR <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取最近通过project()命令定义的子项目的源目录(cmake目录)</span><br><span class="hljs-keyword">set</span>(LAST_PROJECT_SOURCE_DIR <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取包含当前正在处理的列表文件的目录</span><br><span class="hljs-keyword">set</span>(CURRENT_LIST_FILE_DIR <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><h3 id="构建和输出相关"><a href="#构建和输出相关" class="headerlink" title="构建和输出相关"></a>构建和输出相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取顶层构建目录的路径(build)</span><br><span class="hljs-keyword">set</span>(TOP_LEVEL_BINARY_DIR <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取当前处理的CMakeLists.txt对应的构建目录的路径</span><br><span class="hljs-keyword">set</span>(CURRENT_BINARY_DIR <span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)<br><br><span class="hljs-comment"># 设置可执行文件的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-comment"># 设置库文件（动态）的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><br><span class="hljs-comment"># 设置静态库的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/archive)<br></code></pre></td></tr></table></figure></li><li><h3 id="系统和平台相关"><a href="#系统和平台相关" class="headerlink" title="系统和平台相关"></a>系统和平台相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取系统名称，例如Linux、Windows</span><br><span class="hljs-keyword">set</span>(SYSTEM_NAME <span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>)<br><br><span class="hljs-comment"># 获取系统处理器，例如x86_64、AMD64</span><br><span class="hljs-keyword">set</span>(SYSTEM_PROCESSOR <span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><h3 id="C-和编译器相关"><a href="#C-和编译器相关" class="headerlink" title="C++ 和编译器相关"></a>C++ 和编译器相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 设置C++编译器的标志</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;</span>)<br><br><span class="hljs-comment"># 获取编译器的完整路径</span><br><span class="hljs-keyword">set</span>(COMPILER_PATH <span class="hljs-variable">$&#123;CMAKE_CXX_COMPILER&#125;</span>)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：<br>CMAKE_BINARY_DIR是执行cmake命令的目录，外部构建的时候是build目录<br>CMAKE_SOURCE_DIR是项目的根CMakeLists.txt所在目录<br>CMAKE_CURRENT_SOURCE_DIR是当前CMakeLists.txt所在目录</p></blockquote><h3 id="区分预定义变量和自定义变量"><a href="#区分预定义变量和自定义变量" class="headerlink" title="区分预定义变量和自定义变量"></a>区分预定义变量和自定义变量</h3><ul><li><strong>预定义变量</strong>：这些是CMake系统提供的变量，通常以 <code>CMAKE_</code> 开头。它们用于获取关于构建环境和项目配置的信息。</li><li><strong>自定义变量</strong>：您可以通过 <code>set()</code> 命令创建自己的变量。您可以使用这些变量来存储自己的数据，或者修改和存储预定义变量的值。</li></ul><h2 id="构建camke工程的步骤"><a href="#构建camke工程的步骤" class="headerlink" title="构建camke工程的步骤"></a>构建camke工程的步骤</h2><ol><li><p>首先要在每个目录下创建CMakeLists.txt文件</p></li><li><p>嵌套的目录需要使用<code>add_subdirectory</code>调用</p></li><li><p>动态库链接静态库需要添加**-fPIC编译选项**</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cma"># 添加-fPIC编译选项,libA是静态库名<br>set_property(TARGET libA PROPERTY POSITION_INDEPENDENT_CODE ON)<br></code></pre></td></tr></table></figure></li></ol><h2 id="常用命令大全"><a href="#常用命令大全" class="headerlink" title="常用命令大全"></a>常用命令大全</h2><ol><li><h3 id="设置全局c-标准"><a href="#设置全局c-标准" class="headerlink" title="设置全局c++标准"></a>设置全局c++标准</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置全局C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br></code></pre></td></tr></table></figure></li><li><h3 id="指定文件生成目录"><a href="#指定文件生成目录" class="headerlink" title="指定文件生成目录"></a>指定文件生成目录</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置可执行文件和库文件的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs)<br></code></pre></td></tr></table></figure></li><li><h3 id="添加子目录"><a href="#添加子目录" class="headerlink" title="添加子目录"></a>添加子目录</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 添加子目录,括号内是子目录名称</span><br><span class="hljs-keyword">add_subdirectory</span>(external)<br><span class="hljs-keyword">add_subdirectory</span>(lib)<br><span class="hljs-keyword">add_subdirectory</span>(app)<br><span class="hljs-keyword">add_subdirectory</span>(tests)<br></code></pre></td></tr></table></figure></li><li><h3 id="生成库文件"><a href="#生成库文件" class="headerlink" title="生成库文件"></a>生成库文件</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(libname SHARED src/mylib.cpp)  <span class="hljs-comment">#生成动态库文件libname</span><br><span class="hljs-keyword">add_library</span>(libname STATIC src/mylib.cpp)  <span class="hljs-comment">#生成静态库文件libname</span><br></code></pre></td></tr></table></figure></li><li><h3 id="为目标添加头文件搜索路径"><a href="#为目标添加头文件搜索路径" class="headerlink" title="为目标添加头文件搜索路径"></a>为目标添加头文件搜索路径</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(libA PUBLIC <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libA)<br></code></pre></td></tr></table></figure></li><li><h3 id="为目标添加库文件搜索路径"><a href="#为目标添加库文件搜索路径" class="headerlink" title="为目标添加库文件搜索路径"></a>为目标添加库文件搜索路径</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(libA PRIVATE <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure></li><li><h3 id="为目标链接库"><a href="#为目标链接库" class="headerlink" title="为目标链接库"></a>为目标链接库</h3></li></ol>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(myApp PRIVATE libA libB libExternal)<br><span class="hljs-comment">#myqpp是可执行文件（也可以是库文件）</span><br><span class="hljs-comment">#libA，libB，libExternal是库文件</span><br></code></pre></td></tr></table></figure><ol start="8"><li><h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li><p><strong>file(READ)</strong></p><p> 用于将文件内容读取到变量中。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(READ &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;max-in&gt;] [HEX])<br></code></pre></td></tr></table></figure></li><li><p><strong>file(WRITE)</strong></p><p> 用于将内容写入文件。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(WRITE &lt;filename&gt; <span class="hljs-string">&quot;&lt;content&gt;&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(APPEND)</strong></p><p> 用于向文件中追加内容。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(APPEND &lt;filename&gt; <span class="hljs-string">&quot;&lt;content&gt;&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(TOUCH)</strong></p><p> 用于创建空文件或者更新文件的时间戳。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(TOUCH &lt;filename&gt;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><ol><li><p><strong>file(GLOB)</strong></p><p> 用于匹配规则在指定的目录内匹配到所需要的文件。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="hljs-keyword">true</span>[<span class="hljs-keyword">false</span>]] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expression&gt; ...])<br></code></pre></td></tr></table></figure></li><li><p><strong>file(GLOB_RECURSE)</strong></p><p> 用于递归匹配文件，包括子目录中的文件。</p></li><li><p><strong>file(RENAME)</strong></p><p> 用于重命名文件。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(RENAME &lt;old-name&gt; &lt;new-name&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(REMOVE)</strong></p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(<span class="hljs-keyword">REMOVE</span> &lt;filename&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(MAKE_DIRECTORY)</strong></p><p> 用于创建目录。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(<span class="hljs-keyword">MAKE_DIRECTORY</span> &lt;directory&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(COPY)</strong></p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(COPY &lt;files&gt;... DESTINATION &lt;dir&gt; [...])<br></code></pre></td></tr></table></figure></li><li><p><strong>file(INSTALL)</strong></p><p> 用于将文件安装到指定目录中。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(<span class="hljs-keyword">INSTALL</span> &lt;files&gt;... DESTINATION &lt;dir&gt; [...])<br></code></pre></td></tr></table></figure></li></ol><h3 id="路径转换"><a href="#路径转换" class="headerlink" title="路径转换"></a>路径转换</h3><ol><li><p><strong>file(RELATIVE_PATH)</strong></p><p> 用于获取相对路径。</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">cmakeCopy code<br><span class="hljs-built_in">file</span>(RELATIVE_PATH &lt;<span class="hljs-built_in">variable</span>&gt; &lt;<span class="hljs-built_in">directory</span>&gt; &lt;<span class="hljs-built_in">file</span>&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(TO_CMAKE_PATH)</strong></p><p> 用于将路径转换为CMake风格的路径。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cmakeCopy <span class="hljs-selector-tag">code</span><br><span class="hljs-function"><span class="hljs-title">file</span><span class="hljs-params">(TO_CMAKE_PATH &lt;path&gt; &lt;variable&gt;)</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>file(TO_NATIVE_PATH)</strong></p><p> 用于将路径转换为本地操作系统风格的路径。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cmakeCopy <span class="hljs-selector-tag">code</span><br><span class="hljs-function"><span class="hljs-title">file</span><span class="hljs-params">(TO_NATIVE_PATH &lt;path&gt; &lt;variable&gt;)</span></span><br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h3><p> 查ai</p></li></ol><h1 id="添加外部库实战"><a href="#添加外部库实战" class="headerlink" title="添加外部库实战"></a>添加外部库实战</h1><h2 id="boost库"><a href="#boost库" class="headerlink" title="boost库"></a>boost库</h2><ol><li><p>执行命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install libboost-all-dev<br></code></pre></td></tr></table></figure></li><li><p>在CMake中找到Boost库</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(MyComplexProject VERSION <span class="hljs-number">1.0</span>)<br><br><span class="hljs-comment"># 设置全局C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment">#设置可执行文件和库的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/libs)<span class="hljs-comment">#动态库</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/archive)<span class="hljs-comment">#静态库</span><br><br><span class="hljs-comment"># 找到Boost库</span><br><span class="hljs-keyword">find_package</span>(Boost <span class="hljs-number">1.65</span> REQUIRED COMPONENTS system filesystem)<br><br><span class="hljs-comment"># 如果找到了Boost，包括Boost的头文件目录</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;找到了Boost库 $&#123;Boost_VERSION_MAJOR&#125;.$&#123;Boost_VERSION_MINOR&#125;.$&#123;Boost_VERSION_PATCH&#125; in $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(external)<br><span class="hljs-keyword">add_subdirectory</span>(lib)<br><span class="hljs-keyword">add_subdirectory</span>(app)<br><span class="hljs-keyword">add_subdirectory</span>(tests)<br></code></pre></td></tr></table></figure></li><li><p>链接Boost库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(myApp src/main.cpp)<br><span class="hljs-comment"># 链接Boost库</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;链接成功：Boost_INCLUDE_DIRS: $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">target_link_libraries</span>(myApp PRIVATE <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">target_link_libraries</span>(myApp PRIVATE libA libB libExternal)<br><span class="hljs-keyword">target_include_directories</span>(myApp PRIVATE <br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libA <br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libB<br>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="opencv库"><a href="#opencv库" class="headerlink" title="opencv库"></a>opencv库</h2><h2 id="Json库"><a href="#Json库" class="headerlink" title="Json库"></a>Json库</h2><h1 id="根CMakeLists-txt文件"><a href="#根CMakeLists-txt文件" class="headerlink" title="根CMakeLists.txt文件"></a>根CMakeLists.txt文件</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-comment"># 设置项目名称和版本</span><br><span class="hljs-keyword">project</span>(MyComplexProject VERSION <span class="hljs-number">1.0</span>)<br><br><span class="hljs-comment"># 设置全局 C++ 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 如果没有指定构建类型，则默认设置为 Debug</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>    <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;构建类型: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class="hljs-comment"># 设置可执行文件和库的输出目录</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;可执行文件输出目录: $&#123;CMAKE_SOURCE_DIR&#125;/bin&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;动态库输出目录: $&#123;CMAKE_SOURCE_DIR&#125;/lib&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;静态库输出目录: $&#123;CMAKE_SOURCE_DIR&#125;/archive&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)  <span class="hljs-comment"># 可执行文件</span><br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)  <span class="hljs-comment"># 动态库</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/archive)  <span class="hljs-comment"># 静态库</span><br><br><span class="hljs-comment"># 设置 CMake 以查找 Boost 的动态库</span><br><span class="hljs-keyword">set</span>(Boost_USE_STATIC_LIBS <span class="hljs-keyword">OFF</span>)        <span class="hljs-comment"># 只使用 Boost 的动态库</span><br><span class="hljs-keyword">set</span>(Boost_USE_MULTITHREADED <span class="hljs-keyword">ON</span>)       <span class="hljs-comment"># 使用多线程版本的 Boost</span><br><span class="hljs-keyword">set</span>(Boost_USE_STATIC_RUNTIME <span class="hljs-keyword">OFF</span>)     <span class="hljs-comment"># 不使用 Boost 静态运行时库</span><br><br><span class="hljs-comment"># 查找 Boost 库</span><br><span class="hljs-keyword">find_package</span>(Boost <span class="hljs-number">1.65</span> REQUIRED COMPONENTS system filesystem)<br><br><span class="hljs-comment"># 如果找到了 Boost，则包含 Boost 的头文件目录</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;找到了 Boost 库 $&#123;Boost_VERSION_MAJOR&#125;.$&#123;Boost_VERSION_MINOR&#125;.$&#123;Boost_VERSION_PATCH&#125; 在 $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><br><span class="hljs-comment"># 添加源代码子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(server)<br><span class="hljs-keyword">add_subdirectory</span>(src)<br><br><span class="hljs-comment"># 根据构建类型添加编译器标志</span><br><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Debug&quot;</span>)<br>    <span class="hljs-keyword">add_compile_options</span>(-g -O0 -Wall -Wextra -Werror)  <span class="hljs-comment"># Debug模式的编译器标志</span><br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">add_compile_options</span>(-O2)  <span class="hljs-comment"># 非Debug模式的优化选项</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>Cmake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用指令</title>
    <link href="/2023/12/10/vim/"/>
    <url>/2023/12/10/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="一般命令模式"><a href="#一般命令模式" class="headerlink" title="一般命令模式"></a>一般命令模式</h2><ul><li>0：将光标移动到本行开头</li><li>$：将光标移动到本行末尾</li><li>G：将光标移动到最后一行</li><li>gg：将光标移动到第一行</li><li>:n或者nG(n为数字)：将光标移动到第n行</li><li>n&lt;Space&gt;：将光标向后移动n格（会换行）</li><li>n&lt;Enter&gt;：将光标向下移动n行</li><li>重复前一次操作（结合命令模式的查找）</li></ul><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>无常用操作</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li>&#x2F;word：光标位置下查找第一个word字符串</li><li>?word：光标位置上查找第一个word字符串</li><li>n：重复上一次操作，配合查找使用</li><li>N：反向重复上一次操作</li><li>:noh：关闭查找后的高亮</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：将$[n1,n2]$行所有的word1替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：全文替换，将全文word1替换为word2，并且替换前要求用户确认</li><li>v：选中文本，按两下   Esc  取消选中</li><li>d：剪切选中文本（开启删除模式）</li><li>dd：剪切一行</li><li>y：复制选中文本</li><li>yy：复制一行</li><li>p：将剪切的内容复制到<strong>光标的下一个位置（或者下一行）</strong>，这个取决于是否剪切（复制）一行</li><li>u：撤销</li><li>Ctrl+r：取消撤销</li><li>Shrift+&gt;：将选中的内容向右移动</li><li>Shritf+&lt;：将选中的内容向左移动</li><li>:set paste：设置成粘贴模式</li><li>:set nopaste：设置成非粘贴模式</li><li>:set nu：显示行号</li><li>:set nonu：取消显示行号</li></ul><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><ul><li>gg d G：删除所有内容     行号+d+行号</li><li>5G d 10G：删除$[5,10]$行的所有内容</li><li>gg &#x3D; G：格式化整个文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode配置</title>
    <link href="/2023/12/05/vscode%E8%B0%83%E8%AF%95/"/>
    <url>/2023/12/05/vscode%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>本文介绍vscode里的相关配置</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="对于-词-的操作："><a href="#对于-词-的操作：" class="headerlink" title="对于 词 的操作："></a>对于 <strong>词</strong> 的操作：</h2><ul><li>选中一个词：ctrl<code> + d</code></li></ul><h2 id="搜索或者替换："><a href="#搜索或者替换：" class="headerlink" title="搜索或者替换："></a>搜索或者替换：</h2><ul><li>ctrl<code> + f</code> ：搜索</li><li>ctrl<code> + alt + f</code>： 替换</li><li>ctrl<code> + shift + f</code>：在项目内搜索</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>通过<strong>Ctrl + &#96;</strong> 可以打开或关闭终端</li><li>Ctrl+P 快速打开最近打开的文件</li><li>Ctrl+Shift+N 打开新的编辑器窗口</li><li>Ctrl+Shift+W 关闭编辑器</li><li>Home 光标跳转到行头</li><li>End 光标跳转到行尾</li><li>Ctrl + Home 跳转到页头</li><li>Ctrl + End 跳转到页尾</li><li>Ctrl + Shift + [ 折叠区域代码</li><li>Ctrl + Shift + ] 展开区域代码</li><li>Ctrl + &#x2F; 添加关闭行注释</li><li>Shift + Alt +A 块区域注释</li><li><strong>Ctrl+Shift+P</strong> <strong>强大的</strong>命令窗口</li></ol><h1 id="Json讲解"><a href="#Json讲解" class="headerlink" title="Json讲解"></a>Json讲解</h1><p><strong>牢记</strong><code>&#123; &#125;</code>中的内容表示一个对象，<code>[ ]</code>中的内容表示一个数组。</p><h2 id="task-json"><a href="#task-json" class="headerlink" title="task.json"></a>task.json</h2><p>tasks.json可以编辑多个任务，只需要在tasks后继续添加即可，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;HelloTask&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;echo Hello&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;ByeTask&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;echo bye&quot;</span><br>        &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面分别创建了HelloTask和ByeTask两个任务。</p></blockquote><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++恶心知识点</title>
    <link href="/2023/12/05/c++%E7%96%91%E9%9A%BE%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/12/05/c++%E7%96%91%E9%9A%BE%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍c-常用知识点"><a href="#本文介绍c-常用知识点" class="headerlink" title="本文介绍c++常用知识点"></a>本文介绍c++常用知识点</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call</span><span class="hljs-params">(function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span> x)&gt;f)</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">12</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">auto</span> f=[&amp;x](<span class="hljs-type">int</span> y)&#123;<br>       x=y;<br>    &#125;;<br>    <span class="hljs-built_in">call</span>(f);<br>    cout&lt;&lt;x&lt;&lt;endl;<span class="hljs-comment">//x=12</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">v</span>(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v[i]=i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:v)&#123;<br>        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//9 8 7 6 5 4 3 2 1 0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存溢出和内存泄漏，数组越界"><a href="#内存溢出和内存泄漏，数组越界" class="headerlink" title="内存溢出和内存泄漏，数组越界"></a>内存溢出和内存泄漏，数组越界</h2><ul><li><strong>内存溢出（Memory Overflow）</strong>：这通常发生在试图分配的内存超过了系统可用内存的情况。例如，在一个有限的内存空间中创建太多对象或数据结构。</li><li><strong>内存泄漏（Memory Leak）</strong>：这发生在分配的内存没有得到适当释放的时候。如果程序反复分配内存而不释放，最终可能耗尽系统资源。</li><li><strong>数组越界（Array Index Out of Bound）</strong>：当试图访问数组之外的索引时发生。这是常见的编程错误，可能导致程序崩溃或不可预期的行为</li></ul><h2 id="多线程和多进程的关系"><a href="#多线程和多进程的关系" class="headerlink" title="多线程和多进程的关系"></a>多线程和多进程的关系</h2><ul><li><strong>多线程（Multithreading）</strong>：在一个进程内部，可以创建多个线程，这些线程共享相同的内存空间和资源，但可以并行执行不同的任务。多线程适用于轻量级的并行任务，尤其是在需要共享大量数据时。</li><li><strong>多进程（Multiprocessing）</strong>：每个进程有自己独立的内存空间和资源。多进程可以在不同的CPU核心上并行执行，适用于需要隔离和安全性的重量级任务。进程间通信比线程间通信更复杂和开销更大。</li></ul><h2 id="指针字节"><a href="#指针字节" class="headerlink" title="指针字节"></a>指针字节</h2><ul><li>在 32 位系统上，指针的大小通常是 4 字节（32 位）。</li><li>在 64 位系统上，指针的大小通常是 8 字节（64 位）。、</li></ul><p>去除x的第一个字节的数字（可以判断大端序小端序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br>    cout&lt;&lt;(<span class="hljs-type">int</span>)*(<span class="hljs-type">char</span>*)&amp;x;<span class="hljs-comment">//x占4字节，char*取出第一字节，转化为int类型输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历x的每个字节并打印输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        cout&lt;&lt;(<span class="hljs-type">int</span>)*((<span class="hljs-type">char</span>*)&amp;x+i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>任何类型的指针都是4字节</p></li><li><p>char*指向的内存为1字节，int*指向的内存为4字节</p></li></ul><p><strong><code>char*</code> 和 <code>int*</code> 指针的增加区别</strong>:</p><ul><li>当您对 <code>char*</code> 类型的指针执行 <code>++</code> 操作时，指针将向前移动 1 字节，因为 <code>char</code> 的大小是 1 字节。</li><li>相比之下，对 <code>int*</code> 类型的指针执行 <code>++</code> 操作时，指针将向前移动 <code>sizeof(int)</code> 字节，通常是 4 字节（这取决于编译器和系统架构）。</li><li>这反映了指针的算术操作是基于它们指向的数据类型的大小。</li></ul><h2 id="类里面尽量用指针"><a href="#类里面尽量用指针" class="headerlink" title="类里面尽量用指针"></a>类里面尽量用指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    A* a; <span class="hljs-comment">//不允许写成A a(不允许使用不完整的类型)</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-库目录和头文件目录"><a href="#C-库目录和头文件目录" class="headerlink" title="C++ 库目录和头文件目录"></a>C++ 库目录和头文件目录</h2><ul><li><strong>头文件目录</strong>：这是存放 C++ 头文件（通常以 <code>.h</code> 或 <code>.hpp</code> 结尾）的目录。这些头文件包含了类定义、模板和函数声明等。</li><li><strong>库目录</strong>：这是存放编译后的库文件的目录。对于静态库，通常是 <code>.a</code> 或 <code>.lib</code> 文件；对于动态库（共享库），是 <code>.so</code>（在 Linux 上）或 <code>.dll</code>（在 Windows 上）文件。</li></ul><h2 id="在-Linux-下指定动态链接库的目录"><a href="#在-Linux-下指定动态链接库的目录" class="headerlink" title="在 Linux 下指定动态链接库的目录:"></a>在 Linux 下指定动态链接库的目录:</h2><ul><li><strong>运行时指定动态链接库的目录</strong>:<ul><li>如果动态链接库不在标准的库目录（如 <code>/lib</code> 或 <code>/usr/lib</code>）中，可以通过设置环境变量 <code>LD_LIBRARY_PATH</code> 来指定额外的库搜索路径。</li><li><code>LD_LIBRARY_PATH</code> 环境变量包含一系列目录，运行时链接器（dynamic linker）将在这些目录中搜索动态链接库。</li><li>如果 <code>LD_LIBRARY_PATH</code> 没有正确设置，当程序尝试加载一个不在标准路径中的库时，会报错，如 “cannot open shared object file” 或类似的消息。</li></ul></li><li><strong>编译时指定动态链接库的目录</strong>:<ul><li>在编译阶段，使用 <code>g++</code> 或其他编译器时，确实需要指定动态链接库的位置，这样编译器能够正确链接这些库。</li><li>通过 <code>-L</code> 选项指定库所在的目录，例如 <code>g++ -L/path/to/library</code>。</li><li>同时，使用 <code>-l</code> 选项指定要链接的库的名称，例如 <code>g++ -lmylibrary</code>，这里 <code>mylibrary</code> 是库的名称，对应于 <code>libmylibrary.so</code> 文件。</li></ul></li><li><strong>注意事项</strong>:<ul><li>需要注意的是，<code>LD_LIBRARY_PATH</code> 是运行时的设置，而 <code>-L</code> 和 <code>-l</code> 是编译时的设置。</li><li>修改 <code>LD_LIBRARY_PATH</code> 对已经编译好的程序有效，但不会影响未来的编译过程。</li><li>同样，编译时使用的 <code>-L</code> 和 <code>-l</code> 选项不会影响已经编译好的可执行文件的运行。</li></ul></li><li><strong>最佳实践</strong>:<ul><li>尽管可以使用 <code>LD_LIBRARY_PATH</code> 来解决库的查找问题，但最佳实践是将库安装到标准路径，或者在程序的链接阶段正确指定库的位置。</li><li>对于开发和部署，保持一致的库路径有助于避免运行时错误。</li></ul></li></ul><h2 id="make-shared隐患"><a href="#make-shared隐患" class="headerlink" title="make_shared隐患"></a>make_shared隐患</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;<br>        p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]();<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        <span class="hljs-comment">//A类内部new出来的需要手动delete</span><br>        <span class="hljs-keyword">delete</span>[]p;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Hello World&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        <span class="hljs-keyword">private</span>:<br>    &#125;;<br>    B b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">B <span class="hljs-title">getB</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    A::B b=a.<span class="hljs-built_in">getB</span>();<br>    b.<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意作用域</p></blockquote><h2 id="c-的按位取反操作"><a href="#c-的按位取反操作" class="headerlink" title="c++的按位取反操作"></a>c++的按位取反操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">-1e8</span>;i&lt;=<span class="hljs-number">1e8</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(-i!=(~i+<span class="hljs-number">1</span>))&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最终输出yes</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫描线</title>
    <link href="/2023/12/01/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <url>/2023/12/01/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>本文介绍扫描线的几个题目</p><h1 id="二维偏序"><a href="#二维偏序" class="headerlink" title="二维偏序"></a>二维偏序</h1><h2 id="E-World-of-Darkraft-Battle-for-Azathoth"><a href="#E-World-of-Darkraft-Battle-for-Azathoth" class="headerlink" title="E. World of Darkraft: Battle for Azathoth"></a><a href="https://codeforces.com/problemset/problem/1321/E">E. World of Darkraft: Battle for Azathoth</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一些武器和防具，每个武器有<strong>攻击力</strong>，<strong>花费</strong>,每个防具有<strong>防御力</strong>和<strong>花费</strong></p><p>给定一些怪物，每个怪物有<strong>攻击力</strong>，<strong>防御力</strong>，<strong>价值</strong></p><p>你只可以选择一个武器和一个防具，可以获得攻击力小于武器并且防御力小于防具的所有怪物的价值，求最大收益</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将武器和怪物按照攻击力排序，防具自己排序，并且按照防具的防御力防具顺序（id）建立<strong>下标线段树</strong></li><li><strong>双指针</strong>i指向武器，j指向怪物，当i指针向右边移动1个，j指针只会向右边移动，且以后的i一定可以选到当前的怪物j，所以当前的j造成的贡献会一直保留。所以将j的贡献加到线段树中即可</li><li>对于每一个武器i算最大价值，详细见代码</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>ll g;<br>ll c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> A&amp;a)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> g&lt;a.g;<br>&#125;<br>&#125;a[N];<span class="hljs-comment">//gong</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>&#123;<br>ll f;<br>ll c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> B&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> f&lt;b.f;<br>&#125;<br>&#125;b[N];<span class="hljs-comment">//fang</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&#123;<br>ll g,f;<br>ll c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> C&amp;c)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> g&lt;c.g;<br>&#125;<br>&#125;c[N];<span class="hljs-comment">//monster</span><br><br>ll maxn[N&lt;&lt;<span class="hljs-number">2</span>];<br>ll tag[N&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>ll lx=u&lt;&lt;<span class="hljs-number">1</span>;<br>ll rx=u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>;<br>maxn[u]=<span class="hljs-built_in">max</span>(maxn[lx],maxn[rx]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>ll lx=u&lt;&lt;<span class="hljs-number">1</span>;<br>ll rx=u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(tag[u])&#123;<br>maxn[lx]+=tag[u];<br>maxn[rx]+=tag[u];<br>tag[lx]+=tag[u];<br>tag[rx]+=tag[u];<br>&#125;<br>tag[u]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>maxn[u]=-b[l].c;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,ll x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)&#123;<br>maxn[u]+=x;<br>tag[u]+=x;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">pushdown</span>(u);<br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)&#123;<br><span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid,L,R,x);<br>&#125;<br><span class="hljs-keyword">if</span>(R&gt;mid)&#123;<br><span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,L,R,x);<br>&#125;<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n,m,p;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;<br>    <span class="hljs-comment">//输入武器属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i].g&gt;&gt;a[i].c;<br>&#125;<br>    <span class="hljs-comment">//输入防具属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;b[i].f&gt;&gt;b[i].c;<br>&#125;<br>    <span class="hljs-comment">//输入怪物属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br>cin&gt;&gt;c[i].g&gt;&gt;c[i].f&gt;&gt;c[i].c;<br>&#125;<br>    <span class="hljs-comment">//排序</span><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br><span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+m);<br><span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+<span class="hljs-number">1</span>+p);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m);<br>    <br><span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>ll ans=<span class="hljs-number">-1e18</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//暴力加入怪物的价值</span><br><span class="hljs-keyword">while</span>(j&lt;=p&amp;&amp;c[j].g&lt;a[i].g)&#123;<br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=m;<br><span class="hljs-type">int</span> pos=m+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b[mid].f&gt;c[j].f)&#123;<br>pos=mid;<br>r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>l=mid+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>            <span class="hljs-comment">//[pos,m]下标中所有防具需要加上c价值</span><br><span class="hljs-keyword">if</span>(pos&lt;=m)&#123;<span class="hljs-comment">//update</span><br><span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m,pos,m,c[j].c);<br>&#125;<br>++j;<br>&#125;<br>        <span class="hljs-comment">//计算选择当前武器的答案</span><br>ans=<span class="hljs-built_in">max</span>(ans,maxn[<span class="hljs-number">1</span>]-a[i].c);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Number-of-Groups"><a href="#E-Number-of-Groups" class="headerlink" title="E. Number of Groups"></a><a href="https://codeforces.com/contest/1691/problem/E">E. Number of Groups</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一些线段[x,y]，每个线段有一个颜色（0或者1），如果两个不同颜色的线段有交集，那他们在同一组，问有多少不同的组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>将一个线段的x，y看成时间（time），将插入和删除看成时间（event），显然，一个线段的x是插入，y是删除，这是典型的扫描线想法</li><li>按照(time,event)排序，对于插入操作，我们需要知道可以和哪些线段合并，同时自己要记录自己在那个集合中</li><li>显然并查集</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>开两个集合，存每种颜色的线段<strong>右端点</strong>即可</li><li>按照（time，event）排序后，遍历所有点对，如果是插入操作，查询谁跟他一组，暴力合并，如果是删除操作，删除这个点对即可。但是此时会超时，因为每个线段都可以被合并很多次，复杂度不可以保证。</li><li>考虑贪心，若两个0颜色线段在同一个集合中，此时他们肯定都没有删除，此时遍历到第i个<strong>点对</strong>，那么，如果是插入操作，此时只需要和最后一个合并即可（如果可以的话），因为合并的前提是当前点对的time，也就是<code>另一个线段的左端点&lt;=一个线段的左端点要&lt;=另一个线段的右端点</code>，所以贪心即可，边合并边删除即可，具体看代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br>ll n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> col;<br><span class="hljs-type">int</span> l,r;<br>&#125;a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-type">int</span> pos;<br><span class="hljs-type">bool</span> in;<span class="hljs-comment">//是否需要插入</span><br><span class="hljs-type">int</span> id;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> B&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">if</span>(pos!=b.pos)<span class="hljs-keyword">return</span> pos&lt;b.pos;<br><span class="hljs-keyword">if</span>(in!=b.in)<span class="hljs-keyword">return</span> in&gt;b.in;<br><span class="hljs-keyword">return</span> id&lt;b.id;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;B&gt;v;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>f[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i].col&gt;&gt;a[i].l&gt;&gt;a[i].r;<br>v.<span class="hljs-built_in">push_back</span>(&#123;a[i].l,<span class="hljs-number">1</span>,i&#125;);<br>v.<span class="hljs-built_in">push_back</span>(&#123;a[i].r,<span class="hljs-number">0</span>,i&#125;);<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;p[<span class="hljs-number">2</span>];<span class="hljs-comment">//0表示第一个集合，1表示第二个集合</span><br><span class="hljs-comment">//pos,id</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> qq:v)&#123;<br><span class="hljs-type">int</span> id=qq.id;<span class="hljs-comment">//id</span><br><span class="hljs-type">bool</span> in=qq.in;<span class="hljs-comment">//in</span><br><span class="hljs-type">int</span> pos=qq.pos;<span class="hljs-comment">//pos</span><br><span class="hljs-type">int</span> col=a[id].col;<span class="hljs-comment">//col</span><br><span class="hljs-keyword">if</span>(in)&#123;<br><span class="hljs-comment">//插入到本集合中</span><br>p[col].<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(a[id].r,id));<br><span class="hljs-comment">//匹配另外一个集合的元素，并且保留最后一个</span><br><span class="hljs-keyword">while</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>f[<span class="hljs-built_in">find</span>(id)]=<span class="hljs-built_in">find</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()-&gt;second);<br>p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>());<br>&#125;<br>            <span class="hljs-comment">//最后一个还没验证是否可以合并呢</span><br><span class="hljs-keyword">if</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>f[<span class="hljs-built_in">find</span>(id)]=<span class="hljs-built_in">find</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()-&gt;second);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>p[col].<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">make_pair</span>(a[id].r,id));<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==i)ans++;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P4137-Rmq-Problem-mex"><a href="#P4137-Rmq-Problem-mex" class="headerlink" title="P4137 Rmq Problem &#x2F; mex"></a><a href="https://www.luogu.com.cn/problem/P4137">P4137 Rmq Problem &#x2F; mex</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个序列，多次询问，区间mex是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>莫队秒了</li><li>权值线段树扫描线，扫描序列，到达第i个位置的时候，处理以第i个位置为右端点的所有询问。转化为求最小的x，满足$pos[x]&lt;l$,x就是第id个询问的答案,显然可以用线段树二分。</li><li>只需要将权值x当成下标就可以，支持更新pos[x]，和区间查询即可</li><li>注意权值从0开始</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>莫队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><p>权值线段树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> minn[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>minn[u] = <span class="hljs-built_in">min</span>(minn[u &lt;&lt; <span class="hljs-number">1</span>], minn[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">//修改pos为x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>minn[u] = x;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;<br><span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, pos, x);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, x);<br>&#125;<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-comment">//在L到R内查询比tar小的最小的下标（pos[x]&lt;tar,最小的x)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> tar)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br><span class="hljs-keyword">if</span> (minn[u] &lt; tar)<br><span class="hljs-keyword">return</span> l;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;<br><span class="hljs-type">int</span> ans = n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span>] &lt; tar) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, tar);<br>&#125;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] &lt; tar) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, tar);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> ans = n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span>] &lt; tar &amp;&amp; L &lt;= mid) &#123;<br>ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, tar));<br>&#125;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]&lt;tar &amp;&amp; R&gt;mid) &#123;<br>ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, tar));<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i];<br>a[i] = <span class="hljs-built_in">min</span>(a[i], n + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-type">int</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br>v[r].<span class="hljs-built_in">push_back</span>(&#123; l,i &#125;);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>, a[i], i);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> que : v[i]) &#123;<br><span class="hljs-type">int</span> l = que.first;<br><span class="hljs-type">int</span> id = que.second;<br>ans[id] = <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, l);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>cout &lt;&lt; ans[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>扫描线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容斥原理</title>
    <link href="/2023/11/30/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/30/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="线性容斥"><a href="#线性容斥" class="headerlink" title="线性容斥"></a>线性容斥</h1><h2 id="D-Counting-Rhyme"><a href="#D-Counting-Rhyme" class="headerlink" title="D. Counting Rhyme"></a><a href="https://codeforces.com/contest/1884/problem/D">D. Counting Rhyme</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题目大意：有一个长度为n的数组a，如果对于一个数个(a[i],a[j]）满足不存在a[k]使a[i]%a[k]&#x3D;0且a[j]%a[k]&#x3D;0，则称这个数对是合法的，求合法数对的数量。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>对于任意一个a[k],如果这个数合法,则**没有点对（i，j)**，满足$gcd(a[i],a[j])%a[k]&#x3D;0$</p></li><li><p>考虑单点贡献，因为点对贡献是$O(n^2)$的复杂度</p></li><li><p>考虑dp，设$dp[g]$表示$gcd(a[i],a[j])&#x3D;g$的点对数，则$ans&#x3D;\sum_{a_k\nmid g\forall k\in[1,n]}dp_g$</p></li><li><p>具体如何求$dp[g]$：如果我们知道一个多重集合中，任意两个数的gcd都是g的倍数，那么就好做了</p><p> <code>dp[g]=C(cnt,2)-dp[2*g]-dp[3*g]-…dp[k*g]</code>(C表示组合数，cnt表示集合中的多重集中元素个数)</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br>ll dp[N];<br>ll a[N];<br>ll cnt[N];<br>ll n;<br><span class="hljs-type">bool</span> biaoji[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>dp[i]=cnt[i]=biaoji[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>cnt[a[i]]++;<br>&#125;<br>ll zong=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll g=n;g&gt;=<span class="hljs-number">1</span>;g--)&#123;<br>ll sum=cnt[g];<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">2</span>;k*g&lt;=n;k++)&#123;<br>dp[g]-=dp[k*g];<br>sum+=cnt[k*g];<br>&#125;<br>dp[g]+=sum*(sum<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!cnt[i])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j*i&lt;=n;j++)&#123;<br>biaoji[j*i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//有存在的a[k]使得这个gcd做不了贡献！！</span><br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!biaoji[i])&#123;<br>ans+=dp[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，最后要算点对数，而不是a[k]的数目，所以关键是判断哪些点对合法。</p><p>而dp[g]就是表示gcd恰好等于g的所有点对数，所以只需要判断哪些g合法即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>exgcd</title>
    <link href="/2023/11/30/exgcd/"/>
    <url>/2023/11/30/exgcd/</url>
    
    <content type="html"><![CDATA[<h1 id="exgcd反向应用"><a href="#exgcd反向应用" class="headerlink" title="exgcd反向应用"></a>exgcd反向应用</h1><h2 id="ICPC2022杭州A-Modulo-Ruins-the-Legend"><a href="#ICPC2022杭州A-Modulo-Ruins-the-Legend" class="headerlink" title="ICPC2022杭州A. Modulo Ruins the Legend"></a><a href="https://codeforces.com/gym/104090/problem/A">ICPC2022杭州A. Modulo Ruins the Legend</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个n和m，给一个数列a，求一个等差数列b，满足$\sum(a_i+b_i)$模m最小，求s和d，s&gt;&#x3D;0,d&gt;&#x3D;0</p><p>其中$b_i&#x3D;s+d*i$.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>假设sum&#x3D;$\sum(a_i)$,则可以看成求$sum+n<em>s+(n+1)<em>n&#x2F;2</em>d&#x3D;k</em>m+ans$</p><p> 其中ans就是我们要求的最小值</p></li><li><p>先<code>sum%=m</code>，设<code>A=n,B=(n+1)*n/2</code>，则利用exgcd化成$A<em>x+B</em>y+sum&#x3D;k*m+ans$</p></li><li><p>设$A<em>x+B</em>y&#x3D;k_1<em>gcd(A,B)$,则化成$k_1</em>gcd(A,B)-k_2*m&#x3D;ans-sum$</p></li><li><p>容易知道$ans\in[0,m-1]$,则$ans-sum\in[-sum,-sum+m-1]$,在确定最小的ans后，解出k1</p></li><li><p>解出k1，反解出x和y，再利用m求解即可，具体看代码</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<br>ll n,m;<br>ll sum;<br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b,__int128 &amp;x,__int128 &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)<br>    &#123;<br>        x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    ll d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y-=(a/b*x);<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>ll x;<br>cin&gt;&gt;x;<br>sum+=x;<br>&#125;<br>sum%=m;<br>ll A=n,B=(n+<span class="hljs-number">1</span>)*n/<span class="hljs-number">2</span>;<br>ll g=__gcd(A,B);<br><br><span class="hljs-comment">//k1*g+sum=k2*m+ans;</span><br><span class="hljs-comment">//k1*g-k2*m=ans-sum=k3*gcd(g,m)</span><br><br>__int128 x,y;<br>ll t=<span class="hljs-built_in">exgcd</span>(g,m,x,y);<span class="hljs-comment">//t&gt;0</span><br>ll ans=sum%t;<br>x*=(ans-sum)/t;<span class="hljs-comment">//k1</span><br><br>ll k1=x;<br><span class="hljs-comment">//A*x+B*y=k1g</span><br>t=<span class="hljs-built_in">exgcd</span>(A,B,x,y);<span class="hljs-comment">//t&gt;0</span><br>x*=k1;<br>y*=k1;<br><br><span class="hljs-comment">//A*x+B*y-k*m=ans-sum</span><br>x=(x%m+m)%m;<br>y=(y%m+m)%m;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br>cout&lt;&lt;(ll)x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;(ll)y&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有几点特别重要！！！</p><ol><li>我们注意到，题目要求s和d都为<code>非负数</code>（代码中是x和y），但是我们在求解的过程中，没有管k1，k2的正负，更没有管x和y的正负</li><li>而且x和y最后都利用m缩小到[0,m-1]的范围内，这好像也没什么逻辑</li><li>关于第2点，注意到，<strong>换元k1相当于</strong>$A<em>x+B</em>y-k_2<em>m&#x3D;ans-sum$，第一次求出的x和y一定是方程的解，但是正负不确定。但是，我可以使$x&#x3D;x+k3</em>m,y&#x3D;y+k4*m$,再利用k2削减掉多出来的m，此时方程仍然成立，也就保证了正确性</li><li>注意exgcd只可以处理$A<em>x+B</em>y&#x3D;ans-sum$,不可以处理$A<em>x+B</em>y-k*m&#x3D;ans-sum$,不可以跳步！！</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2023/11/29/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2023/11/29/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍树形dp比较难的状态设计和考虑方式</p><h1 id="边贡献型"><a href="#边贡献型" class="headerlink" title="边贡献型"></a>边贡献型</h1><p>贡献放置到边上</p><h2 id="P3177-HAOI2015-树上染色"><a href="#P3177-HAOI2015-树上染色" class="headerlink" title="P3177 [HAOI2015] 树上染色"></a><a href="https://www.luogu.com.cn/problem/P3177">P3177 [HAOI2015] 树上染色</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵点数为 <em>n</em> 的树，树边有边权。给你一个在 0∼<em>n</em> 之内的正整数 <em>k</em> ，你要在这棵树中选择 <em>k</em> 个点，将其染成黑色，并将其他的 <em>n</em>−<em>k</em> 个点染成白色。将所有点染色后，你会获得<strong>黑点两两之间</strong>的距离加上<strong>白点两两之间</strong>的距离的和的收益。问收益最大值是多少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>设dp[u][j]表示以u为根的子树中，选j个黑色点，获取到的最大价值（这个价值只是在子树<strong>内部</strong>的价值，子树外部的价值不算），答案是dp[root][k]</li><li>可能现在还不理解1，那么看转移方程：<br> <code>dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]+val)</code>,这个val是v子树中选k个点，u和v<strong>直连边</strong>可以贡献的价值，这个价值很好算，看代码即可。</li><li>代码中计算val没有用到j，只是用到了k，那可能会有疑问，为什么要这样设计j这一维度呢？？因为可以转移，背下来即可。</li><li><strong>转移的正确性</strong>:我们说v是u的儿子，但实际上，我们在进行<strong>合并操作</strong>，因为当利用v计算u的时候，<strong>v并没有看成在u中</strong>，所以是合并操作。<strong>这样第3条就解释通了</strong>：我们需要将u”子树“”和v”子树”合并，而合并的之前，u，v内部如何选择黑色点是毫无关系的，而且获取到的最大价值<strong>只</strong>在自己子树内部，而且已经被统计好。dp的含义是<strong>内部边</strong>的价值，所以需要j那一维度。</li><li>注意代码中状态计算的方式，只有这种方式才可以保证复杂度是$O(n^2)$</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=N*<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> idx;<br>ll h[N],e[M],ne[M],w[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>e[++idx]=b;<br>w[idx]=c;<br>ne[idx]=h[a];<br>h[a]=idx;<br>&#125;<br><br>ll n,m;<br>ll siz[N];<br>ll dp[N][N];<span class="hljs-comment">//以u为根的子树，恰好选了j个黑色点的最大收益(收益是内部边的收益)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br><span class="hljs-type">static</span> ll tem[N];<span class="hljs-comment">//辅助数组</span><br>siz[u]=<span class="hljs-number">1</span>;<br>dp[u][<span class="hljs-number">0</span>]=dp[u][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<span class="hljs-comment">//枚举层，所有儿子在同一层，按照访问儿子的先后顺序划分层</span><br><span class="hljs-type">int</span> v=e[i];<br><span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v,u);<span class="hljs-comment">//要siz[j]和dp[j][]数组</span><br><br>        <span class="hljs-comment">//必须先初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=siz[u]+siz[v];i++)&#123;<br>tem[i]=<span class="hljs-number">-1e9</span>;<br>&#125;<br>        <br>        <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=siz[u];j++)&#123;<span class="hljs-comment">//前层子树,一共选j个点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=siz[v];k++)&#123;<span class="hljs-comment">//新子树选k个</span><br><span class="hljs-keyword">if</span>(j+k&lt;=m)&#123;<span class="hljs-comment">//只有合法才可以转移</span><br>ll val=(ll)(k*(m-k)+(siz[v]-k)*(n-m-siz[v]+k))*w[i];  <span class="hljs-comment">//当前情况下连接子节点的边的贡献</span><br>tem[j+k]=<span class="hljs-built_in">max</span>(tem[j+k],dp[u][j]+dp[v][k]+val);<br>&#125;<br>&#125;<br>&#125;<br>        <br><span class="hljs-comment">//合并两颗树</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=siz[u]+siz[v];j++)&#123;<br>dp[u][j]=tem[j];<br>&#125;<br>siz[u]+=siz[v];<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br><span class="hljs-built_in">add</span>(b,a,c);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][m]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="牛客多校Tree"><a href="#牛客多校Tree" class="headerlink" title="牛客多校Tree"></a><a href="https://ac.nowcoder.com/acm/contest/57360/A">牛客多校Tree</a></h2><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵树，每个点选择黑、白有对应的代价，定义一棵树的收益为所有黑白点对间路径边权最大值的和，问如何选择每个点的颜色使得收益-代价最大？</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>因为边权最大值才可以算贡献，所以建立kruskal重构树，这样<strong>边的贡献只会在子树内部</strong>,所以可以用树形dp做</li><li>设dp[u][j]表示以u为根的子树中选j个黑色点的最大价值，此时价值只会统计到u子树的内部</li><li>重构树是二叉堆，这样很好的诠释了“合并”的思想，而且，我们<strong>只需要知道</strong>合并后的那颗树的信息,因为只有这样的信息，才会被后续用到。</li><li>上一题，v一旦被合并到u中，v的信息就再也用不到了，实际上我们也可以将u的信息合并到v中，但是不方便，因为我们还要计算u与它的father的边的贡献。</li><li>注意代码中状态计算的方式，只有这种方式才可以保证复杂度是$O(n^2)$</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=N;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll n;<br>ll a[N];<br>ll cost[N];<br>ll dp[N][N];<span class="hljs-comment">//以u为根的子树中，选择黑色点的个数为j的最大价值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>ll u,v,w;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> A&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> w&lt;b.w;<br>&#125;<br>&#125;ed[M];<br><br><span class="hljs-type">int</span> siz[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ll u,ll v,ll w)</span></span>&#123;<br><span class="hljs-type">static</span> ll tem[N];<br>u=<span class="hljs-built_in">find</span>(u),v=<span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(siz[u]&gt;siz[v])<span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-type">int</span> n=siz[u],m=siz[v];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+m;i++)<br>tem[i]=<span class="hljs-number">-1e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//枚举前层子树(v)的黑色点个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//枚举新子树(u)的黑色点个数</span><br>ll cnt=(ll)i*(n-j)+(ll)(m-i)*j;<br>tem[i+j]=<span class="hljs-built_in">max</span>(tem[i+j],dp[v][i]+dp[u][j]+cnt*w);<br>&#125;<br>&#125;<br>f[u]=v;<br>siz[v]+=siz[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n+m;j++)<br>dp[v][j]=tem[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>siz[i]=<span class="hljs-number">1</span>;<br>f[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;cost[i];<br>dp[i][<span class="hljs-number">0</span>]=(a[i]==<span class="hljs-number">0</span>)?<span class="hljs-number">0</span>:-cost[i];<br>dp[i][<span class="hljs-number">1</span>]=(a[i]==<span class="hljs-number">1</span>)?<span class="hljs-number">0</span>:-cost[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>ll a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>ed[i]=&#123;a,b,c&#125;;<br>&#125;<br><span class="hljs-built_in">sort</span>(ed+<span class="hljs-number">1</span>,ed+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>ll u=ed[i].u;<br>ll v=ed[i].v;<br>ll w=ed[i].w;<br><span class="hljs-built_in">merge</span>(u,v,w);<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>ans=<span class="hljs-built_in">max</span>(ans,dp[<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>)][i]);<br>cout&lt;&lt;ans&lt;&lt;endl;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>所有边的贡献必须在子树内部才可以用这种方法，尤其注意第一种，为什么要那样设计状态</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kruskal重构树</title>
    <link href="/2023/11/27/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    <url>/2023/11/27/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="克鲁斯卡尔重构树"><a href="#克鲁斯卡尔重构树" class="headerlink" title="克鲁斯卡尔重构树"></a>克鲁斯卡尔重构树</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>区间点可相互到达时考虑</li><li>连通块题目考虑</li><li>用到的边是“连通块内的最小生成树”时考虑</li></ol><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>所有原节点都为叶子节点</li><li>有<code>2*n-1</code>个节点，<code>叶</code>子是<code>点</code>权，<code>非</code>叶子是<code>边</code>权</li><li>任何两个叶子节点可以相互到达，<code>一定</code>是通过了他们的LCA所代表的那条<code>边</code>到达的。</li><li>重构树一定是小根堆或者大根堆（针对于点的id，针对于点的“边权”）</li><li>选出一些点可以互相到达，且最大边权不可以超过x，则答案是<code>非叶节点</code>中点权<code>大于等于x</code>的所有子树中的点</li></ol><h2 id="注意（性质）"><a href="#注意（性质）" class="headerlink" title="注意（性质）"></a>注意（性质）</h2><ol><li>重构树中的 <code>非叶子</code> 点权不一定都不相同，但是<code>根</code>的点权一定最大</li><li>重构树一定是<code>堆</code></li><li>在重构树上若到达某个<code>非叶</code>子节点 x，则x子树的所有<code>叶子</code>节点，都可以相互到达。</li><li>重构树中，若一个区间的点可以相互到达，求需要经过的边权的<code>最小值</code>？答案为<code>max&#123;LCA(L,L+1),LCA(L+1,L+2),…,LCA(R-2,R-1)&#125;</code>，此时可以用<code>线段树维护区间最大值</code>解决多组询问</li></ol><p><strong>对于4的证明</strong>：</p><p>设4中求出的答案为t，则L和L+1可以相互到达，L+1和L+2可以相互到达…，所以任意两个点都可以相互到达。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="E-Qpwoeirut-and-Vertices"><a href="#E-Qpwoeirut-and-Vertices" class="headerlink" title="E. Qpwoeirut and Vertices"></a><a href="https://codeforces.com/contest/1706/problem/E">E. Qpwoeirut and Vertices</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给我们一个无向无权图（n个点，m条边，边有编号），若干个询问（q组），每次询问给我们一个区间<code>[ l , r ] </code>，问我们只经过前k条边使得该<strong>区间</strong>内任意两点可以互相到达的k的<strong>最小值</strong>。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>将边的id看成边权，建立重构树</li><li>预处理lca数组</li><li>对于区间[l,r]内，若这个区间的点可以相互到达，只需要求出LCA(l,l+1,…r-1)的点权即可</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><br>ll n,m,qq;<br>ll f[N],a[N];<br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><br><span class="hljs-type">int</span> ans[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>e[++idx]=v;<br>ne[idx]=h[u];<span class="hljs-comment">//clear</span><br>h[u]=idx;<br>&#125;<br><br><span class="hljs-comment">//find</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-comment">//LCA</span><br>ll fa[N][<span class="hljs-number">21</span>],deep[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>idx=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxn=<span class="hljs-number">2</span>*n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)&#123;<br>deep[i]=a[i]=h[i]=<span class="hljs-number">0</span>;<br>f[i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">20</span>;j++)&#123;<br>fa[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><br>deep[j]=deep[u]+<span class="hljs-number">1</span>;<br>fa[j][<span class="hljs-number">0</span>]=u;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;<br><span class="hljs-type">int</span> anc=fa[j][k<span class="hljs-number">-1</span>];<br>fa[j][k]=fa[anc][k<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(j);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//lca返回的是点的id</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;  <br><span class="hljs-keyword">if</span>(deep[u]&lt;deep[v])<span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br><span class="hljs-type">int</span> anc=fa[u][k];<br><span class="hljs-keyword">if</span>(deep[anc]&gt;=deep[v])&#123;<br>u=anc;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">return</span> u;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br><span class="hljs-type">int</span> anc1=fa[u][k];<br><span class="hljs-type">int</span> anc2=fa[v][k];<br><span class="hljs-keyword">if</span>(anc1!=anc2)&#123;<br>u=anc1;<br>v=anc2;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><br><br>ll maxn[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>maxn[u]=<span class="hljs-built_in">max</span>(maxn[u&lt;&lt;<span class="hljs-number">1</span>],maxn[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>maxn[u]=ans[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)&#123;<br><span class="hljs-keyword">return</span> maxn[u];<br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">ask</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid,L,R));<br>&#125;<br><span class="hljs-keyword">if</span>(R&gt;mid)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">ask</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,L,R));<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;qq;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>u=<span class="hljs-built_in">find</span>(u),v=<span class="hljs-built_in">find</span>(v);<br>        <br>        <span class="hljs-comment">//注意这句</span><br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">continue</span>;<br>a[++n]=i;<span class="hljs-comment">//val</span><br>f[u]=n,f[v]=n;<br><span class="hljs-built_in">add</span>(n,u),<span class="hljs-built_in">add</span>(n,v);<br>&#125;<br><br>deep[n]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(n);<br><br>    <br>    <span class="hljs-comment">//注意此时叶子节点的编号为[1,n/2+1]，但是最后一个点不参与答案</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)&#123;<br><span class="hljs-type">int</span> zu=<span class="hljs-built_in">lca</span>(i,i+<span class="hljs-number">1</span>);<br>ans[i]=a[zu];<br>&#125;<br><br>    <span class="hljs-comment">//注意区间右端点</span><br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n/<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qq;i++)&#123;<br><span class="hljs-type">int</span> l,r;<br>cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <br>        <span class="hljs-comment">//注意区间右端点</span><br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n/<span class="hljs-number">2</span>,l,r<span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意区间右端点</p></blockquote><h1 id="2021ICPC上海站Life-is-a-Game"><a href="#2021ICPC上海站Life-is-a-Game" class="headerlink" title="2021ICPC上海站Life is a Game"></a><a href="https://ac.nowcoder.com/acm/problem/231127">2021ICPC上海站Life is a Game</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>​给我们一个无向有权图。<br>​点有点权，边有边权。。我们可以在图上来回走，走到一个点后会获得该点的价值，能够重复到达一个点但是不能重复获得该点的价值。但是，从一个点走到另一个点需要满足当前带有的价值要大于边权。<br>​若干次询问，每次询问给一个起点和一个价值，问最多可以获得多少价值。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>考虑到可以在一个连通块内随意走，而且走的边一定是这个连通块的“最小生成树边”，所以正好符合重构树</li><li>建立重构树之后，如果可以到达某个<code>非叶子</code>节点x，那么x的子树的<code>叶子节点的权值</code>都可以被收集到</li><li>考虑假设到达了某<code>非叶子</code>节点x，是否可以向上走，只需要此时的价值&gt;父亲节点的点权即可</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br>ll n,m,q;<br>ll a[N];<br><span class="hljs-comment">//kruskal</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> u,v;<br>ll w;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> A&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> w&lt;b.w;<br>&#125;<br>&#125;edge[N];<br>ll f[N];<br><span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-comment">//graph</span><br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>e[++idx]=b;<br>ne[idx]=h[a];<br>h[a]=idx;<br>&#125;<br><br><br><span class="hljs-comment">//lca</span><br>ll fa[N][<span class="hljs-number">21</span>],deep[N];<br>ll dd[N][<span class="hljs-number">21</span>];<span class="hljs-comment">//在i节点跳到i+2^j，至少还需要多少</span><br>ll sum[N];<span class="hljs-comment">//子树中所有叶子的权值和</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">if</span>(u&lt;=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<br>sum[u]=a[u];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-built_in">dfs1</span>(j);<br>sum[u]+=sum[j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<span class="hljs-comment">//son</span><br><br>dd[j][<span class="hljs-number">0</span>]=a[u]-sum[j];<br>deep[j]=deep[u]+<span class="hljs-number">1</span>;<br>fa[j][<span class="hljs-number">0</span>]=u;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;<br>ll anc=fa[j][k<span class="hljs-number">-1</span>];<br>fa[j][k]=fa[anc][k<span class="hljs-number">-1</span>];<br>dd[j][k]=<span class="hljs-built_in">max</span>(dd[j][k<span class="hljs-number">-1</span>],dd[anc][k<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-built_in">dfs2</span>(j);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i++)f[i]=i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v,w;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>edge[i]=&#123;u,v,w&#125;;<br>&#125;<br><span class="hljs-built_in">sort</span>(edge+<span class="hljs-number">1</span>,edge+m+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u=edge[i].u,v=edge[i].v;<br>ll w=edge[i].w;<br>u=<span class="hljs-built_in">find</span>(u),v=<span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">continue</span>;<br>a[++n]=w;<br>f[u]=f[v]=n;<br><span class="hljs-built_in">add</span>(n,u),<span class="hljs-built_in">add</span>(n,v);<br>&#125;<br><br><span class="hljs-built_in">dfs1</span>(n);<span class="hljs-comment">//cal sum</span><br><br>deep[n]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs2</span>(n);<span class="hljs-comment">//cal fa&amp;dd&amp;deep</span><br><br><span class="hljs-keyword">while</span>(q--)&#123;<br>ll x,k;<br>cin&gt;&gt;x&gt;&gt;k;<br><span class="hljs-comment">//pos:x,val:k</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> jmp=<span class="hljs-number">20</span>;jmp&gt;=<span class="hljs-number">0</span>;jmp--)&#123;<br>            <span class="hljs-keyword">if</span>(fa[x][jmp]==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//不可以跳出去</span><br><span class="hljs-keyword">if</span>(dd[x][jmp]&lt;=k)&#123;<br>x=fa[x][jmp];<br>&#125;<br>&#125;<br>        cout&lt;&lt;sum[x]+k&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：dd数组表示至少需要k才可以跳，那么如果最开始在x位置额外拥有k，无论跳到哪里，都额外拥有k，k不会变化</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>重构树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后缀dp</title>
    <link href="/2023/11/21/%E5%90%8E%E7%BC%80dp/"/>
    <url>/2023/11/21/%E5%90%8E%E7%BC%80dp/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍一种dp的设计状态（后缀）"><a href="#本文介绍一种dp的设计状态（后缀）" class="headerlink" title="本文介绍一种dp的设计状态（后缀）"></a>本文介绍一种dp的设计状态（后缀）</h1><h2 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h2><p>一个序列中 “<code>任意一段区间</code> “满足某个性质，这个时候应该想到 “ 后缀dp”</p><h1 id="Qu’est-ce-Que-C’est"><a href="#Qu’est-ce-Que-C’est" class="headerlink" title="Qu’est-ce Que C’est?"></a><a href="https://ac.nowcoder.com/acm/contest/57358/J">Qu’est-ce Que C’est?</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 n 的数列 ，要求每个数都在 [ − m , m ]  范围，且任意长度大于等于 2 的区间和都大于等于 0 ，问方案数。</p><p><code>1 ≤ n , m ≤ 5e3 </code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>后缀dp秒杀，设<code>dp[i][j]</code>表示第<code>i</code>个数字选完后，所有后缀中<code>最小值</code>是<code>j</code>的合法方案数目（<strong>j可以是负数</strong>）</li><li>如果以i为结尾时，所有后缀最小值满足&gt;&#x3D;0,那么<code>以i为结尾的方案</code>一定是合法方案</li><li>计算<code>dp[i][j]</code>的时候，利用的i-1层的信息，假设i-1层是正确的，那么第i层肯定是正确的，那么后面都正确。</li><li>遍历完所有的i，说明一个很重要的信息：以i为结尾的<strong>任意</strong>后缀都满足“<code>任意长度&gt;=2的区间满足sum&gt;=0</code>”,那么任意一段长度大于等于2的区间都满足！！</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><span class="hljs-type">const</span> ll mol=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P=<span class="hljs-number">5001</span>;<br>ll a[N],n,m;<br>ll dp[<span class="hljs-number">2</span>][N];<span class="hljs-comment">//表示前i个，最小后缀和为j的方案数目 </span><br>ll dpsum[<span class="hljs-number">2</span>][N];<span class="hljs-comment">//dp的前缀和数组 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>    <br>    <span class="hljs-comment">//初始化dp[1][j],注意偏移量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-m;j&lt;=m;j++)<br>dp[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j+P]=<span class="hljs-number">1</span>,dpsum[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j+P]=(dpsum[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>+P]+dp[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j+P])%mol;<br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-m;j&lt;=m;j++)&#123;<span class="hljs-comment">//枚举这一层的最小后缀</span><br><span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//dp[i&amp;1][j+P]=dp[i-1&amp;1][j-m+P]+...+dp[i-1&amp;1][j+m+P]; </span><br>                <br>                <span class="hljs-comment">//当前为j，上一层可以是[j-m,j+m],注意边界</span><br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=dpsum[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(m,j+m)+P]-dpsum[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j-m<span class="hljs-number">-1</span>+P];<br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=(dp[i&amp;<span class="hljs-number">1</span>][j+P]%mol+mol)%mol;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//dp[i&amp;1][j+P]=dp[i-1&amp;1][-j+P]+...+dp[i-1&amp;1][-j+m+P];</span><br>                <br>                <span class="hljs-comment">//当前为j，上一层可以是[-j,-j+m]，否则此时出现区间&lt;0的情况，注意边界</span><br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=dpsum[i<span class="hljs-number">-1</span>&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(-j+m,m)+P]-dpsum[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][-j<span class="hljs-number">-1</span>+P];<br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=(dp[i&amp;<span class="hljs-number">1</span>][j+P]%mol+mol)%mol;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//前缀和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-m;j&lt;=m;j++)&#123;<br>dpsum[i&amp;<span class="hljs-number">1</span>][j+P]=(dpsum[i&amp;<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>+P]+dp[i&amp;<span class="hljs-number">1</span>][j+P])%mol;<br>&#125;<br>&#125;<br>cout&lt;&lt;dpsum[n&amp;<span class="hljs-number">1</span>][m+P];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>当前层<code>j&gt;=0</code>，上一层可以是负数（这个时候本位置一定选正数，可以满足题意），但是<code>j&lt;0</code>时，上一层必须是正数，而且<code> k&gt;=-j</code>,否则，此时一定存在某个以i为结尾的后缀(len&gt;&#x3D;2)，使得这个后缀的sum&lt;0，不符合题意</li><li><strong>边界问题</strong>：为什么当前层为<code>j(j&gt;=0)</code>的时候,上一层<code>最大</code>从<code>k=m</code>转移<strong>而不是</strong><code>k=m+j</code>呢？<br> 因为以i结尾的任意一个后缀的最小值不可能超过m</li></ol><h1 id="P2592-ZJOI2008-生日聚会"><a href="#P2592-ZJOI2008-生日聚会" class="headerlink" title="P2592 [ZJOI2008] 生日聚会"></a><a href="https://www.luogu.com.cn/problem/P2592">P2592 [ZJOI2008] 生日聚会</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定n，m，k。<br>n，m表示有n个男孩和m个女孩，对于任意连续的一段，男孩与女孩的数目之差不超过k，求方案数。<br><code>n , m ≤ 150，k ≤ 20</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>设<code>dp[i][j][w][t]</code>表示选i个男孩，j个女孩，且<code>此时</code>任意后缀中男孩比女孩<code>最多</code>多w个，女孩比男孩<code>最多</code>多t个的方案数目</li><li>显然，增加一个男孩或者增加一个女孩，如果上一个状态合法，那此轮状态也一定合法。</li><li>具体转移见代码</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">152</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">22</span>;<br><span class="hljs-type">const</span> ll mol=<span class="hljs-number">12345678</span>;<br>ll dp[N][N][M][M];<br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;w++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;=k;t++)&#123;<br><span class="hljs-keyword">if</span>(dp[i][j][w][t])&#123;<br>ll tem=dp[i][j][w][t];<br>(dp[i+<span class="hljs-number">1</span>][j][w+<span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,t<span class="hljs-number">-1</span>)]+=tem)%=mol;<br>(dp[i][j+<span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,w<span class="hljs-number">-1</span>)][t+<span class="hljs-number">1</span>]+=tem)%=mol;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;w++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;=k;t++)&#123;<br>ans+=dp[n][m][w][t];<br>ans%=mol;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><blockquote><p><strong>是由当前层转移到下一层，并不是由前一层转移到当前层</strong>，原因如下：</p><p>1.若由前一层转移到当前层,那么其中肯定有这样的转移方程：<code>dp[i][j][w][t]+=dp[i-1][j][max(0,w-1)][t+1]</code>，这是错的，如何确定选（i-1，j)这个状态下，女生一定比男生多t+1个呢？？如果j为0呢？那是不是可以不需要多t+1个，多t个好像也可以，此时t为0。</p><p>2.理论上从前一层转移到当前层也是可以的，只不过需要特判？？这个作者没有严格证明，可以自己尝试</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面两个题，发现，任意一段需要满足某一性质，则需要后缀dp。</p><p>dp定义：在<code>某个状态</code>下，<code>任意后缀</code>的<code>最</code>大属性（或者最小属性）为k   的方案数</p><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><blockquote><p>一定是在某个状态下</p><p>任意后缀</p><p>最大（最小）属性为k</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++单例模式和CRTP</title>
    <link href="/2023/11/21/c++%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/21/c++%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍c-的单例模式以及注意事项"><a href="#本文介绍c-的单例模式以及注意事项" class="headerlink" title="本文介绍c++的单例模式以及注意事项"></a>本文介绍c++的单例模式以及注意事项</h1><h1 id="简单的单例模式"><a href="#简单的单例模式" class="headerlink" title="简单的单例模式"></a>简单的单例模式</h1><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><strong>私有化构造函数</strong>：确保不能从类外部直接构造对象。</li><li><strong>静态成员函数</strong>：提供一个全局访问点，用于获取这个唯一的实例。</li><li><strong>静态成员变量</strong>：存储类的唯一实例。</li><li><strong>删除复制构造函数和赋值操作符</strong>：防止复制和赋值实例。</li><li><strong>可选的私有析构函数</strong>：如果类管理资源，明确声明析构函数有助于资源的正确释放。</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> A* <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; name &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止外部删除单例对象</span><br>    ~<span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> A* m_instance;<br>    string name;<br><br>    <span class="hljs-comment">// 私有化构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;a&quot;</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 私有化拷贝和赋值</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;<br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp;)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员变量</span><br>A* A::m_instance=<span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A::<span class="hljs-built_in">instance</span>()-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模板单例"><a href="#模板单例" class="headerlink" title="模板单例"></a>模板单例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T* <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">//注意这句是protected</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <br>    <span class="hljs-comment">//注意参数</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">//注意返回值和参数</span><br>    Singleton&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-type">static</span> T* m_instance;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T* Singleton&lt;T&gt;::m_instance = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Singleton&lt;A&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">// 让Singleton类模板访问A的私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;A&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s instance method called.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他 A 类的成员函数和变量</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有化构造函数，确保外部不能直接创建A的实例</span><br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* a = A::<span class="hljs-built_in">instance</span>();<br>a-&gt;<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p><ul><li>构造函数必须是类名，不允许加模板</li><li>其他函数需要加模板</li><li>基类类型是Singleton&lt;T&gt;,子类类型是T   ！！！！！！！！！！！！！！</li></ul></blockquote><h1 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>CRTP的全称是<strong>C</strong>uriously <strong>R</strong>ecurring <strong>T</strong>emplate <strong>P</strong>attern，即奇异递归模板模式。</p><p><strong>特点：</strong></p><ol><li>基类是一个模板类</li><li>派生类继承该基类时，<strong>将派生类自身作为模板参数传递给基类</strong></li></ol><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类是模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(<span class="hljs-keyword">this</span>))<br>        &#123;<br>            t-&gt;<span class="hljs-built_in">op</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-comment">// 派生类Derived继承自Base，并以自身作为模板参数传递给基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::op()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>通过使用static_cast，将this指针转换为模板参数类型T的指针，然后调用类型T的方法,这种方法是安全的</p></blockquote><h2 id="CRTP的特点"><a href="#CRTP的特点" class="headerlink" title="CRTP的特点"></a>CRTP的特点</h2><ul><li><strong>优点</strong>：省去动态绑定、查询虚函数表带来的开销。通过CRTP，<code>基类</code>可以<code>获得</code>到<code>派生类</code>的类型，提供各种操作，比普通的继承更加灵活。但<code>CRTP</code>基类并不会单独使用，只是作为一个模板的功能。</li><li><strong>缺点</strong>：模板的通病，即影响代码的可读性。</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="1-静态分发（“静态多态”）"><a href="#1-静态分发（“静态多态”）" class="headerlink" title="1. 静态分发（“静态多态”）"></a>1. 静态分发（“静态多态”）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(<span class="hljs-keyword">this</span>))<br>        &#123;<br>            t-&gt;<span class="hljs-built_in">op</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">public</span> Base&lt;Derived1&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived1</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived1::op()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">public</span> Base&lt;Derived2&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived2</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived2::op()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-comment">// 辅助函数：完成静态分发</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DerivedClass&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helperFunc</span><span class="hljs-params">(Base&lt;DerivedClass&gt;&amp; d)</span><span class="hljs-comment">//注意参数d的类型</span></span><br><span class="hljs-function"></span>&#123;<br>    d.<span class="hljs-built_in">func</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Derived1 d1;<br>    Derived2 d2;<br>    <span class="hljs-built_in">helperFunc</span>(d1);<br>    <span class="hljs-built_in">helperFunc</span>(d2);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Base<Derived1>和Base<Derived2>不算同一个类型</p></blockquote><p><strong>注意：</strong></p><ul><li>模板类或模板函数在<code>调用</code>时才会实例化。因此当<code>Base&lt;Derived1&gt;::func()</code>被调用时，<code>Base&lt;Derived1&gt;</code>已经知道<code>Derived1::op()</code>的存在</li></ul><h3 id="2-计数器"><a href="#2-计数器" class="headerlink" title="2. 计数器"></a>2. 计数器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">Counter</span>()<br>    &#123;<br>        <span class="hljs-comment">//注意类型</span><br>        ++Counter&lt;T&gt;::count;<br>    &#125;<br>    ~<span class="hljs-built_in">Counter</span>() <br>    &#123;<br>        <span class="hljs-comment">//注意类型</span><br>        --Counter&lt;T&gt;::count;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> Counter&lt;T&gt;::count = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DogCounter</span> : <span class="hljs-keyword">public</span> Counter&lt;DogCounter&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;count;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatCounter</span> : <span class="hljs-keyword">public</span> Counter&lt;CatCounter&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;count;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    DogCounter d1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;DogCount : &quot;</span> &lt;&lt; d1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br>    &#123;<br>        DogCounter d2;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DogCount : &quot;</span> &lt;&lt; d1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//2</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;DogCount : &quot;</span> &lt;&lt; d1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br> <br>    CatCounter c1, c2, c3, c4, c5[<span class="hljs-number">3</span>];<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;CatCount : &quot;</span> &lt;&lt; c1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//7</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">DogCount : <span class="hljs-number">1</span><br>DogCount : <span class="hljs-number">2</span><br>DogCount : <span class="hljs-number">1</span><br>CatCount : <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p>见模板单例</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>单例模式下，<code>构造函数</code><strong>不</strong>允许加模板，<code>其他函数</code>需要<strong>加</strong>模板</li><li>单例模式下访问权限：子类需要基类的<code>友元</code>（用于基类访问子类构造函数），基类需要使用<code>protected</code>（用于子类访问基类的构造函数）</li><li>子类需要<code>私有化构造函数</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑层设计</title>
    <link href="/2023/11/20/%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/11/20/%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文概述基于<code>boost::asio</code>实现的服务器逻辑层结构，并且完善之前设计的消息结构。因为为了简化粘包处理，我们简化了发送数据的结构,这次我们给出完整的消息设计，以及服务器架构设计。</p><h1 id="服务层设计"><a href="#服务层设计" class="headerlink" title="服务层设计"></a>服务层设计</h1><p>之前我们设计了Session(会话层)，并且给大家讲述了Asio底层的通信过程，如下图</p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20231120183243232.png" alt="image-20231120183243232"></p><p>我们接下来要设计的服务器结构是这样的</p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20231120183405074.png" alt="image-20231120183405074"></p><h1 id="消息头完善"><a href="#消息头完善" class="headerlink" title="消息头完善"></a>消息头完善</h1><p>我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。</p><p>为了减少耦合和歧义，我们重新设计消息节点</p><ol><li><code>MsgNode</code>表示消息节点的基类，头部的消息用这个结构存储。</li><li><code>RecvNode</code>表示接收消息的节点。</li><li><code>SendNode</code>表示发送消息的节点。</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>_data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>~<span class="hljs-built_in">MsgNode</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">delete</span>[] _data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>&#123;<br>::std::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, _total_len);<br>&#125;<br><span class="hljs-type">short</span> _cur_len;<br><span class="hljs-type">short</span> _total_len;<br><span class="hljs-type">char</span>* _data;<br>&#125;;<br><br><span class="hljs-comment">//接受消息 id+内容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecvNode</span> :<span class="hljs-keyword">public</span> MsgNode &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">RecvNode</span>(<span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id);<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">short</span> _msg_id;<br>&#125;;<br><br><span class="hljs-comment">//发送消息，id+len+内容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendNode</span> :<span class="hljs-keyword">public</span> MsgNode &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SendNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id);<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">short</span> _msg_id;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RecvNode::<span class="hljs-built_in">RecvNode</span>(<span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id) :<span class="hljs-built_in">MsgNode</span>(max_len),<br>_msg_id(msg_id) &#123;<br>&#125;<br><br><span class="hljs-comment">//注意，头部有（id+data_len）两个字段</span><br>SendNode::<span class="hljs-built_in">SendNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id) :<span class="hljs-built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN)<br>, _msg_id(msg_id) &#123;<br>    <span class="hljs-comment">//先发送id, 转为网络字节序</span><br>    <span class="hljs-type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(msg_id);<br><br>    <span class="hljs-comment">//这里是HEAD_ID_LEN，不是HEAD_TOTAL_LEN</span><br>    <span class="hljs-built_in">memcpy</span>(_data, &amp;msg_id_host, HEAD_ID_LEN);<br>    <span class="hljs-comment">//转为网络字节序</span><br>    <span class="hljs-type">short</span> max_len_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(max_len);<br><br>    <span class="hljs-comment">//这里是HEAD_DATA_LEN，不是HEAD_TOTAL_LEN</span><br>    <span class="hljs-built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;max_len_host, HEAD_DATA_LEN);<br><br>    <span class="hljs-comment">//消息内容</span><br>    <span class="hljs-built_in">memcpy</span>(_data + HEAD_ID_LEN + HEAD_DATA_LEN, msg, max_len);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">SendNode`发送节点构造时，先将id转为网络字节序，然后写入`_data`数据域。<br>然后将要发送数据的长度转为大端字节序，写入`_data`数据域，注意要偏移`HEAD_ID_LEN`长度。<br>最后将要发送的数据`msg`写入`_data`数据域，注意要偏移`HEAD_ID_LEN`+`HEAD_DAT<span class="hljs-built_in">A_LEN</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="Session类改写"><a href="#Session类改写" class="headerlink" title="Session类改写"></a>Session类改写</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>~<span class="hljs-built_in">CSession</span>();<br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_length, <span class="hljs-type">short</span> msgid)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(std::string msg, <span class="hljs-type">short</span> msgid)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;CSession&gt; <span class="hljs-title">SharedSelf</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>tcp::socket _socket;<br>std::string _uuid;<br><span class="hljs-type">char</span> _data[MAX_LENGTH];<br>CServer* _server;<br><span class="hljs-type">bool</span> _b_close;<br>std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>std::mutex _send_lock;<br><br><br><span class="hljs-comment">//收到的消息结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br><span class="hljs-type">bool</span> _b_head_parse;<br><span class="hljs-comment">//收到的头部结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/json.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/value.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/reader.h&gt;</span></span><br><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server), _b_close(<span class="hljs-literal">false</span>), _b_head_parse(<span class="hljs-literal">false</span>) &#123;<br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br>_recv_head_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);<br>&#125;<br>CSession::~<span class="hljs-built_in">CSession</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(std::string msg, <span class="hljs-type">short</span> msgid)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;SendNode&gt;(msg.<span class="hljs-built_in">c_str</span>(), msg.<span class="hljs-built_in">length</span>(), msgid));<br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_length, <span class="hljs-type">short</span> msgid)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msgid));<br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Close</span><span class="hljs-params">()</span> </span>&#123;<br>_socket.<span class="hljs-built_in">close</span>();<br>_b_close = <span class="hljs-literal">true</span>;<br>&#125;<br><br>std::shared_ptr&lt;CSession&gt;CSession::<span class="hljs-built_in">SharedSelf</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-comment">//增加异常处理</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-comment">//cout &lt;&lt; &quot;send data &quot; &lt;&lt; _send_que.front()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span><br>_send_que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, shared_self));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception code : &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-comment">//已经移动的字符数</span><br><span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (bytes_transferred &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br><span class="hljs-comment">//收到的数据不足头部大小</span><br><span class="hljs-keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LEN) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_head_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空缓冲区</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//收到的数据比头部多</span><br><span class="hljs-comment">//头部剩余未复制的长度</span><br><span class="hljs-type">int</span> head_remain = HEAD_TOTAL_LEN - _recv_head_node-&gt;_cur_len;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);<br><span class="hljs-comment">//更新已处理的data长度和剩余未处理的长度</span><br>copy_len += head_remain;<br>bytes_transferred -= head_remain;<br><span class="hljs-comment">//获取头部MSGID数据</span><br><span class="hljs-type">short</span> msg_id = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>msg_id = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(msg_id);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;<br><span class="hljs-comment">//id非法</span><br><span class="hljs-keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">short</span> msg_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>msg_len = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(msg_len);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;msg_len is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;<br><br><span class="hljs-comment">//len非法</span><br><span class="hljs-keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid data length is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//构造接收节点</span><br>_recv_msg_node = <span class="hljs-built_in">make_shared</span>&lt;RecvNode&gt;(msg_len, msg_id);<br><br><span class="hljs-comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; msg_len) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-comment">//头部处理完成</span><br>_b_head_parse = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//处理这一轮的消息体</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len);<br>_recv_msg_node-&gt;_cur_len += msg_len;<br>copy_len += msg_len;<br>bytes_transferred -= msg_len;<br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><br><span class="hljs-comment">//构造数据和发送数据</span><br>Json::Reader reader;<br>Json::Value root;<br>reader.<span class="hljs-built_in">parse</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span><br>&lt;&lt; root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>() &lt;&lt; endl;<br>root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>();<br>std::string return_str = root.<span class="hljs-built_in">toStyledString</span>();<br><span class="hljs-built_in">Send</span>(return_str, root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>());<br><br><span class="hljs-comment">//处理下一轮的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">//已经处理完头部，处理上次未接受完的消息数据</span><br><span class="hljs-comment">//接收的数据仍不足剩余未处理的</span><br><span class="hljs-type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br><span class="hljs-keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);<br>_recv_msg_node-&gt;_cur_len += remain_msg;<br>bytes_transferred -= remain_msg;<br>copy_len += remain_msg;<br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br><span class="hljs-comment">//构造数据和发送数据</span><br>Json::Reader reader;<br>Json::Value root;<br>reader.<span class="hljs-built_in">parse</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span><br>&lt;&lt; root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>() &lt;&lt; endl;<br>root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>();<br>std::string return_str = root.<span class="hljs-built_in">toStyledString</span>();<br><span class="hljs-built_in">Send</span>(return_str, root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>());<br><br><br><span class="hljs-comment">//处理下一轮的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="单例模板类"><a href="#单例模板类" class="headerlink" title="单例模板类"></a>单例模板类</h1><p>因为服务器的逻辑处理需要单例模式，后期可能还会有一些模块的设计也需要单例模式，所以先实现一个单例模板类，然后其他想实现单例类只需要继承这个模板类即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; _instance;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//获取指针</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> std::once_flag s_flag;<br>        std::<span class="hljs-built_in">call_once</span>(s_flag, [&amp;]() &#123;<br>            _instance = <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T);<br>            &#125;);<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br><br>    <span class="hljs-comment">//输出地址</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; _instance.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//析构</span><br>    ~<span class="hljs-built_in">Singleton</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><h1 id="LogicNode类"><a href="#LogicNode类" class="headerlink" title="LogicNode类"></a>LogicNode类</h1><p><code>LogicNode</code>定义在CSession.h中</p><p>其包含算了会话类的智能指针，主要是为了实现伪闭包，防止session被释放。<br>其次包含了接收消息的节点类的智能指针。<br>实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//session和recvnode</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicNode</span> &#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicSystem</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">LogicNode</span>(shared_ptr&lt;CSession&gt;Sesson, shared_ptr&lt;RecvNode&gt;Recvnode) :_session(Sesson), _recvnode(Recvnode) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;CSession&gt; _session;<br>shared_ptr&lt;RecvNode&gt; _recvnode;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="LogicSystem单例类"><a href="#LogicSystem单例类" class="headerlink" title="LogicSystem单例类"></a>LogicSystem单例类</h1><p>我们实现逻辑系统的单例类，继承自<code>Singleton&lt;LogicSystem&gt;</code>，这样LogicSystem的构造函数和拷贝构造函数就都变为私有的了，因为基类的构造函数和拷贝构造函数都是私有的。另外<code>LogicSystem</code>也用了基类的成员<code>_instance</code>和<code>GetInstance</code>函数。从而达到单例效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这是回调函数的类型定义。它接受一个会话对象的智能指针、一个消息ID和消息内容作为参数。</span><br><span class="hljs-keyword">typedef</span>  function&lt;<span class="hljs-type">void</span>(shared_ptr&lt;CSession&gt;, <span class="hljs-type">short</span> msg_id, string msg_data)&gt; FunCallBack;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicSystem</span> :<span class="hljs-keyword">public</span> Singleton&lt;LogicSystem&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;LogicSystem&gt;;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">LogicSystem</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostMsgToQue</span><span class="hljs-params">(shared_ptr &lt; LogicNode&gt; msg)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">LogicSystem</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DealMsg</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterCallBacks</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloWordCallBack</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">short</span> msg_id, string msg_data)</span></span>;<br>    std::thread _worker_thread;<br>    std::queue&lt;shared_ptr&lt;LogicNode&gt;&gt; _msg_que;         <span class="hljs-comment">//消息队列</span><br>    std::mutex _mutex;<br>    std::condition_variable _consume;<br>    <span class="hljs-type">bool</span> _b_stop;<br>    std::map&lt;<span class="hljs-type">short</span>, FunCallBack&gt; _fun_callbacks;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>FunCallBack</code>为要注册的回调函数类型，其参数为绘画类智能指针，消息id，以及消息内容。</li><li><code>_msg_que</code>为逻辑队列</li><li><code>_mutex</code> 为保证逻辑队列安全的互斥量</li><li><code>_consume</code>表示消费者条件变量，用来控制当逻辑队列为空时<code>保证线程暂时挂起等待</code>，不要干扰其他线程。</li><li><code>_fun_callbacks</code>表示回调函数的map，根据id查找对应的逻辑处理函数。</li><li><code>_worker_thread</code>表示工作线程，用来从逻辑队列中取数据并执行回调函数。</li><li><code>_b_stop</code>表示收到外部的停止信号，逻辑类要中止工作线程并优雅退出。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中位数第k大二分法</title>
    <link href="/2023/11/19/%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AC%ACk%E5%A4%A7%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2023/11/19/%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AC%ACk%E5%A4%A7%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍利用二分法求中位数的一般思路"><a href="#本文介绍利用二分法求中位数的一般思路" class="headerlink" title="本文介绍利用二分法求中位数的一般思路"></a>本文介绍利用二分法求中位数的一般思路</h1><p>如果一个题目要求中位数，二分答案，判定是否符合条件即可</p><h1 id="D-Max-Median"><a href="#D-Max-Median" class="headerlink" title="D. Max Median"></a><a href="https://codeforces.com/contest/1486/problem/D">D. Max Median</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n和一个k，n表示有一个数组有n个元素，求所有“区间长度大于等于k”的区间中，中位数最大的多少</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>二分答案，检查是否存在一个大于等于k的区间满足即可，显然此时原数组元素<code>具体值</code>是多少已经不重要，重要的是元素的<code>相对大小</code>，设新数组b，若<code>a[i]&gt;=x</code>,则<code>b[i]=1</code>，否则<code>b[i]=0</code>，设s为b的前缀和。</p><p>然后考虑对于每一个<code>i</code>，是否存在<code>j (0&lt;=j&lt;=i-k)</code>,满足<code>s[i]-s[j]&gt;0</code>,这是一个很常见的处理方式（称之为划分集合法），具体见代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mol=<span class="hljs-number">12345678</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> b[N];<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//处理b数组</span><br><span class="hljs-keyword">if</span>(a[i]&gt;=x)&#123;<br>b[i]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> b[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//前缀和数组</span><br>s[i]=s[i<span class="hljs-number">-1</span>]+b[i];<br>&#125;<br><span class="hljs-comment">//s[i]-s[j]&gt;0即可，i-j&gt;=k </span><br><span class="hljs-type">int</span> minn=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;=n;i++)&#123;<br>minn=<span class="hljs-built_in">min</span>(minn,s[i-k]);<br>        <br>        <span class="hljs-comment">//注意是&gt;0，想想为什么</span><br><span class="hljs-keyword">if</span>(s[i]-minn&gt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125; <br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=n;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>ans=mid;<br>l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Chat-Program"><a href="#D-Chat-Program" class="headerlink" title="D. Chat Program"></a><a href="https://codeforces.com/gym/104128/problem/D">D. Chat Program</a></h1><blockquote><p>icpc银牌题</p></blockquote><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的数组，问最多给<code>一段</code>区间添加等差数列后,序列第 k 大最大是多少。</p><p>等差数列首项为c， 公差为d，长度为m。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题虽然不是中位数，其实也差不多。都是二分答案检查是否符合即可</p><ol><li>设二分答案x，若序列中某个数<code>a[i]&lt;x</code>，若使这个数<code>&gt;=x</code>，则必须选一个位置作为开头，加等差数列。</li><li>对于所有数操作完后，我们<code>只可以</code>选一个位置作为开头，那么要满足更多的<code>a[i]&gt;=x</code>。很容易想到，<strong>对于每一个小于x的位置，这个开头是一段区间</strong>，我们差分维护即可，这样对所有数字操作完后，对差分数组求前缀和</li><li>最后，选出一个满足尽可能多的<code>a[i]</code>的位置，如果此时可以满足的<code>a[i]&gt;=x</code>还是大于等于k个，那么符合要求，否则不符合要求</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br> <br>ll a[N];<br>ll n,m;<br>ll k,c,d;<span class="hljs-comment">//c+d[i]</span><br>ll cha[N];<span class="hljs-comment">//差分数组</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-comment">//第k大至少是x,大于等于x的数目需要大于等于k</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>; <span class="hljs-comment">//符合的数目</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">if</span>(a[i]&lt;x) &#123;<br><span class="hljs-comment">//c+ (i-pos)*d +a[i] &gt;= x//最右边的pos</span><br><span class="hljs-comment">//pos=(c+a[i]-x+i*d)/d</span><br> <br><span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span>(a[i]+c&gt;=x) &#123;<br>cha[<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,i-m+<span class="hljs-number">1</span>)]++;<br>cha[i+<span class="hljs-number">1</span>]--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ll ans=(c+a[i]-x+i*d)/d;<span class="hljs-comment">//寻找起始位置</span><br>ans=<span class="hljs-built_in">min</span>(ans,(ll)i);<br><span class="hljs-keyword">if</span>(ans&gt;=<span class="hljs-number">1</span>&amp;&amp;ans&gt;=i-m+<span class="hljs-number">1</span>) &#123;<br>cha[<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,i-m+<span class="hljs-number">1</span>)]++;<br>cha[ans+<span class="hljs-number">1</span>]--;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> num++;<br>&#125;<br>ll maxn=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cha[i]+=cha[i<span class="hljs-number">-1</span>];<br>maxn=<span class="hljs-built_in">max</span>(maxn,cha[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n+<span class="hljs-number">1</span>; i++)cha[i]=<span class="hljs-number">0</span>;<br>num+=maxn;<br><span class="hljs-keyword">return</span> num&gt;=k;<br> <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;c&gt;&gt;d;<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>&#125;<br> <br>ll ans=<span class="hljs-number">0</span>;<br>ll begin=<span class="hljs-number">1</span>,end=<span class="hljs-number">2e15</span>;<br><span class="hljs-keyword">while</span>(begin&lt;=end) &#123;<br>ll mid=begin+end&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) &#123;<br>ans=mid;<br>begin=mid+<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> end=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br> <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//关闭C++和C的输入输出流的同步，提高C++的输入输出效率</span><br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//解除cin和cout的绑定，让它们可以独立缓冲</span><br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//这一句可以不要，效果一样</span><br><span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//cin&gt;&gt;t;</span><br><span class="hljs-keyword">while</span>(t--) &#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>碰到这种题先考虑二分吧，中位数，第k大</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节序大小端问题</title>
    <link href="/2023/11/16/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/16/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="字节序的问题"><a href="#字节序的问题" class="headerlink" title="字节序的问题"></a>字节序的问题</h1><p>字节序问题，通常被称为大小端问题（Endianess），涉及到数据在计算机内存中的存储方式，尤其是多字节值（如整数、浮点数）的存储顺序。这个问题在不同架构的计算机系统中尤为重要，因为它会影响数据的解释和处理。主要有两种类型的字节序：</p><ol><li><strong>大端序（Big Endian）</strong>：在这种方式下，多字节值的最高有效字节（MSB）存储在最低的内存地址，随后是次高有效字节，以此类推。例如，数值 <code>0x12345678</code> 在内存中会被存储为 <code>12 34 56 78</code>（地址由低到高排列）。</li><li><strong>小端序（Little Endian）</strong>：与大端序相反，小端序将多字节值的最低有效字节（LSB）存储在最低的内存地址。同样的数值 <code>0x12345678</code> 在小端序系统中将被存储为 <code>78 56 34 12</code>。</li></ol><p>字节序问题在跨平台数据交换时尤为重要。如果两个交流数据的系统采用不同的字节序，没有适当的转换，数据可能会被错误地解释，导致问题。例如，在网络编程中，通常采用大端序（网络字节序），因此在数据发送和接收时，可能需要在小端序和大端序之间进行转换。</p><p><strong>产生问题的原因</strong>：</p><p>在网络通信中，如果数字（如整数或浮点数）的字节序没有从<code>发送方</code>的主机序转换为统一的网络字节序（大端序），那么<code>接收方</code>可能无法正确解释接收到的数据。这是因为<strong>不同的计算机架构可能采用不同的字节序</strong>，导致相同的数字在不同系统上的内存表示不同</p><h1 id="如何区分本机字节序"><a href="#如何区分本机字节序" class="headerlink" title="如何区分本机字节序"></a>如何区分本机字节序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 判断当前系统的字节序是大端序还是小端序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 当前系统为小端序</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 当前系统为大端序</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;num;<br>cout &lt;&lt; <span class="hljs-string">&quot;原始数据：&quot;</span> &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_big_endian</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统为大端序&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(num); i++) &#123;<br>cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统为小端序&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">sizeof</span>(num) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务器使用网络字节序"><a href="#服务器使用网络字节序" class="headerlink" title="服务器使用网络字节序"></a>服务器使用网络字节序</h1><p>为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。</p><p>可以使用<br><code> boost::asio::detail::socket_ops::host_to_network_long()</code> 和 <code>boost::asio::detail::socket_ops::host_to_network_short()</code> 函数</p><p><strong>将主机字节序转换为网络字节序</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> host_long_value = <span class="hljs-number">0x12345678</span>;<br>    <span class="hljs-type">uint16_t</span> host_short_value = <span class="hljs-number">0x5678</span>;<br>    <span class="hljs-type">uint32_t</span> network_long_value = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_long</span>(host_long_value);<br>    <span class="hljs-type">uint16_t</span> network_short_value = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(host_short_value);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Host long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_long_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Network long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_long_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Host short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_short_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Network short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_short_value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host long value: 0x12345678<br>Network long value: 0x78563412<br>Host short value: 0x5678<br>Network short value: 0x7856<br></code></pre></td></tr></table></figure><hr><blockquote><p>注意：在使用这些函数时，应该确保输入参数和返回结果都是无符号整数类型，否则可能会出现错误。</p></blockquote><p>服务器<code>发送数据</code>时，将数据长度转化为<code>网络字节序</code>，<br>在<code>接收数据</code>时，将长度转为<code>本机字节序</code>。</p><p><strong>将网络字节序转换为主机字节序</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len=boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br></code></pre></td></tr></table></figure><hr><h1 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h1><p>发送时我们会将发送的消息放入队列里以保证发送的时序性，每个session都有一个发送队列，因为有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>    <span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-comment">//如果大于&quot;队列size允许的容量&quot;,则不允许发送</span><br>    <span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br>    <span class="hljs-keyword">if</span> (send_que_size&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>    boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), <br>        std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字节序问题的解决需要程序员显示的调用函数，asio不会自动帮我们实现</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>处理网络粘包问题</title>
    <link href="/2023/11/15/%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/15/%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h1><p>原因：</p><p>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！</p><p>其他的原因:<br>1   客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！。<br>2   tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法。<br>3   再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连。</p><h1 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h1><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议：</p><p><code>消息id</code>+<code>消息长度</code>+<code>消息内容</code></p><h1 id="MsgNode类"><a href="#MsgNode类" class="headerlink" title="MsgNode类"></a>MsgNode类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br>    <span class="hljs-comment">//Csession可以访问私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span>;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//(发送msg)，数组长度为（max_len+头长度+1)，结尾&quot;\0&quot;,当前长度为0</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len) :_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>        <span class="hljs-built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);<br>        <span class="hljs-built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);<br>        _data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//(读取msg)，数组为（max_len+1），，结尾&quot;\0&quot;,当前长度为0</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>    &#125;<br><br>    ~<span class="hljs-built_in">MsgNode</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] _data;<br>    &#125;<br><br>    <span class="hljs-comment">//清空消息内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>&#123;<br>        ::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, _total_len);<br>        _cur_len = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">short</span> _cur_len;  <span class="hljs-comment">//当前消息长度</span><br>    <span class="hljs-type">short</span> _total_len;<span class="hljs-comment">//消息总长度</span><br>    <span class="hljs-type">char</span>* _data;     <span class="hljs-comment">//消息内容</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>_cur_len;  &#x2F;&#x2F;当前消息长度</li><li>_total_len;&#x2F;&#x2F;消息总长度</li><li>_data;     &#x2F;&#x2F;消息内容</li><li>MsgNode(short max_len)           接受消息（read)的话需要这个构造</li><li>MsgNode(char* msg, short max_len)  发送消息（wrire）的话需要找个构造</li></ul><h1 id="CSession"><a href="#CSession" class="headerlink" title="CSession"></a>CSession</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为能够对收到的数据切包处理，需要定义一个消息接收节点，一个bool类型的变量表示头部是否解析完成，以及将处理好的头部先缓存起来的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    ~<span class="hljs-built_in">CSession</span>();<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开始接收消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<span class="hljs-comment">//发送消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//关闭会话</span><br>    <span class="hljs-function">std::shared_ptr&lt;CSession&gt; <span class="hljs-title">SharedSelf</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取this指针</span><br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读回调</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>    <span class="hljs-comment">//写回调</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>    tcp::socket _socket;<br>    std::string _uuid;<br><br>    <span class="hljs-comment">//接收数据的缓冲区</span><br>    <span class="hljs-type">char</span> _data[MAX_LENGTH];<br><br>    <span class="hljs-comment">//对应的服务器</span><br>    CServer* _server;<br><br><br>    <span class="hljs-type">bool</span> _b_close;<span class="hljs-comment">//是否关闭</span><br><br>    <span class="hljs-comment">//发送队列</span><br>    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>    std::mutex _send_lock;<span class="hljs-comment">//发送锁，防止多线程同时发送</span><br><br><br>    <span class="hljs-comment">//收到的消息结构</span><br>    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br>    <span class="hljs-type">bool</span> _b_head_parse;<span class="hljs-comment">//是否解析到头部</span><br>    <span class="hljs-comment">//收到的头部结构</span><br>    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//构造会话，_socket，服务器指针，关闭标志位，头部解析标志位，接收头部节点</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server), _b_close(<span class="hljs-literal">false</span>), _b_head_parse(<span class="hljs-literal">false</span>) &#123;<br><br><span class="hljs-comment">//生成uuid</span><br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br><br><span class="hljs-comment">//初始化接收头部节点</span><br>_recv_head_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);<br>&#125;<br>CSession::~<span class="hljs-built_in">CSession</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Close</span><span class="hljs-params">()</span> </span>&#123;<br>_socket.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭socket</span><br>_b_close = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置关闭标志位</span><br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><span class="hljs-comment">//获取this指针</span><br>std::shared_ptr&lt;CSession&gt;CSession::<span class="hljs-built_in">SharedSelf</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//开始接收数据</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//异步读取数据</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-comment">//发送消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<span class="hljs-comment">//加锁</span><br><br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获取当前发送队列大小</span><br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//将消息放入发送队列</span><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><br><span class="hljs-comment">//如果当前发送队列不为空，则说明有消息正在发送，不需要再次发送</span><br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//发送消息</span><br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-comment">//写回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<span class="hljs-comment">//加锁</span><br>cout &lt;&lt; <span class="hljs-string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="hljs-built_in">front</span>()-&gt;_data + HEAD_LENGTH &lt;&lt; endl;<br><br>_send_que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//write成功，一定发送完一条数据，所以直接pop</span><br><br><span class="hljs-comment">//如果发送队列不为空，则继续发送</span><br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, shared_self));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<span class="hljs-comment">//关闭会话</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">//从服务器中移除</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//读回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-comment">//已经移动的字符数</span><br><span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//如果接受到了数据，则继续接收</span><br><span class="hljs-keyword">while</span> (bytes_transferred &gt; <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-comment">//如果未处理头部，则先处理头部</span><br><span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br><span class="hljs-comment">//情况1：收到的数据不足头部大小</span><br><span class="hljs-keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;<br><br><span class="hljs-comment">//将数据复制到头部节点</span><br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_head_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//情况2：收到的数据比头部多</span><br><br><span class="hljs-comment">//头部剩余未复制的长度</span><br><span class="hljs-type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);<br><br><span class="hljs-comment">//更新已处理的data长度和剩余未处理的长度</span><br>copy_len += head_remain;<br>bytes_transferred -= head_remain;<br><br><span class="hljs-comment">//获取头部数据（应该接受到的消息，而不是真正接受到的消息）</span><br><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br><br><span class="hljs-comment">//头部长度非法</span><br><span class="hljs-keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);    <span class="hljs-comment">//从服务器中移除</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//创建接收消息节点</span><br>_recv_msg_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br><br><span class="hljs-comment">//情况3：消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; data_len) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续接收</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><br><span class="hljs-comment">//头部处理完成,下一个回调处理头部。</span><br>_b_head_parse = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//情况4：接受的长度 &gt; 头部规定的长度，说明数据已经收全，则将消息放到接收节点里</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);<br>_recv_msg_node-&gt;_cur_len += data_len;<br>copy_len += data_len;<br>bytes_transferred -= data_len;<br><br><span class="hljs-comment">//将最后一个位置置为&#x27;\0&#x27;，表示一个消息的结束(其实也不需要)</span><br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><span class="hljs-comment">//情况5:继续轮询剩余未处理数据(下一个头部）</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<span class="hljs-comment">//清空头部节点</span><br><br><span class="hljs-comment">//如果剩余数据没有了，则继续接收</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续接收</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//否则处理头部</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">//已经处理完头部，处理上次未接受完的消息数据</span><br><br><br><span class="hljs-comment">//获取应该处理的长度</span><br><span class="hljs-type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br><br><span class="hljs-comment">//情况1：接受的数据&lt;应该接受的数据</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//情况2：接受的数据&gt;应该接受的数据</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);<br>_recv_msg_node-&gt;_cur_len += remain_msg;<br>bytes_transferred -= remain_msg;<br>copy_len += remain_msg;<br><br><span class="hljs-comment">//将最后一个位置置为&#x27;\0&#x27;，表示一个消息的结束(其实也不需要)</span><br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><br><span class="hljs-comment">//处理下一个消息的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//清空头部节点</span><br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><br><span class="hljs-comment">//如果剩余数据没有了，则继续接收</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//否则处理头部</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<span class="hljs-comment">//关闭会话</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">//从服务器中移除</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>处理粘包具体步骤：</strong></p><ol><li>判断是否在读头部，分为两种情况</li><li>读头部：<ul><li>收到的数据还不够2字节，那么头部构造不出来，继续异步接受，return</li><li>收到的数据够头部，解析出头部，然后将剩余的数据与解析出的数据对比</li><li>如果剩余的数据<code>少于</code>解析出的头部，那么接着读，并且下一次读到（内容区）</li><li>如果剩余的数据<code>大于</code>解析出的头部，构造完整消息，如果还有数据，continue，否则接着监听</li></ul></li><li>读内容：<ul><li>收到的数据不够装满内容区，则接着监听，return</li><li>收到的数据<code>大于</code>内容区域,内容数据构造完后，下一次需要读，如果剩余数据为0，则接着监听，如果还有数据，则continue</li></ul></li></ol><h1 id="Cserver类"><a href="#Cserver类" class="headerlink" title="Cserver类"></a>Cserver类</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//端口号</span><br><span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//接受回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br><span class="hljs-comment">//开始接受</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>;<br><br><br>boost::asio::io_context&amp; _io_context;<br><span class="hljs-type">short</span> _port;<br>tcp::acceptor _acceptor;<span class="hljs-comment">//接收器（需要端点）</span><br><br><span class="hljs-comment">//会话列表</span><br>std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port) :_io_context(io_context), _port(port),<br>_acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br>shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio健壮的异步服务器</title>
    <link href="/2023/11/13/asio%E5%BB%B6%E9%95%BFsession%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/11/13/asio%E5%BB%B6%E9%95%BFsession%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>asio异步应答服务器存在隐患，就是因为使用了delete删除session对象，而本章使用智能指针防止重复delete对象session，使用智能指针构造成一个伪闭包的状态延长session的生命周期。</p><h1 id="智能指针管理Session"><a href="#智能指针管理Session" class="headerlink" title="智能指针管理Session"></a>智能指针管理Session</h1><p>我们可以通过智能指针的方式管理Session类，将<code>acceptor</code>接收的链接保存在<code>Session类型</code>的<code>智能指针</code>里。由于智能指针会在引用计数为0时自动析构，所以为了防止其被自动回收，也方便Server管理Session。因为我们后期会做一些重连踢人等业务逻辑，我们在Server类中添加成员变量，该变量为一个map类型，<code>key为Session的uid</code>，<code>value为该Session的智能指针</code>,此时也会增加引用计数</p><h1 id="session类"><a href="#session类" class="headerlink" title="session类"></a>session类</h1><h2 id="session类定义"><a href="#session类定义" class="headerlink" title="session类定义"></a>session类定义</h2><ul><li>首先定义一个消息节点，表示接受或者发送的消息</li><li>定义session类，继承std::enable_shared_from_this&lt;CSession&gt;</li><li>session存储socket，server，消息队列，uuid</li><li>回调函数中多一个参数，shared_ptr&lt;CSession&gt; _self_shared，传入_self_shared保证引用计数+1，从而防止隐患</li></ul><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENGTH  1024</span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span>;<br><br><br><span class="hljs-comment">//定义消息节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_len) &#123;<br>_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[max_len];<br><span class="hljs-built_in">memcpy</span>(_data, msg, max_len);<br>&#125;<br><br>~<span class="hljs-built_in">MsgNode</span>() &#123;<br><span class="hljs-keyword">delete</span>[] _data;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _cur_len;<span class="hljs-comment">//当前发送（接受）消息长度</span><br><span class="hljs-type">int</span> _max_len;<span class="hljs-comment">//最大消息长度</span><br><span class="hljs-type">char</span>* _data;<span class="hljs-comment">//消息内容</span><br>&#125;;<br><br><span class="hljs-comment">//定义会话类，继承自enable_shared_from_this，用于在异步操作中获取this指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> :<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数只需要io_context，不需要ip、端口，因为是服务器方，accecptor才会有ip和端口</span><br><span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    <br>~<span class="hljs-built_in">CSession</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Ssession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br>    <br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开启监听状态</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<span class="hljs-comment">//开启写状态</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读回调，注意最后一个参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br>    <br>    <span class="hljs-comment">//写回调，不需要指定bytes_transferred，注意最后一个参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br><br><br><span class="hljs-comment">//会话的socket</span><br>tcp::socket _socket;<br><span class="hljs-comment">//每个会话都有一个唯一的uuid</span><br>std::string _uuid;<br><br><span class="hljs-comment">//接收数据的缓冲区</span><br><span class="hljs-type">char</span> _data[MAX_LENGTH];<br><br><span class="hljs-comment">//对应的服务器</span><br>CServer* _server;<br><br><span class="hljs-comment">//发送队列</span><br>std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br><br><span class="hljs-comment">//发送锁，防止多线程同时发送</span><br>std::mutex _send_lock;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="session实现"><a href="#session实现" class="headerlink" title="session实现"></a>session实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//构造函数，初始化socket对象，初始化server，同时初始化随机数uuid，用于标识每个连接</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server) &#123;<br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><br><br><span class="hljs-comment">//开始监听读取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意绑定的是shared_from_this()！！</span><br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><span class="hljs-comment">//读回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;read data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><br><span class="hljs-comment">//将读取到的数据发送给客户端</span><br><span class="hljs-built_in">Send</span>(_data, bytes_transferred);<br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续监听读取</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, _self_shared));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//如果读取失败，清除session</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//填入消息队列发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否有待发送的数据</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果有待发送的数据，将数据放入队列，等待发送</span><br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><span class="hljs-keyword">if</span> (pending) &#123;<span class="hljs-comment">//如果有待发送的数据，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果没有待发送的数据，直接发送</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><span class="hljs-comment">//写回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-comment">//由于async_write一次发送数据完整，所以可以直接pop</span><br>_send_que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//如果还有待发送的数据，继续发送</span><br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_max_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, _self_shared));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-comment">//如果写入失败，清除session</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>start中开始异步读，读回调有send函数（异步写），然后接着开始异步读，继续监听</li><li>send函数开始异步写（如果此时没有在发送消息），写回调中开始异步写，直到全部写完</li></ul><blockquote><p>注意，此方式中:</p><p>异步读-&gt;读回调（这个里面调用send，开启异步写）-&gt;异步读</p><p>异步写-&gt;写回调-&gt;异步写</p></blockquote><p>如果回调函数中不增加引用计数，就会存在风险，假设异步读<strong>之后</strong>，客户端关闭连接，此时读回调<code>调用</code>send开启异步写，然后读回调<code>开启</code>异步读，会Clearsesson（uuid）两次，这样可能会导致：shared_ptr引用计数变为0，最后一次调用的时候，访问不存在的内存</p><h1 id="Cserver类"><a href="#Cserver类" class="headerlink" title="Cserver类"></a>Cserver类</h1><h2 id="Cserver类定义"><a href="#Cserver类定义" class="headerlink" title="Cserver类定义"></a>Cserver类定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//accecptor需要端口</span><br><span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br>    <br>    <span class="hljs-comment">//删除map中的session</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <br>    <span class="hljs-comment">//接受回调，第一个参数是智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code &amp; error)</span></span>;<br>   <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//开启接受服务器（接受状态）</span><br>    <br>boost::asio::io_context &amp;_io_context;<br><span class="hljs-type">short</span> _port;<br>tcp::acceptor _acceptor;<br>std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Cserver实现"><a href="#Cserver实现" class="headerlink" title="Cserver实现"></a>Cserver实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port):_io_context(io_context), _port(port),<br>_acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(),port))<br>&#123;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-comment">//接受回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<span class="hljs-comment">//开启监听</span><br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<span class="hljs-comment">//插入map中</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br>    <span class="hljs-comment">//继续开启服务器</span><br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><br><span class="hljs-comment">//开启接受状态，注意，session必须是智能指针！！</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br>shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br>    <br>    <span class="hljs-comment">//接受到新的连接，此时new_session-&gt;GetSocket()是被绑定到一个会话了，然后回调，注意传参是shared_ptr</span><br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>    <br>    <span class="hljs-comment">//此函数结束后，new_session销毁，引用计数-1，但是回调函数中还在使用，所以没释放内存</span><br>&#125;<br><br><span class="hljs-comment">//map中删除这个session，引用计数-1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><h2 id="shared-ptr的初始化问题"><a href="#shared-ptr的初始化问题" class="headerlink" title="shared_ptr的初始化问题"></a>shared_ptr的初始化问题</h2><p>不能用两个智能指针管理同一块内存，如下用法是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_ptr</span>&lt;CSession&gt;(<span class="hljs-keyword">this</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>shared_ptr&lt;CSession&gt;(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数，所以要通过shared_from_this()函数返回智能指针，该智能指针和其他管理这块内存的智能指针共享引用计数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，send函数中第一次发送也要绑定shared_from_this()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//填入消息队列发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否有待发送的数据</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果有待发送的数据，将数据放入队列，等待发送</span><br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><span class="hljs-keyword">if</span> (pending) &#123;<span class="hljs-comment">//如果有待发送的数据，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果没有待发送的数据，直接发送</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this()"></a>shared_from_this()</h2><p><code>shared_from_this()</code> 方法来获取当前对象的 <code>shared_ptr</code> 实例。这样可以确保你得到的 <code>shared_ptr</code> 与最初用于创建当前对象的 <code>shared_ptr</code> 共享相同的控制块。</p><blockquote><p>注意，使用shared_from_this(),必须保证这个类对象是用make_shared方式创建的！！！</p></blockquote><h1 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h1><ul><li>服务器 (<code>Server</code>) 初始化一个新的会话 (<code>Session</code>)，并为该会话分配一个网络套接字 (<code>Socket</code>)。</li><li>接受<code>session</code>后，回调函数中开启监听(<code>async_read_some</code>),然后回调函数中继续开启接受状态（<code>StartAccept()</code>)</li><li>监听到消息，<code>读</code>回调中调用<code>send</code>（开启写），然后<code>读</code>回调中继续开启监听（<code>async_read_some</code>）</li><li>send开启写(<code>async_write</code>),<code>写</code>回调中继续<code>写</code>，直到写完</li><li>sesson有问题，直接删除即可，整个异步过程的所有函数都有此对象的引用，直到所有函数执行完毕，引用计数才会清0</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio普通的异步服务器</title>
    <link href="/2023/11/13/asio%E6%99%AE%E9%80%9A%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/13/asio%E6%99%AE%E9%80%9A%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要实现一个异步应答服务器</p></blockquote><blockquote><p>分文两个类</p><p>session：session类主要是处理客户端消息收发的会话类，属于服务端</p><p>server：server类为服务器接收连接的管理类，用于管理多个session，属于服务端</p></blockquote><h1 id="session类"><a href="#session类" class="headerlink" title="session类"></a>session类</h1><p><strong>成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc):_socket(ioc)&#123;<br>    &#125;<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">Socket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _socket;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读操作回调函数需要2个参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span></span>;<br>    <span class="hljs-comment">//写操作只需要1个参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    tcp::socket _socket;<br>    <span class="hljs-keyword">enum</span> &#123;max_length = <span class="hljs-number">1024</span>&#125;;<br>    <span class="hljs-type">char</span> _data[max_length];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>_data用来接收客户端传递的数据</li><li>_socket为单独处理客户端读写的socket。</li><li>handle_read和handle_write分别为读回调函数和写回调函数。</li></ul><blockquote><p>注意，读写回调函数的参数数量不同</p></blockquote><p><strong>具体实现</strong></p><h2 id="1-start函数"><a href="#1-start函数" class="headerlink" title="(1)start函数"></a>(1)<code>start函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    <span class="hljs-comment">//读操作，读完调用handle_read</span><br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在Start方法中我们调用异步读操作，监听对端发送的消息。当对端发送数据后，触发handle_read函数</p><h2 id="2-handle-read函数"><a href="#2-handle-read函数" class="headerlink" title="(2)handle_read函数"></a>(2)<code>handle_read函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><br>        <span class="hljs-comment">//读完后，异步调用写操作，返回消息给发送者，返回后，调用handle_write函数</span><br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transfered),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handle_read函数内将收到的数据发送给对端，当发送完成后触发handle_write回调函数。</p><h2 id="3-handle-write函数"><a href="#3-handle-write函数" class="headerlink" title="(3)handle_write函数"></a>(3)<code>handle_write函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br><br>        <span class="hljs-comment">//发送完后，调用异步读操作，读取发送者发送的消息，读取完后，再次调用handle_read函数，形成循环</span><br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length), std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read,<br>            <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handle_write函数内又一次监听了读事件，如果对端有数据发送过来则触发handle_read，我们再将收到的数据发回去。从而达到应答式服务的效果。</p><h1 id="server类"><a href="#server类" class="headerlink" title="server类"></a>server类</h1><p>server类是服务器接收连接的管理类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数，初始化acceptor对象</span><br>    <span class="hljs-built_in">server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port);<br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//服务器开始接受连接</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_accept</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//新连接触发后的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_accept</span><span class="hljs-params">(session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br>    boost::asio::io_context&amp; _ioc;<br>    tcp::acceptor _acceptor;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>start_accept将要接收连接的acceptor绑定到服务上，其内部就是将accpeptor对应的socket描述符绑定到epoll或iocp模型上，实现事件驱动。</li><li>handle_accept为新连接到来后触发的回调函数。</li></ul><h2 id="（a-构造函数"><a href="#（a-构造函数" class="headerlink" title="（a) 构造函数"></a>（a) <code>构造函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">server::<span class="hljs-built_in">server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port) :_ioc(ioc),<br><span class="hljs-comment">//初始化acceptor对象（协议+监听端口，表示监听主机上的所有 IPv4 地址上的指定端口）</span><br>_acceptor(ioc, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)) &#123;<br>    <span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//启动接受连接</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始化ioc和accecptor</li><li>启动接受连接</li></ul><h2 id="b-start-accept函数"><a href="#b-start-accept函数" class="headerlink" title="(b)start_accept函数"></a>(b)<code>start_accept函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//保存新连接的socket对象</span><br>    session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">session</span>(_ioc);<br><br>    <span class="hljs-comment">//异步接受连接，调用handle_accept函数</span><br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保存socket对象</li><li>异步接受连接，然后调用<code>handle_accecpt函数</code></li><li>使用异步接受连接，因为防止阻塞</li></ul><blockquote><p>注意：开启异步接受连接，不代表立马会有客户端连接过来，而是等客户端连接过来才触发async_accept函数，连接完后调用handle_accept函数！！！！</p></blockquote><h2 id="c-handle-accept函数"><a href="#c-handle-accept函数" class="headerlink" title="(c)handle_accept函数"></a>(c)<code>handle_accept函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">//开启异步监听客户端的消息，这一步不会阻塞</span><br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br>    <span class="hljs-comment">//继续接受新连接</span><br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意，start是异步读操作，不会阻塞</p></blockquote><h1 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h1><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/array.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;server.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;session.h&quot;</span></span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>asio::io_context io_context;<br><span class="hljs-function">server <span class="hljs-title">s</span><span class="hljs-params">(io_context, <span class="hljs-number">8080</span>)</span></span>;<br>io_context.<span class="hljs-built_in">run</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>io_context.run()的作用</strong></p><ol><li><strong>启动事件循环</strong>：<ul><li><code>io_context.run()</code> 调用开始一个事件处理循环，负责执行所有排队的异步操作的处理程序。</li></ul></li><li><strong>执行异步操作处理程序</strong>：<ul><li>这个循环处理由异步操作（如异步读取、写入、连接接受）触发的处理程序（handlers）。</li></ul></li><li><strong>阻塞行为</strong>：<ul><li>函数执行时是阻塞的，意味着它会持续运行，直到所有异步操作完成或 <code>io_context</code> 被停止。</li></ul></li><li><strong>确保线程安全</strong>：<ul><li>所有异步操作的处理程序都在 <code>io_context.run()</code> 提供的上下文中安全地执行，这有助于维护线程安全。</li></ul></li><li><strong>驱动程序的核心</strong>：<ul><li><code>io_context.run()</code> 是 Boost.Asio 应用程序的驱动力，没有它，异步操作不会执行。</li></ul></li><li><strong>处理所有异步事件</strong>：<ul><li>包括网络 I&#x2F;O 操作、定时器事件等，都是在 <code>io_context.run()</code> 的循环中被处理。</li></ul></li><li><strong>应用程序的持续运行</strong>：<ul><li>主线程在调用 <code>run</code> 后会在事件循环中阻塞，这保证了应用程序可以持续处理异步事件，直到不再需要处理或被显式停止。</li></ul></li></ol><h1 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h1><p>该demo示例为仿照asio官网编写的，其中存在隐患，就是当服务器即将发送数据前(调用async_write前)，此刻客户端中断，服务器此时调用async_write会触发发送回调函数，判断ec为非0进而执行delete this逻辑回收session。但要注意的是客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。在读事件回调函数中判断错误码ec为非0，进而再次执行delete操作，从而造成二次析构，这是极度危险的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个demo介绍了异步读写的相关操作，下面是对于常用函数的总结，以及对异步的理解</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="（a-开启异步读"><a href="#（a-开启异步读" class="headerlink" title="（a)开启异步读"></a><strong>（a)开启异步读</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启异步读就好，然后结束start</li></ul><h3 id="b-异步读async-read-some"><a href="#b-异步读async-read-some" class="headerlink" title="(b)异步读async_read_some"></a><strong>(b)异步读</strong>async_read_some</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    <span class="hljs-comment">//指定读到哪，读多少</span><br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>                            <span class="hljs-comment">//读完后回调，去写</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//回调函数处理异步写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transferred),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启异步读</li><li>参数（buffer，回调函数）</li><li>buffer需要数组首地址，以及读取的<strong>最大长度</strong>(并不是读完max_lengtg才会回调！！)</li><li>回调函数需要两个参数error和bytes_transferred，因为不能保证数据一次性发完</li></ul><h3 id="c-异步写async-write"><a href="#c-异步写async-write" class="headerlink" title="(c)异步写async_write"></a><strong>(c)异步写async_write</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        <span class="hljs-comment">//异步发送数据给客户端，发送完回调</span><br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transferred),<br>                                 <span class="hljs-comment">//回调，开启异步读</span><br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        <span class="hljs-comment">//异步读</span><br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>异步写函数在异步读的回调函数中</li><li>异步写发送数据给客户端，然后回调函数中调用异步读</li><li>参数（buffer，回调函数）</li><li>buffer需要首地址，以及要发送的长度</li><li>回调函数只需要一个参数，那就是error，因为write一定会发送完的</li></ul><h3 id="d-异步接受连接async-accept"><a href="#d-异步接受连接async-accept" class="headerlink" title="(d)异步接受连接async_accept"></a><strong>(d)异步接受连接async_accept</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">session</span>(_ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>                           <span class="hljs-comment">//创建新连接后，回调</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::handle_accept</span><span class="hljs-params">(session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br>    <span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//接着等待接受新连接</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个新的 <code>session</code> 对象，准备处理新连接。</li><li>使用 <code>_acceptor.async_accept</code> 异步等待新的连接请求。</li><li>当有新的连接时，<code>handle_accept</code> 会被调用。</li></ul><h2 id="e-bind绑定回调函数的参数问题"><a href="#e-bind绑定回调函数的参数问题" class="headerlink" title="(e)bind绑定回调函数的参数问题"></a>(e)bind绑定回调函数的参数问题</h2><blockquote><h3 id="Boost-Asio-异步操作的回调函数"><a href="#Boost-Asio-异步操作的回调函数" class="headerlink" title="Boost Asio 异步操作的回调函数"></a>Boost Asio 异步操作的回调函数</h3><p>Boost Asio 的异步操作，如 <code>async_read</code>、<code>async_write</code> 等，通常要求你提供一个回调函数。这个回调函数通常接受两个参数：</p><p><strong>Error Code</strong> (<code>boost::system::error_code</code>)：表明异步操作成功或失败的错误码。</p><p><strong>Bytes Transferred</strong> (<code>size_t</code>)：传输的字节数。</p></blockquote><ol><li><p><strong>绑定所有参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2)<br></code></pre></td></tr></table></figure></li><li><p><strong>绑定部分参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>, placeholders::_1)<br><span class="hljs-comment">//只有错误码会被传递给回调函数。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不绑定任何参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure><hr></li></ol><h2 id="对异步的理解"><a href="#对异步的理解" class="headerlink" title="对异步的理解"></a>对异步的理解</h2><ul><li><h3 id="异步操作的特点"><a href="#异步操作的特点" class="headerlink" title="异步操作的特点"></a>异步操作的特点</h3><ol><li><strong>事件驱动</strong>：<ul><li>异步操作是基于事件的。这意味着操作（如读取、写入、接受连接等）等待特定的网络事件发生，如数据到达或连接建立。</li></ul></li><li><strong>非阻塞行为</strong>：<ul><li>异步操作不会阻塞程序的其余部分。它们在后台“监听”或等待事件发生，而程序可以继续执行其他任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>当相应的事件发生（例如，数据到达用于读取的套接字），异步操作完成，并触发定义好的回调函数。</li><li>回调函数通常用于处理事件结果，如读取数据或发送响应。</li></ul></li></ol><h3 id="异步读取和写入的循环"><a href="#异步读取和写入的循环" class="headerlink" title="异步读取和写入的循环"></a>异步读取和写入的循环</h3><ul><li>当 <code>async_read_some</code> 或类似函数被调用时，它开始监听数据到达事件。如果没有数据到达，这个函数不会执行其回调。</li><li>在异步读取的回调函数中启动异步写入是一种常见的模式。这确保了服务器在处理完一个请求后立即准备发送响应。</li><li>完成异步写入后，通常会再次启动异步读取操作，维持与客户端的持续通信。</li></ul><h3 id="异步接受连接"><a href="#异步接受连接" class="headerlink" title="异步接受连接"></a>异步接受连接</h3><ul><li><code>async_accept</code> 类似地监听新的连接请求。如果没有新的连接尝试，它会保持在监听状态，直到有新的连接请求到达。</li><li>一旦接受到新的连接，将调用 <code>async_accept</code> 指定的回调函数来处理这个新连接。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio异步读写操作及注意事项</title>
    <link href="/2023/11/12/asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/11/12/asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍异步读写操作。</p><p>定义个session类，这个session类表示服务器处理客户端连接的管理类</p><p>其中有socket对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(std::shared_ptr&lt;asio::ip::tcp::socket&gt; socket);<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::ip::tcp::endpoint&amp; ep)</span></span>;<span class="hljs-comment">//连接端点</span><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<span class="hljs-comment">//智能指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>session类定义了一个socket成员变量，负责处理对端的连接读写，封装了Connect函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::ip::tcp::endpoint &amp;ep)</span> </span>&#123;<br>    _socket-&gt;<span class="hljs-built_in">connect</span>(ep);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步写操作"><a href="#异步写操作" class="headerlink" title="异步写操作"></a>异步写操作</h1><p>在写操作前，我们先封装一个MsgNode结构，用来管理要<code>发送和接收</code>的数据，该结构包含<code>数据域首地址</code>，<code>数据的总长度</code>，以及<code>已经处理的长度</code>(已读的长度或者已写的长度)</p><h2 id="async-write-some方式"><a href="#async-write-some方式" class="headerlink" title="async_write_some方式"></a>async_write_some方式</h2><blockquote><p>一次性不一定发送完数据</p></blockquote><h3 id="定义MsgNode类用于封装数据"><a href="#定义MsgNode类用于封装数据" class="headerlink" title="定义MsgNode类用于封装数据"></a>定义MsgNode类用于封装数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最大报文接收大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RECVSIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MsgNode</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-comment">//发送数据的构造函数</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> total_len): _total_len(total_len), _cur_len(<span class="hljs-number">0</span>)&#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>        <span class="hljs-built_in">memcpy</span>(_msg, msg, total_len);<br>    &#125;<br>    <span class="hljs-comment">//接受数据的构造函数</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>    &#125;<br>    ~<span class="hljs-built_in">MsgNode</span>()&#123;<br>        <span class="hljs-keyword">delete</span>[]_msg;<br>    &#125;<br>    <span class="hljs-comment">//消息首地址</span><br>    <span class="hljs-type">char</span>* _msg;<br>    <span class="hljs-comment">//总长度</span><br>    <span class="hljs-type">int</span> _total_len;<br>    <span class="hljs-comment">//当前长度</span><br>    <span class="hljs-type">int</span> _cur_len;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="为Session添加异步写操作"><a href="#为Session添加异步写操作" class="headerlink" title="为Session添加异步写操作"></a>为Session添加异步写操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">    std::shared_ptr&lt;MsgNode&gt;)</span></span>;<br>    <span class="hljs-comment">//写函数（传入需要写的数据）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;MsgNode&gt; _send_node;<span class="hljs-comment">//定义需要发送的数据</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现void-WriteToSocketErr函数"><a href="#实现void-WriteToSocketErr函数" class="headerlink" title="实现void WriteToSocketErr函数"></a>实现<code>void WriteToSocketErr函数</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//构造发送数据</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>async_wirte_some函数第一个参数是buffer，第二个参数是回调函数）</p></blockquote><h3 id="实现WriteCallBackErr函数"><a href="#实现WriteCallBackErr函数" class="headerlink" title="实现WriteCallBackErr函数"></a>实现<code>WriteCallBackErr</code>函数</h3><p>因为WriteCallBackErr函数为三个参数且为成员函数，而<strong>async_write_some需要的回调函数为两个参数</strong>，所以我们通过bind将三个参数转换为两个参数的普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, </span></span><br><span class="hljs-params"><span class="hljs-function">    std::<span class="hljs-type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len <br>        &lt; msg_node-&gt;_total_len) &#123;<br>        _send_node-&gt;_cur_len += bytes_transferred;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,<br>            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单凭这两个不可以投入使用，具体原因是</p></blockquote><p>我们可以通过队列保证应用层的发送顺序。我们在Session中定义一个发送队列，然后重新定义正确的异步发送函数和回调处理</p><h3 id="定义queue写入消息（重点）"><a href="#定义queue写入消息（重点）" class="headerlink" title="定义queue写入消息（重点）"></a>定义queue写入消息（重点）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;<span class="hljs-comment">//用来缓存要发送的消息节点</span><br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    <span class="hljs-type">bool</span> _send_pending;<span class="hljs-comment">//该变量为true表示一个节点还未发送完。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现queue异步写入功能"><a href="#实现queue异步写入功能" class="headerlink" title="实现queue异步写入功能"></a><strong>实现queue异步写入功能</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf), std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标志正在发送消息...</span><br>&#125;<br><br><span class="hljs-comment">//回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec,  std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//取出队首元素即当前未发送完数据</span><br>    <span class="hljs-keyword">auto</span> &amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>    send_data-&gt;_cur_len += bytes_transferred;<br>    <br>    <span class="hljs-comment">//数据未发送完， 则继续发送（相当于递归）</span><br>    <span class="hljs-keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len-send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>    _send_pending=<span class="hljs-literal">false</span>;<span class="hljs-comment">//消息发送完毕</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="async-send方式"><a href="#async-send方式" class="headerlink" title="async_send方式"></a>async_send方式</h2><blockquote><p>一次性发送完数据</p></blockquote><p>其内部的实现原理就是帮我们不断的调用async_write_some直到完成发送，<code>async_send不能和async_write_some混合使用</code>，我们基于async_send封装另外一个发送函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不能与async_write_some混合使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果发送完，此时一定发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步读操作"><a href="#异步读操作" class="headerlink" title="异步读操作"></a>异步读操作</h1><h2 id="async-read-some方式"><a href="#async-read-some方式" class="headerlink" title="async_read_some方式"></a>async_read_some方式</h2><blockquote><p>触发的回调函数获取的读数据的长度可能会小于要求读取的总长度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadFromSocket</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    std::shared_ptr&lt;MsgNode&gt; _recv_node;<br>    <span class="hljs-type">bool</span> _recv_pending;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>recv_node用来缓存接收的数据，_recv_pending为true表示节点正在接收数据，还未接受完。</code></p><p><strong>具体实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不考虑粘包情况， 先用固定的字节接收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    <br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//没读完继续读</span><br>    <span class="hljs-keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;<br>        _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len,<br>            _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="async-receive方式"><a href="#async-receive方式" class="headerlink" title="async_receive方式"></a>async_receive方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，async_read_some和async_receive不能混合使用，否则会出现逻辑问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>（a）对于异步写操作，流程如下</p><ol><li>设置队列</li><li>将需要写的放入队列里</li><li>如果此时在写，则return</li><li>否则开启写操作，绑定回调函数,然后标志”正在写“</li><li>回调函数实现递归逻辑，按照顺序完成队列中所有的写操作</li></ol><p>（b）对于异步读操作，流程如下</p><ol><li>如果此时在读，则return</li><li>否则开启读操作，绑定回调函数，然后标志”正在读“</li><li>回调函数实现递归逻辑，读完为止</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>对于写操作，尽量使用async_send<br>对于读操作，尽量使用async_read_some</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//async_write_some</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造发送数据</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">// 异步发送数据</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br><br><span class="hljs-comment">//async_send</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造发送数据</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">// 异步发送数据</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <span class="hljs-comment">//注意，这个一定是直接发完了，所以不需要指定长度******</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//async_read_some</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    <span class="hljs-comment">// 异步读取数据</span><br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//async_receive</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    <span class="hljs-comment">// 异步读取数据必须指定大小，表示接受多少数据</span><br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio socket同步读写</title>
    <link href="/2023/11/12/asio%20socket%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99/"/>
    <url>/2023/11/12/asio%20socket%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="同步写write-some"><a href="#同步写write-some" class="headerlink" title="同步写write_some"></a>同步写write_some</h1><p>write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wirte_to_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>std::string buf = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::<span class="hljs-type">size_t</span> total_bytes_written = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (total_bytes_written != buf.<span class="hljs-built_in">length</span>()) &#123;<br>total_bytes_written += sock.<span class="hljs-built_in">write_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>() + total_bytes_written, buf.<span class="hljs-built_in">length</span>() - total_bytes_written)<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步写send"><a href="#同步写send" class="headerlink" title="同步写send"></a>同步写send</h1><p>send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_send</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br>std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-type">int</span> send_length = sock.<span class="hljs-built_in">send</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步写write"><a href="#同步写write" class="headerlink" title="同步写write"></a>同步写write</h1><p>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_wirte</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br>std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-type">int</span> send_length = asio::<span class="hljs-built_in">write</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读read-some"><a href="#同步读read-some" class="headerlink" title="同步读read_some"></a>同步读read_some</h1><p>同步读和同步写类似，提供了读取指定字节数的接口read_some</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">read_from_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MESSAGE_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buf[MESSAGE_SIZE];<br>std::<span class="hljs-type">size_t</span> total_bytes_read = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//如果没有读到7个字节，那么一直阻塞</span><br><span class="hljs-keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;<br>total_bytes_read += sock.<span class="hljs-built_in">read_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf + total_bytes_read,<br>MESSAGE_SIZE - total_bytes_read));<br>&#125;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buf, total_bytes_read);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read_some</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-comment">//读取数据</span><br><span class="hljs-built_in">read_from_socket</span>(sock);<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读receive"><a href="#同步读receive" class="headerlink" title="同步读receive"></a>同步读receive</h1><p>可以一次性同步读取对方发送的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_receive</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = sock.<span class="hljs-built_in">receive</span>(asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br><span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读read"><a href="#同步读read" class="headerlink" title="同步读read"></a>同步读read</h1><p>可以一次性同步接收对方发送的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = asio::<span class="hljs-built_in">read</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br><span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读取直到指定字符"><a href="#读取直到指定字符" class="headerlink" title="读取直到指定字符"></a>读取直到指定字符</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string  <span class="hljs-title">read_data_by_until</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>    asio::streambuf buf;<br>    <span class="hljs-comment">// Synchronously read data from the socket until</span><br>    <span class="hljs-comment">// &#x27;\n&#x27; symbol is encountered.  </span><br>    asio::<span class="hljs-built_in">read_until</span>(sock, buf, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    std::string message;<br>    <span class="hljs-comment">// Because buffer &#x27;buf&#x27; may contain some other data</span><br>    <span class="hljs-comment">// after &#x27;\n&#x27; symbol, we have to parse the buffer and</span><br>    <span class="hljs-comment">// extract only symbols before the delimiter. </span><br>    <span class="hljs-function">std::istream <span class="hljs-title">input_stream</span><span class="hljs-params">(&amp;buf)</span></span>;<br>    std::<span class="hljs-built_in">getline</span>(input_stream, message);<br>    <span class="hljs-keyword">return</span> message;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限制+修改单调队列（Ropeway）</title>
    <link href="/2023/11/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%B8%A6%E4%BF%AE%E6%94%B9/"/>
    <url>/2023/11/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%B8%A6%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/104128/problem/B">2022ICPC 南京B.Ropeway</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>n+2个点编号0到n+1，每个点有点权，要求选若干个点使得总点权最小，其中编号为0 和n + 1的点必须选且点权为0 ，同时满足任意两个被选的点之间的距离不超过k 。</p><p>此外还会给一个01串，表示1到n这些点是否为必选的点，1为必选，0为可选可不选</p><p>现在会给m个询问，每个询问为如果将<code>编号为x</code>的点权修改为v,答案是多少？每次询问互不影响</p><p>n&lt;&#x3D;5e5,m,k&lt;&#x3D;3e3</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>一眼单调队列，但是和普通单调队列不同，有些位置必须选，而且0，n+1都有一个点权为0的点，普通的单调队列是：0位置点权为0，而且每个点可选可不选</li><li>位置0和n+1容易处理，只需要设pre[i]为从前往后扫描，而且选i的最小花费，suf[i]表示从后往前扫描，而且选i的最小花费</li><li>有些位置必须选，可以这样思考，处理pre[i]的时候，枚举j的位置，j的区间为[i-m,i-1],表示上一个选的什么，但是如果i的前面有必须选的，那么j的范围就要改变，变成[k,i-1],k表示上一个必须选的位置，具体实现见代码</li><li>现在考虑修改，如果将位置x的值修改，那么会影响到pre和suf数组，会影响多少呢？对于pre来说，x到n全部被影响到，suf同理。</li><li>考虑答案是如何产生的，任选一个长度为k的区间，遍历这个区间所有的点，答案为min(pre[i]+suf[i]-a[i])</li><li>所以修改一个位置，保证suf不动，那么答案可以在[i,i+k]中产生，此时需要修改pre数组</li><li>但是6无法保证i+k&lt;&#x3D;n，但好像也没有关系，因为n+1这个点必选，那么从答案从n+1更新即可</li></ol><blockquote><p>第5点十分重要！！！</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> q[N],hh,tt;<span class="hljs-comment">//单调队列，存数组下标 </span><br><br><span class="hljs-type">int</span> n,k;<br>ll a[N];<span class="hljs-comment">//权值 </span><br><span class="hljs-type">char</span> s[N];<span class="hljs-comment">//s数组是01串，1表示必须选</span><br><br><span class="hljs-comment">//pre和suf表示分别从前后遍历，结尾为i的最小花费</span><br>ll pre[N],suf[N],tem[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//初始化队头队尾</span><br>hh=<span class="hljs-number">1</span>,tt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">(ll f[])</span> </span>&#123;<br><span class="hljs-built_in">init</span>();<br>q[++tt]=<span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n+<span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k) &#123;<br>hh++;<br>&#125;<br>f[i]=f[q[hh]]+a[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;f[q[tt]]&gt;=f[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//处理presuf数组</span><br><span class="hljs-built_in">get</span>(pre);<br><span class="hljs-built_in">reverse</span>(a,a+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">reverse</span>(s,s+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">get</span>(suf);<br><span class="hljs-built_in">reverse</span>(suf,suf+n+<span class="hljs-number">2</span>);<span class="hljs-comment">//反转suf数组</span><br><span class="hljs-comment">//复原</span><br><span class="hljs-built_in">reverse</span>(a,a+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">reverse</span>(s,s+n+<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br><span class="hljs-comment">//利用[pos+1,pos+k]更新答案</span><br><span class="hljs-built_in">init</span>();<br>ll ans=<span class="hljs-number">1e18</span>;<br><br><span class="hljs-comment">//对[pos-k,pos-1]做一遍单调队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,pos-k); i&lt;pos; i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k)hh++;<br>tem[i]=pre[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;pre[q[tt]]&gt;=pre[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>&#125;<br> <br><span class="hljs-comment">//更新答案[pos,pos+k-1] </span><br>    <br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时suf数组在pos位置是不准确的，但是为什么还可以用来更新答案呢？？</span><br><span class="hljs-comment">因为suf数组表示以pos为结尾，选上pos但是不计算pos的答案，也就是说，pos位置的数无论是多少，都不影响suf</span><br><span class="hljs-comment">那么此时suf值在pos位置就是准确的。</span><br><span class="hljs-comment">此时，修改pos位置，影响到suf的区间[0,pos-1]!!!!!</span><br><span class="hljs-comment">    */</span><br>    <br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos; i&lt;=<span class="hljs-built_in">min</span>(n+<span class="hljs-number">1</span>,pos+k<span class="hljs-number">-1</span>); i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k)hh++;<br>tem[i]=tem[q[hh]]+a[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;tem[q[tt]]&gt;=tem[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>ans=<span class="hljs-built_in">min</span>(ans,tem[i]+suf[i]);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">init</span>();<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>a[<span class="hljs-number">0</span>]=a[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>cin&gt;&gt;s+<span class="hljs-number">1</span>;<br>s[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;1&#x27;</span>,s[n+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;1&#x27;</span>;<span class="hljs-comment">//必须选</span><br><span class="hljs-built_in">get</span>();<span class="hljs-comment">//处理pre，suf数组</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>suf[i]-=a[i];<br>        <br>        <br><span class="hljs-comment">/*需要做这个处理</span><br><span class="hljs-comment">suf数组表示选第i个，但是第i个权值并没有算进去</span><br><span class="hljs-comment">这样ask询问好算，而且此处理后，pos修改只会影响[0,pos-1]的suf值，具体见ask处</span><br><span class="hljs-comment">*/</span><br>        <br>        <br>&#125;<br><br><span class="hljs-type">int</span> m;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--) &#123;<br><span class="hljs-type">int</span> pos,val;<br>cin&gt;&gt;pos&gt;&gt;val;<br><span class="hljs-type">int</span> back=a[pos];<br>a[pos]=val;<br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(pos)&lt;&lt;endl;<span class="hljs-comment">//计算答案</span><br>a[pos]=back;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>a.对于本题目的答案ans</p><blockquote><ol><li>对于任何一个必须选的点x，ans&#x3D;pre[x]+suf[x]-a[x]</li><li>特殊的，ans&#x3D;suf[0]+pre[n+1]</li><li>对于任何一个非必选的x，在一个长度为k的区间内，假设区间内的所有位置都非必选，则ans&#x3D;min(pre[i]+suf[i]-a[i])</li><li>第3条，假设区间内存在必须选的位置，ans&#x3D;min(pre[i]+suf[i]-a[i])&#x3D;pre[pos]+suf[pos]-a[pos]，(pos是必须要选的位置)</li></ol></blockquote><p>b.代码中，如果x+k-1&gt;n+1，也没事，因为答案会在n+1处取得</p><p>c.     注意本题目的suf数组的具体含义（见代码注释），因为这样处理，在ask询问中比较容易做，而且改变了<code>a[pos]的修改</code>对suf的影响！！！。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有限制的背包（No Bug No Game）</title>
    <link href="/2023/11/11/%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%83%8C%E5%8C%85/"/>
    <url>/2023/11/11/%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/104090/problem/C">2022 ICPC杭州 C. No Bug No Game</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有n个物品，背包容量为k，给出n组物品，每一组物品有pi个，每个物品的体积从1到pi递增，取的体积不同，获得的价值也不同，体积从1到pi(连续），价值从w1到wj   （j&#x3D;pi）</p><p>如果当前背包容量足够，则必须取完整的重量</p><p>否则必须可以取部分体积来填满剩余的背包容量，问能取得的最大价值是多少</p><p>数据范围：<code>n，k&lt;=3000,  pi&lt;=10 , wj&lt;=1e5</code></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>对于每一组物品，如果此时剩余容量大于pi，则必须取最后一个，否则必须取相应体积的物品，此时容量为0</li><li>而且，体积小的物体可能有更大的价值</li><li>显然，取的顺序有所谓，前面组必须取最后，最后一组必须取中间的某个</li><li>我们无法贪心的排序，但是可以这样想，只有一组取中间，其他组取最后，可以dp</li><li>设dp[i][j][0\1]表示前i组，且此时恰好装了j体积的最大价值，0和1表示，恰好装到j时，前i组有没有取到中间的某个物品</li></ol><p>我们发现，这样设转移方程是可以转移的，因为可以表示所有状态，第i组刚结束，并且恰好取到了j，还知道此时是否可以取中间</p><p>转移方程见代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">10</span>;<br><br>ll dp[N][N][<span class="hljs-number">2</span>];<br>ll w[N][<span class="hljs-number">15</span>];<br>ll p[N];<br>ll n,k;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br>ll sum0=<span class="hljs-number">0</span>,sum1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;p[i];<br>sum0+=p[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=p[i]; j++) &#123;<br>cin&gt;&gt;w[i][j]; <br>&#125;<br>sum1+=w[i][p[i]];<br>&#125;<br><br><span class="hljs-keyword">if</span>(sum0&lt;=k)&#123;<br>cout&lt;&lt;sum1&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=k; j++) &#123;<br>dp[i][j][<span class="hljs-number">0</span>]=dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-number">-1e18</span>;<br>&#125;<br>&#125;<br><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//前0个物品,恰好选0体积，而且没有选中间某个物品,最大价值为0</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=k; j++) &#123;<br><span class="hljs-comment">//可以选择不选当前组</span><br>dp[i][j][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>];<br>dp[i][j][<span class="hljs-number">1</span>]=dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">1</span>];<br><br><br><span class="hljs-comment">//选当前组最后一个物品</span><br><span class="hljs-comment">//更新dp[i][j][0],dp[i][j][1]</span><br><span class="hljs-keyword">if</span>(j&gt;=p[i]) &#123;<br>dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][j-p[i]][<span class="hljs-number">0</span>]+w[i][p[i]]);<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][j-p[i]][<span class="hljs-number">1</span>]+w[i][p[i]]);<br>&#125;<br><br><span class="hljs-comment">//选当前组的中间物品</span><br><span class="hljs-comment">//更新dp[i][j][1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>; t&lt;p[i]; t++) &#123;<br><span class="hljs-keyword">if</span>(j&gt;=t) &#123;<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][j-t][<span class="hljs-number">0</span>]+w[i][t]);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">千万不可以这样写！！！ </span><br><span class="hljs-comment">ans=max(ans,max(dp[i][j][0],dp[i][j][1]));</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//cout&lt;&lt;ans&lt;&lt;endl; </span><br>cout&lt;&lt;<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,<span class="hljs-built_in">max</span>(dp[n][k][<span class="hljs-number">0</span>],dp[n][k][<span class="hljs-number">1</span>]));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">千万不可以这样写！！！ </span><br><span class="hljs-comment">ans=max(ans,max(dp[i][j][0],dp[i][j][1]));</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 为什么不可以这样做？？</li></ul><p>设想这样一个情景，假设有一组，其中物品价值是 1， 1，INF，1，1</p><p>此时，dp[i][j][1]可以是前i组，容量恰好选完j，且此时选到了中间的INF，此时价值是正无穷，可是，如果实际情况是永远也不可能选到INF，这样更新会导致答案错误。</p><p>下面证明实际情况存在可能选不到INF：</p><ol><li>前i-1层遍历完，并且仅<code>dp[i-1][j][0]</code>有值，<code>dp[i-1][[j][1]</code>为-INF，实际上，不需要考虑<code>dp[i-1][j][1]</code></li><li>遍历第i层，<code>dp[i][j][1]</code>用<code>dp[i-1][j’][0]</code>更新，此时遇到了INF,被更新为INF，导致答案错误</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio socket的创建和连接</title>
    <link href="/2023/11/11/asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/11/asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="TCP和IP协议"><a href="#TCP和IP协议" class="headerlink" title="TCP和IP协议"></a>TCP和IP协议</h3><ol><li><strong>TCP（传输控制协议）</strong>：TCP是一种网络通信协议，它在互联网协议套件（TCP&#x2F;IP）中负责确保数据的可靠传输。TCP提供了一种可靠的、面向连接的通信方式。这意味着在数据开始传输之前，两个网络设备（比如计算机）之间必须首先建立一个连接。TCP还负责确保数据的完整性和顺序正确。</li><li><strong>IP协议（互联网协议）</strong>：IP协议是另一种关键的网络通信协议，负责在网络上路由和传输数据包。IP有两个主要版本：IPv4和IPv6。IPv4是目前最广泛使用的版本，但由于地址空间限制，IPv6正在逐渐被采用。</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul><li><strong>Socket是什么</strong>：Socket是网络通信的端点。您可以将其想象为电话插座，它是网络上两个程序（运行在不同计算机上或同一计算机上的不同进程）进行数据交换的接口。</li><li><strong>Socket的用途</strong>：Socket使得程序可以读写网络上的数据。在创建Socket时，您需要指定使用的协议（如TCP）。一旦建立了Socket连接，数据就可以通过这个连接在网络上进行传输。</li></ul><h3 id="TCP连接和IP协议的关系"><a href="#TCP连接和IP协议的关系" class="headerlink" title="TCP连接和IP协议的关系"></a>TCP连接和IP协议的关系</h3><ul><li>在进行TCP网络通信时，通常会使用IP协议（无论是IPv4还是IPv6）。这是因为TCP负责在两个端点之间建立一个稳定的连接，并确保数据可靠地传输，而IP协议负责将数据包路由到正确的目的地。</li><li>当您在编程中创建一个TCP Socket时，您需要指定使用的IP协议版本。例如，在Boost.Asio中，您可以创建一个使用IPv4的TCP Socket（<code>asio::ip::tcp::socket</code>），这意味着它将使用IPv4协议来路由数据。</li></ul><h1 id="网络编程基本流程"><a href="#网络编程基本流程" class="headerlink" title="网络编程基本流程"></a>网络编程基本流程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>1）socket——创建socket对象。</p><p>2）bind——绑定本机ip+port。</p><p>3）listen——监听来电，若在监听到来电，则建立起连接。</p><p>4）accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。</p><p>5）read、write——就是收发消息了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>1）socket——创建socket对象。</p><p>2）connect——根据服务端ip+port，发起连接请求。</p><p>3）write、read——建立连接后，就可发收消息了。</p><h1 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h1><h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><p><code>客户端</code>可以通过对端的ip和端口构造一个endpoint，用这个endpoint和<code>服务端</code>通信。</p><p>步骤如下：</p><ol><li>设置服务器<code>IP地址</code>（string）和 <code>PORT</code>（unsigned short）</li><li>定义<code> boost::system::error_code</code>状态码，用于存储解析<code> IP</code>时候可能发生的错误</li><li>解析IP地址,获取<code>asio::ip::address</code>对象</li><li>如果解析失败，反悔错误码</li><li>解析成功，根据<code>ip::address</code>和<code>PORT</code>建立TCP连接，获取<code>asio::ip::tcp::endpoint</code>对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义client_end_point函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">client_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 设置服务器IP地址和端口号</span><br>    <span class="hljs-comment">// 使用本地回环地址127.0.0.1进行测试</span><br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;           <br><br>    <span class="hljs-comment">// Step 2: 用于存储解析IP地址时可能发生的错误的变量</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 3: 解析IP地址</span><br>    asio::ip::address ip_address = asio::ip::address::<span class="hljs-built_in">from_string</span>(raw_ip_address, ec);<br><br>    <span class="hljs-comment">// Step 4: 检查IP地址是否正确解析</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果解析出错，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to parse the IP address. Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Step 5: 使用解析好的IP地址和端口号创建TCP端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 6: 输出端点信息，验证创建是否成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Endpoint created: IP Address = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">address</span>() <br>              &lt;&lt; <span class="hljs-string">&quot;, Port = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">port</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用client_end_point函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">client_end_point</span>();<br><br>    <span class="hljs-comment">// 检查client_end_point函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during endpoint creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 端点创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Endpoint creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p>步骤如下：</p><ol><li>定义端口号（unsigned short）</li><li>根据本机IPv6<code>asio::ip::address_v6::any()</code>协议创建<code>asio::ip::address</code>对象</li><li>根据<code>ip::address</code>和<code>Port</code>创建<code>asio::ip::tcp::endpoint</code>对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义server_end_point函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">server_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-comment">// 这里我们假设服务器应用程序已经获取了端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个特殊的asio::ip::address对象</span><br>    <span class="hljs-comment">// 它指定了主机上所有可用的IP地址</span><br>    <span class="hljs-comment">// 注意，这里我们假设服务器工作在IPv6协议上</span><br>    asio::ip::address ip_address = asio::ip::address_v6::<span class="hljs-built_in">any</span>();<br><br>    <span class="hljs-comment">// Step 3: 使用指定的IP地址和端口号创建TCP端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 端点创建完成，可以用来指定服务器应用程序希望监听传入连接的IP地址和端口号</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server endpoint created: IP Address = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">address</span>() <br>              &lt;&lt; <span class="hljs-string">&quot;, Port = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">port</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用server_end_point函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">server_end_point</span>();<br><br>    <span class="hljs-comment">// 检查server_end_point函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during server endpoint creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 服务器端点创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server endpoint creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h1><h2 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h2><p>步骤：</p><ol><li>创建<code>asio::io_context</code>对象</li><li>创建一个代表TCP协议的<code>asio::ip::tcp</code>对象protocol</li><li>创建TCP套接字对象<code>asio::ip::tcp::socket</code>,将它与<code>asio::io_context</code>对象关联</li><li>定义一个<code>boost::system::error_code</code>变量</li><li>打开套接字（使用TCP协议protocol，错误码error_code)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义create_tcp_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 创建asio::io_context对象</span><br>    <span class="hljs-comment">// io_service（或io_context）是Boost.Asio中的核心类，用于处理所有I/O操作</span><br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// Step 2: 创建一个代表TCP协议的asio::ip::tcp对象</span><br>    <span class="hljs-comment">// 这里我们使用IPv4作为底层协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3: 实例化一个活动的TCP套接字对象</span><br>    <span class="hljs-comment">// 套接字用于网络通信，这里我们将它与io_service对象关联</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储打开套接字时可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 打开套接字</span><br>    <span class="hljs-comment">// 使用之前定义的TCP协议（IPv4）打开套接字</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查套接字是否成功打开</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果打开失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用create_tcp_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br><br>    <span class="hljs-comment">// 检查create_tcp_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during socket creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 套接字创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Socket creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h2><p>需要生成一个acceptor的socket，用来接收新的连接。</p><p>步骤：</p><ol><li>创建<code>asio::io_context</code>对象</li><li>创建一个代表TCP协议的<code>asio::ip::tcp</code>对象protocol</li><li>实例化一个接收器（Acceptor） 套接字对象<code>asio::ip::tcp::acceptor</code>,参数是ios</li><li>定义一个<code>boost::system::error_code</code>变量</li><li>打开套接字（使用TCP协议protocol，错误码error_code)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义create_acceptor_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 创建asio::io_context对象</span><br>    <span class="hljs-comment">// io_service（或io_context）是Boost.Asio中的核心类，用于处理所有I/O操作</span><br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// Step 2: 创建一个代表TCP协议的asio::ip::tcp对象</span><br>    <span class="hljs-comment">// 这里我们使用IPv6作为底层协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v6</span>();<br><br>    <span class="hljs-comment">// Step 3: 实例化一个接收器（Acceptor）套接字对象</span><br>    <span class="hljs-comment">// 接收器套接字用于监听和接受传入的TCP连接</span><br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储打开接收器套接字时可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 打开接收器套接字</span><br>    <span class="hljs-comment">// 使用之前定义的TCP协议（IPv6）打开接收器</span><br>    acceptor.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查接收器套接字是否成功打开</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果打开失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to open the acceptor socket! Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用create_acceptor_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_acceptor_socket</span>();<br><br>    <span class="hljs-comment">// 检查create_acceptor_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during acceptor socket creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收器套接字创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Acceptor socket creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h1><p>acceptor类型的socket，服务器要将其绑定到指定的端点,所有连接这个端点的连接都可以被接收到</p><p>步骤：</p><ol><li>设置端口号port</li><li>创建一个端点 <code>asio::ip::tcp::endpoint</code>,利用IP，prot</li><li>创建并打开一个接收器套接字<code>asio::ip::tcp::acceptor</code>，根据<code>ios</code>和<code>协议</code></li><li>定义一个error_code变量</li><li>将接收器套接字（accecptor）绑定到端点（endpoint）， <code>acceptor.bind(ep, ec)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义bind_acceptor_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-comment">// 这里我们假设服务器应用程序已经获取了端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个端点</span><br>    <span class="hljs-comment">// 使用asio::ip::address_v4::any()表示服务器将接受发送到本机任何IPv4地址的连接</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(), port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 3: 创建并打开一个接收器套接字</span><br>    asio::io_context ios;<br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储绑定操作过程中可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 将接收器套接字绑定到端点</span><br>    acceptor.<span class="hljs-built_in">bind</span>(ep, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查接收器套接字是否成功绑定</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果绑定失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to bind the acceptor socket. Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用bind_acceptor_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">bind_acceptor_socket</span>();<br><br>    <span class="hljs-comment">// 检查bind_acceptor_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during acceptor socket binding. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收器套接字绑定成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Acceptor socket binding successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="客户端连接到指定的端点"><a href="#客户端连接到指定的端点" class="headerlink" title="客户端连接到指定的端点"></a>客户端连接到指定的端点</h1><p>步骤：</p><ol><li>获取目标服务器的IP地址和端口号</li><li>创建一个指向目标应用程序的端点endpoint，需要ip和端口号</li><li>创建并打开一个套接字socket，需要ios和IP协议</li><li>socket连接endpoint</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义connect_to_end函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect_to_end</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取目标服务器的IP地址和端口号</span><br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Step 2: 创建一个指向目标服务器应用程序的端点</span><br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;<br><br>        asio::io_context ios;<br><br>        <span class="hljs-comment">// Step 3: 创建并打开一个套接字</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>        <span class="hljs-comment">// Step 4: 连接套接字</span><br>        sock.<span class="hljs-built_in">connect</span>(ep);<br><br>        <span class="hljs-comment">// 连接成功，套接字现在可以用于发送和接收数据</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occurred! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>                  &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用connect_to_end函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">connect_to_end</span>();<br><br>    <span class="hljs-comment">// 检查connect_to_end函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during connection. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 连接成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Connection successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务端接收连接"><a href="#服务端接收连接" class="headerlink" title="服务端接收连接"></a>服务端接收连接</h1><p>步骤：</p><ol><li>设置端口号</li><li>创建端点endpoint，需要IP地址和Port</li><li>创建<code>接收器套接字</code>，需要ios和IP协议</li><li>接收器套接字<code>accecptor</code>绑定指定<code>endpoint</code></li><li>开始监听传入的连接请求 <code>acceptor.listen(BACKLOG_SIZE)</code></li><li>创建一个活动套接字sock,需要ios</li><li>接收连接请求，将活动套接字连接到客户端<code>acceptor.accept(sock)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义accept_new_connection函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept_new_connection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BACKLOG_SIZE = <span class="hljs-number">30</span>; <span class="hljs-comment">// 等待连接请求的队列大小</span><br><br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个服务器端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(), port_num)</span></span>;<br><br>    asio::io_context ios;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Step 3: 实例化并打开一个接收器套接字</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>        <span class="hljs-comment">// Step 4: 将接收器套接字绑定到服务器端点</span><br>        acceptor.<span class="hljs-built_in">bind</span>(ep);<br><br>        <span class="hljs-comment">// Step 5: 开始监听传入的连接请求</span><br>        acceptor.<span class="hljs-built_in">listen</span>(BACKLOG_SIZE);<br><br>        <span class="hljs-comment">// Step 6: 创建一个活动套接字</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>        <span class="hljs-comment">// Step 7: 接收连接请求，将活动套接字连接到客户端</span><br>        acceptor.<span class="hljs-built_in">accept</span>(sock);<br><br>        <span class="hljs-comment">// 连接成功，套接字现在可以用于与客户端进行数据交换</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occurred! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>                  &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用accept_new_connection函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">accept_new_connection</span>();<br><br>    <span class="hljs-comment">// 检查accept_new_connection函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during accepting connection. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收连接成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Accepting connection successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="概念和疑问"><a href="#概念和疑问" class="headerlink" title="概念和疑问"></a>概念和疑问</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p><input disabled="" type="checkbox"> 端点，套接字，接收器套接字对于客户端和服务端的作用</p></li><li><p><strong>客户端端点创建</strong> (<code>client_end_point</code>):</p><ul><li>设置目标服务器的IP和端口，创建客户端端点以连接服务器。</li></ul></li><li><p><strong>服务器端点创建</strong> (<code>server_end_point</code>):</p><ul><li>设置端口号，创建服务器端点以便监听来自客户端的连接。</li></ul></li><li><p><strong>创建TCP套接字</strong> (<code>create_tcp_socket</code>):</p><ul><li>创建套接字，用于客户端的连接或服务器的通信。</li></ul></li><li><p><strong>创建接收器套接字</strong> (<code>create_acceptor_socket</code>):</p><ul><li>创建接收器套接字，用于服务器端接受客户端的连接请求。</li></ul></li><li><p><strong>绑定接收器套接字</strong> (<code>bind_acceptor_socket</code>):</p><ul><li>将接收器套接字绑定到一个特定的端点，用于监听来自该端点的连接请求。</li></ul></li><li><p><strong>连接到端点</strong> (<code>connect_to_end</code>):</p><ul><li>客户端使用套接字连接到指定的服务器端点。</li></ul></li><li><p><strong>接收新连接</strong> (<code>accept_new_connection</code>):</p><ul><li>服务端监听并接受来自客户端的新连接请求。<strong>创建一个新的套接字与客户端进行通信</strong>。（注意，创建新的套接字通信）</li></ul></li><li><p><input disabled="" type="checkbox"> 端点，套接字，接收器套接字代码</p></li></ul><table><thead><tr><th>组件</th><th>功能</th><th>参数</th><th>示例代码</th><th>应用场景</th></tr></thead><tbody><tr><td>boost::system::error_code</td><td>错误代码对象</td><td>-</td><td>boost::system::error_code ec;</td><td>用于处理网络操作中的错误，如套接字打开或绑定失败。</td></tr><tr><td>asio::ip::address</td><td>表示一个IP地址</td><td>1.IP地址字符串<br />2.错误代码对象</td><td>asio::ip::address ip_address &#x3D; asio::ip::address::from_string(“127.0.0.1”, ec);</td><td>定义网络通信的IP地址，用于创建端点。</td></tr><tr><td>asio::ip::tcp::endpoint</td><td>表示一个TCP网络端点</td><td>1.ip_address<br />2.port_num</td><td>asio::ip::tcp::endpoint ep(ip_address, port_num);</td><td>用于定义TCP连接的目标地址和端口，客户端和服务器都会使用。</td></tr><tr><td>asio::io_context</td><td>提供I&#x2F;O功能</td><td>-</td><td>asio::io_context ios;</td><td>用于管理异步I&#x2F;O操作，是Boost.Asio程序的核心。</td></tr><tr><td>asio::ip::tcp::socket</td><td>TCP套接字，用于网络通信</td><td>1.<code>io_context</code>对象<br />2.协议</td><td>asio::ip::tcp::socket sock(ios);</td><td>用于客户端发起连接和服务器与客户端之间的数据交换。</td></tr><tr><td>asio::ip::tcp::acceptor</td><td>接收器套接字，用于接受连接</td><td>1.<code>io_context</code>对象<br />2.协议</td><td>asio::ip::tcp::acceptor acceptor(ios, protocol);</td><td>服务器端使用，用于监听和接受来自客户端的连接。</td></tr></tbody></table><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="1-关于地址解析"><a href="#1-关于地址解析" class="headerlink" title="1. 关于地址解析"></a>1. 关于地址解析</h4><p><strong>问题</strong>：根据string类型的ip地址解析，创建address对象，如果这个ip不是本机ip，是别的服务器的ip，就有可能解析不成功。如果是本机ip，一定可以成功。</p><p><strong>答案</strong>：当你使用一个字符串类型的IP地址来创建<code>asio::ip::address</code>对象时，如果IP地址格式正确，它应该能够成功解析，无论这个IP是否属于本机。解析失败通常是由于格式错误或不支持的地址类型。</p><h4 id="2-创建端点endpoint对象需要address对象和端口"><a href="#2-创建端点endpoint对象需要address对象和端口" class="headerlink" title="2. 创建端点endpoint对象需要address对象和端口"></a>2. 创建端点endpoint对象需要address对象和端口</h4><p><strong>问题</strong>：创建端点endpoint对象需要address对象和端口。</p><p><strong>答案</strong>：正确，<code>asio::ip::tcp::endpoint</code>对象的创建需要一个IP地址（<code>asio::ip::address</code>对象）和一个端口号。</p><h4 id="3-关于创建和打开socket"><a href="#3-关于创建和打开socket" class="headerlink" title="3. 关于创建和打开socket"></a>3. 关于创建和打开<code>socket</code></h4><p><strong>问题</strong>：创建socket对象需要ios，打开socket需要protocol和error_code?为啥需要打开呢？打开的时候在什么情况下会出错呢？</p><p><strong>答案</strong>：<code>asio::ip::tcp::socket</code>对象需要一个<code>asio::io_context</code>对象来处理I&#x2F;O操作。打开<code>socket</code>指的是使其准备好进行网络通信。如果指定的协议不支持，或者系统资源不足（如端口号被占用），打开<code>socket</code>可能会出错。</p><h4 id="4-关于acceptor"><a href="#4-关于acceptor" class="headerlink" title="4. 关于acceptor"></a>4. 关于<code>acceptor</code></h4><p><strong>问题</strong>：accecptor也是一个接收器socket，也需要打开，并且流程跟socket一样？</p><p><strong>答案</strong>：<code>asio::ip::tcp::acceptor</code>类似于一个特殊的<code>socket</code>，专门用于监听和接受来自客户端的连接。它也需要被打开和绑定到一个端点上，以便知道在哪个端口上监听。</p><h4 id="5-绑定acceptor"><a href="#5-绑定acceptor" class="headerlink" title="5. 绑定acceptor"></a>5. 绑定<code>acceptor</code></h4><p><strong>问题</strong>：绑定accecptor，是先创建，然后在将他绑定到endpoint上么？然后listen，就可以接受ip：port的消息了？</p><p><strong>答案</strong>：你需要先创建一个<code>acceptor</code>，然后将其绑定到一个<code>endpoint</code>上（一个IP地址和端口号的组合）。一旦绑定并调用了<code>listen()</code>，它就开始监听该端点上的入站连接。</p><h4 id="6-客户端访问服务端"><a href="#6-客户端访问服务端" class="headerlink" title="6. 客户端访问服务端"></a>6. 客户端访问服务端</h4><p><strong>问题</strong>：客户端访问服务端，需要socket绑定endpoint（服务器的ip:port）。</p><p><strong>答案</strong>：客户端的<code>socket</code>需要连接到服务器的<code>endpoint</code>（服务器的IP地址和端口号）。</p><h4 id="7-关于asio-ip-address-v6-any"><a href="#7-关于asio-ip-address-v6-any" class="headerlink" title="7. 关于asio::ip::address_v6::any()"></a>7. 关于<code>asio::ip::address_v6::any()</code></h4><p><strong>问题</strong>：asio::ip::address_v6::any()，这种代码只会在服务器上创建endpoint上使用，而且基本不会出错？</p><p><strong>答案</strong>：<code>asio::ip::address_v6::any()</code>在服务器上创建一个可以接受任何IPv6地址的端点，这意味着它可以从任何IPv6地址接收连接。这通常不会出错，除非有底层网络配置问题。</p><h4 id="8-关于接收器端点的访问"><a href="#8-关于接收器端点的访问" class="headerlink" title="8. 关于接收器端点的访问"></a>8. 关于接收器端点的访问</h4><p><strong>问题</strong>：接收器接受服务器的端点，此时是不是只用（端点的ip，和端口号）访问？比如开放了公网ip，那只可以用“公网ip:端口”访问，如果用“127.0.0.1：3333”就不可以（如果服务器在本地）。</p><p><strong>答案</strong>：如果服务器监听公网IP和端口，那么客户端必须使用这个公网IP和端口来连接。如果服务器监听的是本地地址（如127.0.0.1），那么只有本地客户端（在同一台机器上）可以使用这个地址和端口连接。</p><h4 id="9-理解asio-io-context的重要性"><a href="#9-理解asio-io-context的重要性" class="headerlink" title="9. 理解asio::io_context的重要性"></a>9. 理解<code>asio::io_context</code>的重要性</h4><p><strong>问题</strong>：如果不理解asio::io_context，是不是可以先跳过？</p><p><strong>答案</strong>：<code>asio::io_context</code>是Boost Asio库的核心，负责管理所有I&#x2F;O服务。虽然一开始可能不容易理解，但它在Asio编程中非常重要，建议不要跳过。随着实践的增加，你会逐渐理解它的用途和重要性。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置docker服务器</title>
    <link href="/2023/11/07/docker%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/07/docker%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>本文介绍如何在ubuntu环境下创建docker容器，并且将此容器设置成一个“服务器”</li><li>然后如何ssh进docker容器(root用户)，并且配置免密登录</li></ul><p><em>步骤如下</em></p><hr><h1 id="1-创建Dockerfile文件"><a href="#1-创建Dockerfile文件" class="headerlink" title="1.创建Dockerfile文件"></a>1.创建Dockerfile文件</h1><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Docker"><span class="hljs-comment"># 使用官方Ubuntu基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-comment"># 避免在自动化构建时出现提示</span><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># 安装开发所需的包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span><br><span class="language-bash">    vim \</span><br><span class="language-bash">    git \</span><br><span class="language-bash">    curl \</span><br><span class="language-bash">    wget \</span><br><span class="language-bash">    build-essential \</span><br><span class="language-bash">    lsb-release \</span><br><span class="language-bash">    sudo \</span><br><span class="language-bash">    man \</span><br><span class="language-bash">    software-properties-common \</span><br><span class="language-bash">    ca-certificates \</span><br><span class="language-bash">    &amp;&amp; apt-get clean \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># 如果需要其他语言环境或工具，可以在这里继续安装，比如对于Python开发：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3 python3-pip</span><br><br><span class="hljs-comment"># 对于Node.js开发：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -sL https://deb.nodesource.com/setup_14.x | bash - &amp;&amp; apt-get update &amp;&amp; apt-get install -y nodejs</span><br><br><span class="hljs-comment"># 清理apt缓存以减少镜像大小</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get clean &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># （可选）设置工作目录，这是容器内的目录，你的项目代码可以放在这里</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><br><span class="hljs-comment"># 设置默认运行的命令，此命令将保持容器运行</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;tail&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;/dev/null&quot;</span>]</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-执行命令创建镜像"><a href="#2-执行命令创建镜像" class="headerlink" title="2.执行命令创建镜像"></a>2.执行命令创建镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t mydocker .<br></code></pre></td></tr></table></figure><p>将<code>mydocker</code>换成你想要的镜像名称</p><hr><h1 id="3-利用镜像创建容器"><a href="#3-利用镜像创建容器" class="headerlink" title="3.利用镜像创建容器"></a>3.利用镜像创建容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name mydocker-container -p 8080:8080 -p 20000:22 mydocker<br></code></pre></td></tr></table></figure><p>将<code>mydocker-container</code>换成你自己的容器名称，<code>mydocker</code>是镜像名称</p><hr><p>此时容器已经创建成功，可以进入容器查看 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it myapp-container /bin/bash<br></code></pre></td></tr></table></figure><h1 id="4-配置并开启docker容器的ssh服务"><a href="#4-配置并开启docker容器的ssh服务" class="headerlink" title="4.配置并开启docker容器的ssh服务"></a>4.配置并开启docker容器的ssh服务</h1><h2 id="a-确保-SSH-服务已经在容器内安装并正在运行。"><a href="#a-确保-SSH-服务已经在容器内安装并正在运行。" class="headerlink" title="(a)确保 SSH 服务已经在容器内安装并正在运行。"></a>(a)确保 SSH 服务已经在容器内安装并正在运行。</h2><p>可以使用以下命令来安装并启动 SSH 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker apt-get update<br>docker <span class="hljs-built_in">exec</span> -it xddocker apt-get install -y openssh-server<br>docker <span class="hljs-built_in">exec</span> -it xddocker service ssh start<br></code></pre></td></tr></table></figure><p>如果 <code>service ssh start</code> 不工作，您也可以尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker /etc/init.d/ssh start<br></code></pre></td></tr></table></figure><p>或者直接使用 systemctl（如果您的容器支持 systemd）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker systemctl start ssh<br></code></pre></td></tr></table></figure><h2 id="b-设置-root-用户的密码。"><a href="#b-设置-root-用户的密码。" class="headerlink" title="(b)设置 root 用户的密码。"></a>(b)设置 <code>root</code> 用户的密码。</h2><p>你需要使用 <code>passwd</code> 命令来为 <code>root</code> 用户设置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker passwd root<br></code></pre></td></tr></table></figure><p>当系统提示时输入并确认密码。</p><h2 id="d-配置-SSH-以允许-root-用户登录。"><a href="#d-配置-SSH-以允许-root-用户登录。" class="headerlink" title="(d)配置 SSH 以允许 root 用户登录。"></a>(d)配置 SSH 以允许 <code>root</code> 用户登录。</h2><p>编辑容器中的 <code>/etc/ssh/sshd_config</code> 文件，将 <code>PermitRootLogin</code> 的值更改为 <code>yes</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker sed -i <span class="hljs-string">&#x27;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><h2 id="e-重新启动-SSH-服务以使更改生效："><a href="#e-重新启动-SSH-服务以使更改生效：" class="headerlink" title="(e)重新启动 SSH 服务以使更改生效："></a>(e)重新启动 SSH 服务以使更改生效：</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> xddocker service ssh restart<br></code></pre></td></tr></table></figure><h2 id="f-使用-SSH-连接到容器："><a href="#f-使用-SSH-连接到容器：" class="headerlink" title="(f)使用 SSH 连接到容器："></a>(f)使用 SSH 连接到容器：</h2><p>现在您应该可以使用 SSH 连接到容器的 <code>root</code> 用户了。使用宿主机的端口 <code>20000</code> 来连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@localhost -p 20000<br></code></pre></td></tr></table></figure><hr><p><strong>到此为止，docker容器的ssh已经完全配置好了</strong></p><hr><h1 id="5-配置免密登录"><a href="#5-配置免密登录" class="headerlink" title="5.配置免密登录"></a>5.配置免密登录</h1><p>以下是在Windows系统使用Git Bash来完成这个过程的详细步骤</p><hr><h2 id="a-生成SSH密钥对"><a href="#a-生成SSH密钥对" class="headerlink" title="(a)生成SSH密钥对"></a>(a)生成SSH密钥对</h2><p>打开<code>git bash</code>,输入命令生成密钥对，一路回车，密钥对在 <code>/c/Users/&lt;你的用户名&gt;/.ssh/id_rsa</code>文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure><h2 id="b-复制SSH公钥到远程服务器"><a href="#b-复制SSH公钥到远程服务器" class="headerlink" title="(b)复制SSH公钥到远程服务器"></a>(b)复制SSH公钥到远程服务器</h2><p>本地git bash中查看公钥内容,复制下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>然后登录远程主机   (端口号20000，这是映射的端口)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@远程主机ip -p 20000<br></code></pre></td></tr></table></figure><p>登录到远程服务器后，执行以下命令来编辑（或创建）<code>authorized_keys</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.ssh<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">touch</span> ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br>vim ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>将复制的公钥粘贴进文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basj">按i键进入编辑模式<br>按住Shift+Insert进行粘贴<br>按Esc退出面积模式<br>输入&quot;:wq&quot;保存退出<br></code></pre></td></tr></table></figure><h2 id="c-退出后，即可进行免密登录"><a href="#c-退出后，即可进行免密登录" class="headerlink" title="(c)退出后，即可进行免密登录"></a>(c)退出后，即可进行免密登录</h2>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树逆序对（Master of Both）</title>
    <link href="/2023/11/07/%E5%AD%97%E5%85%B8%E6%A0%91%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2023/11/07/%E5%AD%97%E5%85%B8%E6%A0%91%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p> <a href="https://codeforces.com/gym/104090/problem/K">2022ICPC杭州K题 Master of Both</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定n和m，表示n个字符串和m组询问</p><p>字符串长度1e5，总长度不超过1e6</p><p>m组询问中，每次给定一个字符串（只含有26个不同的小写字母），表示比较规则（前面小于后面），求n个字符串中的逆序对个数</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>首先发现，对于n个字符串中任意两个字符串a,b，只有两种情况</p><ul><li><input disabled="" type="checkbox"> a是b的前缀，那么此时a&lt;b一定成立，在任何比较规则下</li><li><input disabled="" type="checkbox"> a不是b的前缀，那么，首先找到<code>最长公共前缀的下一个字符</code>，这俩字符即可决定a和b的大小关系，并且a和b的大小关系只由这一对字符决定</li></ul><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><ol><li>字典树</li><li>插入字符串的时候维护res数组和cnt数组。</li><li>设res[i][j]表示 字母i&gt;字母j的情况下，产生的逆序对个数</li><li>设cnt数组表示字典树中节点i的字数中有多少个单词</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> t[N][<span class="hljs-number">26</span>],idx;<br>ll cnt[N];<span class="hljs-comment">//trie中每个节点的权值 </span><br>ll res[<span class="hljs-number">26</span>][<span class="hljs-number">26</span>];<span class="hljs-comment">//在i&gt;j的规则下，整个序列产生的逆序对 </span><br>ll chushi;<span class="hljs-comment">//表示一定会产生的逆序对个数 </span><br>ll n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_res</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-comment">//当前在p节点，要经过边q</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br><span class="hljs-comment">//当i&gt;q的时候，产生的逆序对个数增加 cnt个 </span><br>res[i][q]+=cnt[t[p][i]];<br>&#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>&#123;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前节点 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-type">int</span> q=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//边的方向</span><br><span class="hljs-keyword">if</span>(!t[p][q])t[p][q]=++idx;<br><br><span class="hljs-built_in">update_res</span>(p,q);<br><br>p=t[p][q];<br><br>cnt[p]++; <br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>chushi+=cnt[t[p][i]];<span class="hljs-comment">//一定会产生的逆序对 </span><br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>&#123;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br><span class="hljs-comment">//注意j在i前面，因为s[j]&gt;s[i] </span><br>ans+=res[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">insert</span>(s);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>string s;<br>cin&gt;&gt;s;<br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(s)+chushi&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>字典树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悬线法dp(玉蟾宫+ICPC银川K)</title>
    <link href="/2023/11/07/%E6%82%AC%E7%BA%BF%E6%B3%95dp/"/>
    <url>/2023/11/07/%E6%82%AC%E7%BA%BF%E6%B3%95dp/</url>
    
    <content type="html"><![CDATA[<h1 id="玉蟾宫"><a href="#玉蟾宫" class="headerlink" title="玉蟾宫"></a>玉蟾宫</h1><p><a href="https://www.luogu.com.cn/problem/P4147">洛谷P4147玉蟾宫</a></p><p>给一个矩阵，一些点有障碍物，求最大子矩阵</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p><code>悬线法dp</code>，第一次听说。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>（1）结论：答案一定是一个矩形（废话。。。）<br>（2）最大矩形一定是：由其中<code>某个点</code>，<code>先</code>向上扩展到最大，<code>然后</code>再分别向左、向右走到最远。<br>（3）由于（2）的结论对所有点这样操作，一定可以找到最大矩形<br>  (4)  注意<code>先初始化h，L，R</code>，然后在<code>h=1的时候预处理L,R</code>，然后<code>再更新h，同时更新L，R</code>，并且统计答案   </p><h2 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">char</span> a[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][N];<span class="hljs-comment">//每个点往上延申的最大长度</span><br><span class="hljs-type">int</span> L[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往左走最远到哪</span><br><span class="hljs-type">int</span> R[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往右走最远到哪</span><br><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)h[i][j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//自己</span><br>L[i][j]=R[i][j]=j;<span class="hljs-comment">//自己 </span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//在h=1的情况下处理L和R </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//处理L </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>L[i][j]=L[i][j<span class="hljs-number">-1</span>];<br>&#125; <br>&#125; <br><span class="hljs-comment">//处理R </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>R[i][j]=R[i][j+<span class="hljs-number">1</span>];<br>&#125; <br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<span class="hljs-comment">//h数组扩展 </span><br><br><span class="hljs-comment">//L、R向内收缩 </span><br>L[i][j]=<span class="hljs-built_in">max</span>(L[i][j],L[i<span class="hljs-number">-1</span>][j]);<br>R[i][j]=<span class="hljs-built_in">min</span>(R[i][j],R[i<span class="hljs-number">-1</span>][j]); <br>&#125;<br><br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,h[i][j]*(R[i][j]-L[i][j]+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>&#125; <br>cout&lt;&lt;ans*<span class="hljs-number">3</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="ICPC银川"><a href="#ICPC银川" class="headerlink" title="ICPC银川"></a>ICPC银川</h1><p><a href="https://codeforces.com/gym/104021/problem/K">Largest Common Submatrix</a></p><p>给定一个矩阵A和一个矩阵B，求最大子矩阵，满足最大子矩阵同时是A的最大子矩阵和B的最大子矩阵</p><h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>悬线法dp，注意转移条件，以及<code>边界问题</code>！！！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> b[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][N];<span class="hljs-comment">//每个点往上延申的最大长度</span><br><span class="hljs-type">int</span> L[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往左走最远到哪</span><br><span class="hljs-type">int</span> R[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往右走最远到哪</span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;pos[N*N];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br>cin&gt;&gt;a[i][j];<br>h[i][j]=<span class="hljs-number">1</span>;<br>L[i][j]=R[i][j]=j;<span class="hljs-comment">//自己</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br>cin&gt;&gt;b[i][j];<br>pos[b[i][j]]= &#123;i,j&#125;;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//在h=1的情况下处理L和R</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">//处理L</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j&lt;=m; j++) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//a中当前数字的左边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[x].first;<br><span class="hljs-type">int</span> by=pos[x].second;<br><br><span class="hljs-comment">//如果可以向左边扩展</span><br><span class="hljs-keyword">if</span>(b[bx][by<span class="hljs-number">-1</span>]==y) &#123;<br>L[i][j]=L[i][j<span class="hljs-number">-1</span>];<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//处理R</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">1</span>; j--) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i][j+<span class="hljs-number">1</span>];<span class="hljs-comment">//a中当前数字的右边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[x].first;<br><span class="hljs-type">int</span> by=pos[x].second;<br><br><span class="hljs-comment">//如果可以向右边扩展</span><br><span class="hljs-keyword">if</span>(b[bx][by+<span class="hljs-number">1</span>]==y) &#123;<br>R[i][j]=R[i][j+<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//更新h,L,R ，统计答案</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">//a中当前数字的上边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[a[i][j]].first;<br><span class="hljs-type">int</span> by=pos[a[i][j]].second;<br><br><span class="hljs-comment">//如果可以向上边扩展</span><br><span class="hljs-keyword">if</span>(y&amp;&amp;b[bx<span class="hljs-number">-1</span>][by]==y) &#123;<br>h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>L[i][j]=<span class="hljs-built_in">max</span>(L[i][j],L[i<span class="hljs-number">-1</span>][j]);<br>R[i][j]=<span class="hljs-built_in">min</span>(R[i][j],R[i<span class="hljs-number">-1</span>][j]);<br>&#125;<br>ans=<span class="hljs-built_in">max</span>(ans,h[i][j]*(R[i][j]-L[i][j]+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
