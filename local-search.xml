<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字节序大小端问题</title>
    <link href="/2023/11/16/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/16/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="字节序的问题"><a href="#字节序的问题" class="headerlink" title="字节序的问题"></a>字节序的问题</h1><p>字节序问题，通常被称为大小端问题（Endianess），涉及到数据在计算机内存中的存储方式，尤其是多字节值（如整数、浮点数）的存储顺序。这个问题在不同架构的计算机系统中尤为重要，因为它会影响数据的解释和处理。主要有两种类型的字节序：</p><ol><li><strong>大端序（Big Endian）</strong>：在这种方式下，多字节值的最高有效字节（MSB）存储在最低的内存地址，随后是次高有效字节，以此类推。例如，数值 <code>0x12345678</code> 在内存中会被存储为 <code>12 34 56 78</code>（地址由低到高排列）。</li><li><strong>小端序（Little Endian）</strong>：与大端序相反，小端序将多字节值的最低有效字节（LSB）存储在最低的内存地址。同样的数值 <code>0x12345678</code> 在小端序系统中将被存储为 <code>78 56 34 12</code>。</li></ol><p>字节序问题在跨平台数据交换时尤为重要。如果两个交流数据的系统采用不同的字节序，没有适当的转换，数据可能会被错误地解释，导致问题。例如，在网络编程中，通常采用大端序（网络字节序），因此在数据发送和接收时，可能需要在小端序和大端序之间进行转换。</p><p><strong>产生问题的原因</strong>：</p><p>在网络通信中，如果数字（如整数或浮点数）的字节序没有从<code>发送方</code>的主机序转换为统一的网络字节序（大端序），那么<code>接收方</code>可能无法正确解释接收到的数据。这是因为<strong>不同的计算机架构可能采用不同的字节序</strong>，导致相同的数字在不同系统上的内存表示不同</p><h1 id="如何区分本机字节序"><a href="#如何区分本机字节序" class="headerlink" title="如何区分本机字节序"></a>如何区分本机字节序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 判断当前系统的字节序是大端序还是小端序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 当前系统为小端序</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 当前系统为大端序</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;num;<br>cout &lt;&lt; <span class="hljs-string">&quot;原始数据：&quot;</span> &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_big_endian</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统为大端序&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(num); i++) &#123;<br>cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统为小端序&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">sizeof</span>(num) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务器使用网络字节序"><a href="#服务器使用网络字节序" class="headerlink" title="服务器使用网络字节序"></a>服务器使用网络字节序</h1><p>为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。</p><p>可以使用<br><code> boost::asio::detail::socket_ops::host_to_network_long()</code> 和 <code>boost::asio::detail::socket_ops::host_to_network_short()</code> 函数</p><p><strong>将主机字节序转换为网络字节序</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> host_long_value = <span class="hljs-number">0x12345678</span>;<br>    <span class="hljs-type">uint16_t</span> host_short_value = <span class="hljs-number">0x5678</span>;<br>    <span class="hljs-type">uint32_t</span> network_long_value = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_long</span>(host_long_value);<br>    <span class="hljs-type">uint16_t</span> network_short_value = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(host_short_value);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Host long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_long_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Network long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_long_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Host short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_short_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Network short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_short_value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host long value: 0x12345678<br>Network long value: 0x78563412<br>Host short value: 0x5678<br>Network short value: 0x7856<br></code></pre></td></tr></table></figure><hr><blockquote><p>注意：在使用这些函数时，应该确保输入参数和返回结果都是无符号整数类型，否则可能会出现错误。</p></blockquote><p>服务器<code>发送数据</code>时，将数据长度转化为<code>网络字节序</code>，<br>在<code>接收数据</code>时，将长度转为<code>本机字节序</code>。</p><p><strong>将网络字节序转换为主机字节序</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len=boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br></code></pre></td></tr></table></figure><hr><h1 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h1><p>发送时我们会将发送的消息放入队列里以保证发送的时序性，每个session都有一个发送队列，因为有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>    <span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-comment">//如果大于&quot;队列size允许的容量&quot;,则不允许发送</span><br>    <span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br>    <span class="hljs-keyword">if</span> (send_que_size&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>    boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), <br>        std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字节序问题的解决需要程序员显示的调用函数，asio不会自动帮我们实现</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>处理网络粘包问题</title>
    <link href="/2023/11/15/%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/15/%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h1><p>原因：</p><p>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！</p><p>其他的原因:<br>1   客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！。<br>2   tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法。<br>3   再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连。</p><h1 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h1><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议：</p><p><code>消息id</code>+<code>消息长度</code>+<code>消息内容</code></p><h1 id="MsgNode类"><a href="#MsgNode类" class="headerlink" title="MsgNode类"></a>MsgNode类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br>    <span class="hljs-comment">//Csession可以访问私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span>;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//(发送msg)，数组长度为（max_len+头长度+1)，结尾&quot;\0&quot;,当前长度为0</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len) :_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>        <span class="hljs-built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);<br>        <span class="hljs-built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);<br>        _data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//(读取msg)，数组为（max_len+1），，结尾&quot;\0&quot;,当前长度为0</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>    &#125;<br><br>    ~<span class="hljs-built_in">MsgNode</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] _data;<br>    &#125;<br><br>    <span class="hljs-comment">//清空消息内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>&#123;<br>        ::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, _total_len);<br>        _cur_len = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">short</span> _cur_len;  <span class="hljs-comment">//当前消息长度</span><br>    <span class="hljs-type">short</span> _total_len;<span class="hljs-comment">//消息总长度</span><br>    <span class="hljs-type">char</span>* _data;     <span class="hljs-comment">//消息内容</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>_cur_len;  &#x2F;&#x2F;当前消息长度</li><li>_total_len;&#x2F;&#x2F;消息总长度</li><li>_data;     &#x2F;&#x2F;消息内容</li><li>MsgNode(short max_len)           接受消息（read)的话需要这个构造</li><li>MsgNode(char* msg, short max_len)  发送消息（wrire）的话需要找个构造</li></ul><h1 id="CSession"><a href="#CSession" class="headerlink" title="CSession"></a>CSession</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为能够对收到的数据切包处理，需要定义一个消息接收节点，一个bool类型的变量表示头部是否解析完成，以及将处理好的头部先缓存起来的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    ~<span class="hljs-built_in">CSession</span>();<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开始接收消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<span class="hljs-comment">//发送消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//关闭会话</span><br>    <span class="hljs-function">std::shared_ptr&lt;CSession&gt; <span class="hljs-title">SharedSelf</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取this指针</span><br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读回调</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>    <span class="hljs-comment">//写回调</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>    tcp::socket _socket;<br>    std::string _uuid;<br><br>    <span class="hljs-comment">//接收数据的缓冲区</span><br>    <span class="hljs-type">char</span> _data[MAX_LENGTH];<br><br>    <span class="hljs-comment">//对应的服务器</span><br>    CServer* _server;<br><br><br>    <span class="hljs-type">bool</span> _b_close;<span class="hljs-comment">//是否关闭</span><br><br>    <span class="hljs-comment">//发送队列</span><br>    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>    std::mutex _send_lock;<span class="hljs-comment">//发送锁，防止多线程同时发送</span><br><br><br>    <span class="hljs-comment">//收到的消息结构</span><br>    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br>    <span class="hljs-type">bool</span> _b_head_parse;<span class="hljs-comment">//是否解析到头部</span><br>    <span class="hljs-comment">//收到的头部结构</span><br>    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//构造会话，_socket，服务器指针，关闭标志位，头部解析标志位，接收头部节点</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server), _b_close(<span class="hljs-literal">false</span>), _b_head_parse(<span class="hljs-literal">false</span>) &#123;<br><br><span class="hljs-comment">//生成uuid</span><br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br><br><span class="hljs-comment">//初始化接收头部节点</span><br>_recv_head_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);<br>&#125;<br>CSession::~<span class="hljs-built_in">CSession</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Close</span><span class="hljs-params">()</span> </span>&#123;<br>_socket.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭socket</span><br>_b_close = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置关闭标志位</span><br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><span class="hljs-comment">//获取this指针</span><br>std::shared_ptr&lt;CSession&gt;CSession::<span class="hljs-built_in">SharedSelf</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//开始接收数据</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//异步读取数据</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-comment">//发送消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<span class="hljs-comment">//加锁</span><br><br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获取当前发送队列大小</span><br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//将消息放入发送队列</span><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><br><span class="hljs-comment">//如果当前发送队列不为空，则说明有消息正在发送，不需要再次发送</span><br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//发送消息</span><br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-comment">//写回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<span class="hljs-comment">//加锁</span><br>cout &lt;&lt; <span class="hljs-string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="hljs-built_in">front</span>()-&gt;_data + HEAD_LENGTH &lt;&lt; endl;<br><br>_send_que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//write成功，一定发送完一条数据，所以直接pop</span><br><br><span class="hljs-comment">//如果发送队列不为空，则继续发送</span><br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, shared_self));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<span class="hljs-comment">//关闭会话</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">//从服务器中移除</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//读回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-comment">//已经移动的字符数</span><br><span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//如果接受到了数据，则继续接收</span><br><span class="hljs-keyword">while</span> (bytes_transferred &gt; <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-comment">//如果未处理头部，则先处理头部</span><br><span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br><span class="hljs-comment">//情况1：收到的数据不足头部大小</span><br><span class="hljs-keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;<br><br><span class="hljs-comment">//将数据复制到头部节点</span><br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_head_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//情况2：收到的数据比头部多</span><br><br><span class="hljs-comment">//头部剩余未复制的长度</span><br><span class="hljs-type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);<br><br><span class="hljs-comment">//更新已处理的data长度和剩余未处理的长度</span><br>copy_len += head_remain;<br>bytes_transferred -= head_remain;<br><br><span class="hljs-comment">//获取头部数据（应该接受到的消息，而不是真正接受到的消息）</span><br><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br><br><span class="hljs-comment">//头部长度非法</span><br><span class="hljs-keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);    <span class="hljs-comment">//从服务器中移除</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//创建接收消息节点</span><br>_recv_msg_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br><br><span class="hljs-comment">//情况3：消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; data_len) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续接收</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><br><span class="hljs-comment">//头部处理完成,下一个回调处理头部。</span><br>_b_head_parse = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//情况4：接受的长度 &gt; 头部规定的长度，说明数据已经收全，则将消息放到接收节点里</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);<br>_recv_msg_node-&gt;_cur_len += data_len;<br>copy_len += data_len;<br>bytes_transferred -= data_len;<br><br><span class="hljs-comment">//将最后一个位置置为&#x27;\0&#x27;，表示一个消息的结束(其实也不需要)</span><br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><span class="hljs-comment">//情况5:继续轮询剩余未处理数据(下一个头部）</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<span class="hljs-comment">//清空头部节点</span><br><br><span class="hljs-comment">//如果剩余数据没有了，则继续接收</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续接收</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//否则处理头部</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">//已经处理完头部，处理上次未接受完的消息数据</span><br><br><br><span class="hljs-comment">//获取应该处理的长度</span><br><span class="hljs-type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br><br><span class="hljs-comment">//情况1：接受的数据&lt;应该接受的数据</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//情况2：接受的数据&gt;应该接受的数据</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);<br>_recv_msg_node-&gt;_cur_len += remain_msg;<br>bytes_transferred -= remain_msg;<br>copy_len += remain_msg;<br><br><span class="hljs-comment">//将最后一个位置置为&#x27;\0&#x27;，表示一个消息的结束(其实也不需要)</span><br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><br><span class="hljs-comment">//处理下一个消息的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//清空头部节点</span><br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><br><span class="hljs-comment">//如果剩余数据没有了，则继续接收</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//否则处理头部</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<span class="hljs-comment">//关闭会话</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">//从服务器中移除</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>处理粘包具体步骤：</strong></p><ol><li>判断是否在读头部，分为两种情况</li><li>读头部：<ul><li>收到的数据还不够2字节，那么头部构造不出来，继续异步接受，return</li><li>收到的数据够头部，解析出头部，然后将剩余的数据与解析出的数据对比</li><li>如果剩余的数据<code>少于</code>解析出的头部，那么接着读，并且下一次读到（内容区）</li><li>如果剩余的数据<code>大于</code>解析出的头部，构造完整消息，如果还有数据，continue，否则接着监听</li></ul></li><li>读内容：<ul><li>收到的数据不够装满内容区，则接着监听，return</li><li>收到的数据<code>大于</code>内容区域,内容数据构造完后，下一次需要读，如果剩余数据为0，则接着监听，如果还有数据，则continue</li></ul></li></ol><h1 id="Cserver类"><a href="#Cserver类" class="headerlink" title="Cserver类"></a>Cserver类</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//端口号</span><br><span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//接受回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br><span class="hljs-comment">//开始接受</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>;<br><br><br>boost::asio::io_context&amp; _io_context;<br><span class="hljs-type">short</span> _port;<br>tcp::acceptor _acceptor;<span class="hljs-comment">//接收器（需要端点）</span><br><br><span class="hljs-comment">//会话列表</span><br>std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port) :_io_context(io_context), _port(port),<br>_acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br>shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio健壮的异步服务器</title>
    <link href="/2023/11/13/asio%E5%BB%B6%E9%95%BFsession%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/11/13/asio%E5%BB%B6%E9%95%BFsession%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>asio异步应答服务器存在隐患，就是因为使用了delete删除session对象，而本章使用智能指针防止重复delete对象session，使用智能指针构造成一个伪闭包的状态延长session的生命周期。</p><h1 id="智能指针管理Session"><a href="#智能指针管理Session" class="headerlink" title="智能指针管理Session"></a>智能指针管理Session</h1><p>我们可以通过智能指针的方式管理Session类，将<code>acceptor</code>接收的链接保存在<code>Session类型</code>的<code>智能指针</code>里。由于智能指针会在引用计数为0时自动析构，所以为了防止其被自动回收，也方便Server管理Session。因为我们后期会做一些重连踢人等业务逻辑，我们在Server类中添加成员变量，该变量为一个map类型，<code>key为Session的uid</code>，<code>value为该Session的智能指针</code>,此时也会增加引用计数</p><h1 id="session类"><a href="#session类" class="headerlink" title="session类"></a>session类</h1><h2 id="session类定义"><a href="#session类定义" class="headerlink" title="session类定义"></a>session类定义</h2><ul><li>首先定义一个消息节点，表示接受或者发送的消息</li><li>定义session类，继承std::enable_shared_from_this&lt;CSession&gt;</li><li>session存储socket，server，消息队列，uuid</li><li>回调函数中多一个参数，shared_ptr&lt;CSession&gt; _self_shared，传入_self_shared保证引用计数+1，从而防止隐患</li></ul><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENGTH  1024</span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span>;<br><br><br><span class="hljs-comment">//定义消息节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_len) &#123;<br>_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[max_len];<br><span class="hljs-built_in">memcpy</span>(_data, msg, max_len);<br>&#125;<br><br>~<span class="hljs-built_in">MsgNode</span>() &#123;<br><span class="hljs-keyword">delete</span>[] _data;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _cur_len;<span class="hljs-comment">//当前发送（接受）消息长度</span><br><span class="hljs-type">int</span> _max_len;<span class="hljs-comment">//最大消息长度</span><br><span class="hljs-type">char</span>* _data;<span class="hljs-comment">//消息内容</span><br>&#125;;<br><br><span class="hljs-comment">//定义会话类，继承自enable_shared_from_this，用于在异步操作中获取this指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> :<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数只需要io_context，不需要ip、端口，因为是服务器方，accecptor才会有ip和端口</span><br><span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    <br>~<span class="hljs-built_in">CSession</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Ssession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br>    <br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开启监听状态</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<span class="hljs-comment">//开启写状态</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读回调，注意最后一个参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br>    <br>    <span class="hljs-comment">//写回调，不需要指定bytes_transferred，注意最后一个参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br><br><br><span class="hljs-comment">//会话的socket</span><br>tcp::socket _socket;<br><span class="hljs-comment">//每个会话都有一个唯一的uuid</span><br>std::string _uuid;<br><br><span class="hljs-comment">//接收数据的缓冲区</span><br><span class="hljs-type">char</span> _data[MAX_LENGTH];<br><br><span class="hljs-comment">//对应的服务器</span><br>CServer* _server;<br><br><span class="hljs-comment">//发送队列</span><br>std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br><br><span class="hljs-comment">//发送锁，防止多线程同时发送</span><br>std::mutex _send_lock;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="session实现"><a href="#session实现" class="headerlink" title="session实现"></a>session实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//构造函数，初始化socket对象，初始化server，同时初始化随机数uuid，用于标识每个连接</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server) &#123;<br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><br><br><span class="hljs-comment">//开始监听读取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意绑定的是shared_from_this()！！</span><br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><span class="hljs-comment">//读回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;read data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><br><span class="hljs-comment">//将读取到的数据发送给客户端</span><br><span class="hljs-built_in">Send</span>(_data, bytes_transferred);<br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续监听读取</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, _self_shared));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//如果读取失败，清除session</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//填入消息队列发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否有待发送的数据</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果有待发送的数据，将数据放入队列，等待发送</span><br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><span class="hljs-keyword">if</span> (pending) &#123;<span class="hljs-comment">//如果有待发送的数据，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果没有待发送的数据，直接发送</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><span class="hljs-comment">//写回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-comment">//由于async_write一次发送数据完整，所以可以直接pop</span><br>_send_que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//如果还有待发送的数据，继续发送</span><br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_max_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, _self_shared));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-comment">//如果写入失败，清除session</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>start中开始异步读，读回调有send函数（异步写），然后接着开始异步读，继续监听</li><li>send函数开始异步写（如果此时没有在发送消息），写回调中开始异步写，直到全部写完</li></ul><blockquote><p>注意，此方式中:</p><p>异步读-&gt;读回调（这个里面调用send，开启异步写）-&gt;异步读</p><p>异步写-&gt;写回调-&gt;异步写</p></blockquote><p>如果回调函数中不增加引用计数，就会存在风险，假设异步读<strong>之后</strong>，客户端关闭连接，此时读回调<code>调用</code>send开启异步写，然后读回调<code>开启</code>异步读，会Clearsesson（uuid）两次，这样可能会导致：shared_ptr引用计数变为0，最后一次调用的时候，访问不存在的内存</p><h1 id="Cserver类"><a href="#Cserver类" class="headerlink" title="Cserver类"></a>Cserver类</h1><h2 id="Cserver类定义"><a href="#Cserver类定义" class="headerlink" title="Cserver类定义"></a>Cserver类定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//accecptor需要端口</span><br><span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br>    <br>    <span class="hljs-comment">//删除map中的session</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <br>    <span class="hljs-comment">//接受回调，第一个参数是智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code &amp; error)</span></span>;<br>   <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//开启接受服务器（接受状态）</span><br>    <br>boost::asio::io_context &amp;_io_context;<br><span class="hljs-type">short</span> _port;<br>tcp::acceptor _acceptor;<br>std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Cserver实现"><a href="#Cserver实现" class="headerlink" title="Cserver实现"></a>Cserver实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port):_io_context(io_context), _port(port),<br>_acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(),port))<br>&#123;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-comment">//接受回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<span class="hljs-comment">//开启监听</span><br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<span class="hljs-comment">//插入map中</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br>    <span class="hljs-comment">//继续开启服务器</span><br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><br><span class="hljs-comment">//开启接受状态，注意，session必须是智能指针！！</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br>shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br>    <br>    <span class="hljs-comment">//接受到新的连接，此时new_session-&gt;GetSocket()是被绑定到一个会话了，然后回调，注意传参是shared_ptr</span><br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>    <br>    <span class="hljs-comment">//此函数结束后，new_session销毁，引用计数-1，但是回调函数中还在使用，所以没释放内存</span><br>&#125;<br><br><span class="hljs-comment">//map中删除这个session，引用计数-1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><h2 id="shared-ptr的初始化问题"><a href="#shared-ptr的初始化问题" class="headerlink" title="shared_ptr的初始化问题"></a>shared_ptr的初始化问题</h2><p>不能用两个智能指针管理同一块内存，如下用法是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_ptr</span>&lt;CSession&gt;(<span class="hljs-keyword">this</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>shared_ptr&lt;CSession&gt;(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数，所以要通过shared_from_this()函数返回智能指针，该智能指针和其他管理这块内存的智能指针共享引用计数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，send函数中第一次发送也要绑定shared_from_this()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//填入消息队列发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否有待发送的数据</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果有待发送的数据，将数据放入队列，等待发送</span><br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><span class="hljs-keyword">if</span> (pending) &#123;<span class="hljs-comment">//如果有待发送的数据，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果没有待发送的数据，直接发送</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this()"></a>shared_from_this()</h2><p><code>shared_from_this()</code> 方法来获取当前对象的 <code>shared_ptr</code> 实例。这样可以确保你得到的 <code>shared_ptr</code> 与最初用于创建当前对象的 <code>shared_ptr</code> 共享相同的控制块。</p><blockquote><p>注意，使用shared_from_this(),必须保证这个类对象是用make_shared方式创建的！！！</p></blockquote><h1 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h1><ul><li>服务器 (<code>Server</code>) 初始化一个新的会话 (<code>Session</code>)，并为该会话分配一个网络套接字 (<code>Socket</code>)。</li><li>接受<code>session</code>后，回调函数中开启监听(<code>async_read_some</code>),然后回调函数中继续开启接受状态（<code>StartAccept()</code>)</li><li>监听到消息，<code>读</code>回调中调用<code>send</code>（开启写），然后<code>读</code>回调中继续开启监听（<code>async_read_some</code>）</li><li>send开启写(<code>async_write</code>),<code>写</code>回调中继续<code>写</code>，直到写完</li><li>sesson有问题，直接删除即可，整个异步过程的所有函数都有此对象的引用，直到所有函数执行完毕，引用计数才会清0</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio普通的异步服务器</title>
    <link href="/2023/11/13/asio%E5%BC%82%E6%AD%A5%E5%BA%94%E7%AD%94%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/13/asio%E5%BC%82%E6%AD%A5%E5%BA%94%E7%AD%94%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要实现一个异步应答服务器</p></blockquote><blockquote><p>分文两个类</p><p>session：session类主要是处理客户端消息收发的会话类，属于服务端</p><p>server：server类为服务器接收连接的管理类，用于管理多个session，属于服务端</p></blockquote><h1 id="session类"><a href="#session类" class="headerlink" title="session类"></a>session类</h1><p><strong>成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc):_socket(ioc)&#123;<br>    &#125;<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">Socket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _socket;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读操作回调函数需要2个参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span></span>;<br>    <span class="hljs-comment">//写操作只需要1个参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    tcp::socket _socket;<br>    <span class="hljs-keyword">enum</span> &#123;max_length = <span class="hljs-number">1024</span>&#125;;<br>    <span class="hljs-type">char</span> _data[max_length];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>_data用来接收客户端传递的数据</li><li>_socket为单独处理客户端读写的socket。</li><li>handle_read和handle_write分别为读回调函数和写回调函数。</li></ul><blockquote><p>注意，读写回调函数的参数数量不同</p></blockquote><p><strong>具体实现</strong></p><h2 id="1-start函数"><a href="#1-start函数" class="headerlink" title="(1)start函数"></a>(1)<code>start函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    <span class="hljs-comment">//读操作，读完调用handle_read</span><br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在Start方法中我们调用异步读操作，监听对端发送的消息。当对端发送数据后，触发handle_read函数</p><h2 id="2-handle-read函数"><a href="#2-handle-read函数" class="headerlink" title="(2)handle_read函数"></a>(2)<code>handle_read函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><br>        <span class="hljs-comment">//读完后，异步调用写操作，返回消息给发送者，返回后，调用handle_write函数</span><br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transfered),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handle_read函数内将收到的数据发送给对端，当发送完成后触发handle_write回调函数。</p><h2 id="3-handle-write函数"><a href="#3-handle-write函数" class="headerlink" title="(3)handle_write函数"></a>(3)<code>handle_write函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br><br>        <span class="hljs-comment">//发送完后，调用异步读操作，读取发送者发送的消息，读取完后，再次调用handle_read函数，形成循环</span><br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length), std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read,<br>            <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handle_write函数内又一次监听了读事件，如果对端有数据发送过来则触发handle_read，我们再将收到的数据发回去。从而达到应答式服务的效果。</p><h1 id="server类"><a href="#server类" class="headerlink" title="server类"></a>server类</h1><p>server类是服务器接收连接的管理类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数，初始化acceptor对象</span><br>    <span class="hljs-built_in">server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port);<br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//服务器开始接受连接</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_accept</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//新连接触发后的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_accept</span><span class="hljs-params">(session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br>    boost::asio::io_context&amp; _ioc;<br>    tcp::acceptor _acceptor;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>start_accept将要接收连接的acceptor绑定到服务上，其内部就是将accpeptor对应的socket描述符绑定到epoll或iocp模型上，实现事件驱动。</li><li>handle_accept为新连接到来后触发的回调函数。</li></ul><h2 id="（a-构造函数"><a href="#（a-构造函数" class="headerlink" title="（a) 构造函数"></a>（a) <code>构造函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">server::<span class="hljs-built_in">server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port) :_ioc(ioc),<br><span class="hljs-comment">//初始化acceptor对象（协议+监听端口，表示监听主机上的所有 IPv4 地址上的指定端口）</span><br>_acceptor(ioc, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)) &#123;<br>    <span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//启动接受连接</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始化ioc和accecptor</li><li>启动接受连接</li></ul><h2 id="b-start-accept函数"><a href="#b-start-accept函数" class="headerlink" title="(b)start_accept函数"></a>(b)<code>start_accept函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//保存新连接的socket对象</span><br>    session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">session</span>(_ioc);<br><br>    <span class="hljs-comment">//异步接受连接，调用handle_accept函数</span><br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保存socket对象</li><li>异步接受连接，然后调用<code>handle_accecpt函数</code></li><li>使用异步接受连接，因为防止阻塞</li></ul><blockquote><p>注意：开启异步接受连接，不代表立马会有客户端连接过来，而是等客户端连接过来才触发async_accept函数，连接完后调用handle_accept函数！！！！</p></blockquote><h2 id="c-handle-accept函数"><a href="#c-handle-accept函数" class="headerlink" title="(c)handle_accept函数"></a>(c)<code>handle_accept函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">//开启异步监听客户端的消息，这一步不会阻塞</span><br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br>    <span class="hljs-comment">//继续接受新连接</span><br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意，start是异步读操作，不会阻塞</p></blockquote><h1 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h1><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/array.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;server.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;session.h&quot;</span></span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>asio::io_context io_context;<br><span class="hljs-function">server <span class="hljs-title">s</span><span class="hljs-params">(io_context, <span class="hljs-number">8080</span>)</span></span>;<br>io_context.<span class="hljs-built_in">run</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>io_context.run()的作用</strong></p><ol><li><strong>启动事件循环</strong>：<ul><li><code>io_context.run()</code> 调用开始一个事件处理循环，负责执行所有排队的异步操作的处理程序。</li></ul></li><li><strong>执行异步操作处理程序</strong>：<ul><li>这个循环处理由异步操作（如异步读取、写入、连接接受）触发的处理程序（handlers）。</li></ul></li><li><strong>阻塞行为</strong>：<ul><li>函数执行时是阻塞的，意味着它会持续运行，直到所有异步操作完成或 <code>io_context</code> 被停止。</li></ul></li><li><strong>确保线程安全</strong>：<ul><li>所有异步操作的处理程序都在 <code>io_context.run()</code> 提供的上下文中安全地执行，这有助于维护线程安全。</li></ul></li><li><strong>驱动程序的核心</strong>：<ul><li><code>io_context.run()</code> 是 Boost.Asio 应用程序的驱动力，没有它，异步操作不会执行。</li></ul></li><li><strong>处理所有异步事件</strong>：<ul><li>包括网络 I&#x2F;O 操作、定时器事件等，都是在 <code>io_context.run()</code> 的循环中被处理。</li></ul></li><li><strong>应用程序的持续运行</strong>：<ul><li>主线程在调用 <code>run</code> 后会在事件循环中阻塞，这保证了应用程序可以持续处理异步事件，直到不再需要处理或被显式停止。</li></ul></li></ol><h1 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h1><p>该demo示例为仿照asio官网编写的，其中存在隐患，就是当服务器即将发送数据前(调用async_write前)，此刻客户端中断，服务器此时调用async_write会触发发送回调函数，判断ec为非0进而执行delete this逻辑回收session。但要注意的是客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。在读事件回调函数中判断错误码ec为非0，进而再次执行delete操作，从而造成二次析构，这是极度危险的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个demo介绍了异步读写的相关操作，下面是对于常用函数的总结，以及对异步的理解</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="（a-开启异步读"><a href="#（a-开启异步读" class="headerlink" title="（a)开启异步读"></a><strong>（a)开启异步读</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启异步读就好，然后结束start</li></ul><h3 id="b-异步读async-read-some"><a href="#b-异步读async-read-some" class="headerlink" title="(b)异步读async_read_some"></a><strong>(b)异步读</strong>async_read_some</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    <span class="hljs-comment">//指定读到哪，读多少</span><br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>                            <span class="hljs-comment">//读完后回调，去写</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//回调函数处理异步写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transferred),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启异步读</li><li>参数（buffer，回调函数）</li><li>buffer需要数组首地址，以及读取的<strong>最大长度</strong>(并不是读完max_lengtg才会回调！！)</li><li>回调函数需要两个参数error和bytes_transferred，因为不能保证数据一次性发完</li></ul><h3 id="c-异步写async-write"><a href="#c-异步写async-write" class="headerlink" title="(c)异步写async_write"></a><strong>(c)异步写async_write</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        <span class="hljs-comment">//异步发送数据给客户端，发送完回调</span><br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transferred),<br>                                 <span class="hljs-comment">//回调，开启异步读</span><br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        <span class="hljs-comment">//异步读</span><br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>异步写函数在异步读的回调函数中</li><li>异步写发送数据给客户端，然后回调函数中调用异步读</li><li>参数（buffer，回调函数）</li><li>buffer需要首地址，以及要发送的长度</li><li>回调函数只需要一个参数，那就是error，因为write一定会发送完的</li></ul><h3 id="d-异步接受连接async-accept"><a href="#d-异步接受连接async-accept" class="headerlink" title="(d)异步接受连接async_accept"></a><strong>(d)异步接受连接async_accept</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">session</span>(_ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>                           <span class="hljs-comment">//创建新连接后，回调</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::handle_accept</span><span class="hljs-params">(session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br>    <span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//接着等待接受新连接</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个新的 <code>session</code> 对象，准备处理新连接。</li><li>使用 <code>_acceptor.async_accept</code> 异步等待新的连接请求。</li><li>当有新的连接时，<code>handle_accept</code> 会被调用。</li></ul><h2 id="e-bind绑定回调函数的参数问题"><a href="#e-bind绑定回调函数的参数问题" class="headerlink" title="(e)bind绑定回调函数的参数问题"></a>(e)bind绑定回调函数的参数问题</h2><blockquote><h3 id="Boost-Asio-异步操作的回调函数"><a href="#Boost-Asio-异步操作的回调函数" class="headerlink" title="Boost Asio 异步操作的回调函数"></a>Boost Asio 异步操作的回调函数</h3><p>Boost Asio 的异步操作，如 <code>async_read</code>、<code>async_write</code> 等，通常要求你提供一个回调函数。这个回调函数通常接受两个参数：</p><p><strong>Error Code</strong> (<code>boost::system::error_code</code>)：表明异步操作成功或失败的错误码。</p><p><strong>Bytes Transferred</strong> (<code>size_t</code>)：传输的字节数。</p></blockquote><ol><li><p><strong>绑定所有参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2)<br></code></pre></td></tr></table></figure></li><li><p><strong>绑定部分参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>, placeholders::_1)<br><span class="hljs-comment">//只有错误码会被传递给回调函数。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不绑定任何参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure><hr></li></ol><h2 id="对异步的理解"><a href="#对异步的理解" class="headerlink" title="对异步的理解"></a>对异步的理解</h2><ul><li><h3 id="异步操作的特点"><a href="#异步操作的特点" class="headerlink" title="异步操作的特点"></a>异步操作的特点</h3><ol><li><strong>事件驱动</strong>：<ul><li>异步操作是基于事件的。这意味着操作（如读取、写入、接受连接等）等待特定的网络事件发生，如数据到达或连接建立。</li></ul></li><li><strong>非阻塞行为</strong>：<ul><li>异步操作不会阻塞程序的其余部分。它们在后台“监听”或等待事件发生，而程序可以继续执行其他任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>当相应的事件发生（例如，数据到达用于读取的套接字），异步操作完成，并触发定义好的回调函数。</li><li>回调函数通常用于处理事件结果，如读取数据或发送响应。</li></ul></li></ol><h3 id="异步读取和写入的循环"><a href="#异步读取和写入的循环" class="headerlink" title="异步读取和写入的循环"></a>异步读取和写入的循环</h3><ul><li>当 <code>async_read_some</code> 或类似函数被调用时，它开始监听数据到达事件。如果没有数据到达，这个函数不会执行其回调。</li><li>在异步读取的回调函数中启动异步写入是一种常见的模式。这确保了服务器在处理完一个请求后立即准备发送响应。</li><li>完成异步写入后，通常会再次启动异步读取操作，维持与客户端的持续通信。</li></ul><h3 id="异步接受连接"><a href="#异步接受连接" class="headerlink" title="异步接受连接"></a>异步接受连接</h3><ul><li><code>async_accept</code> 类似地监听新的连接请求。如果没有新的连接尝试，它会保持在监听状态，直到有新的连接请求到达。</li><li>一旦接受到新的连接，将调用 <code>async_accept</code> 指定的回调函数来处理这个新连接。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio异步读写操作及注意事项</title>
    <link href="/2023/11/12/asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/11/12/asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍异步读写操作。</p><p>定义个session类，这个session类表示服务器处理客户端连接的管理类</p><p>其中有socket对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(std::shared_ptr&lt;asio::ip::tcp::socket&gt; socket);<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::ip::tcp::endpoint&amp; ep)</span></span>;<span class="hljs-comment">//连接端点</span><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<span class="hljs-comment">//智能指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>session类定义了一个socket成员变量，负责处理对端的连接读写，封装了Connect函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::ip::tcp::endpoint &amp;ep)</span> </span>&#123;<br>    _socket-&gt;<span class="hljs-built_in">connect</span>(ep);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步写操作"><a href="#异步写操作" class="headerlink" title="异步写操作"></a>异步写操作</h1><p>在写操作前，我们先封装一个MsgNode结构，用来管理要<code>发送和接收</code>的数据，该结构包含<code>数据域首地址</code>，<code>数据的总长度</code>，以及<code>已经处理的长度</code>(已读的长度或者已写的长度)</p><h2 id="async-write-some方式"><a href="#async-write-some方式" class="headerlink" title="async_write_some方式"></a>async_write_some方式</h2><blockquote><p>一次性不一定发送完数据</p></blockquote><h3 id="定义MsgNode类用于封装数据"><a href="#定义MsgNode类用于封装数据" class="headerlink" title="定义MsgNode类用于封装数据"></a>定义MsgNode类用于封装数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最大报文接收大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RECVSIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MsgNode</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-comment">//发送数据的构造函数</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> total_len): _total_len(total_len), _cur_len(<span class="hljs-number">0</span>)&#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>        <span class="hljs-built_in">memcpy</span>(_msg, msg, total_len);<br>    &#125;<br>    <span class="hljs-comment">//接受数据的构造函数</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>    &#125;<br>    ~<span class="hljs-built_in">MsgNode</span>()&#123;<br>        <span class="hljs-keyword">delete</span>[]_msg;<br>    &#125;<br>    <span class="hljs-comment">//消息首地址</span><br>    <span class="hljs-type">char</span>* _msg;<br>    <span class="hljs-comment">//总长度</span><br>    <span class="hljs-type">int</span> _total_len;<br>    <span class="hljs-comment">//当前长度</span><br>    <span class="hljs-type">int</span> _cur_len;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="为Session添加异步写操作"><a href="#为Session添加异步写操作" class="headerlink" title="为Session添加异步写操作"></a>为Session添加异步写操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">    std::shared_ptr&lt;MsgNode&gt;)</span></span>;<br>    <span class="hljs-comment">//写函数（传入需要写的数据）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;MsgNode&gt; _send_node;<span class="hljs-comment">//定义需要发送的数据</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现void-WriteToSocketErr函数"><a href="#实现void-WriteToSocketErr函数" class="headerlink" title="实现void WriteToSocketErr函数"></a>实现<code>void WriteToSocketErr函数</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//构造发送数据</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>async_wirte_some函数第一个参数是buffer，第二个参数是回调函数）</p></blockquote><h3 id="实现WriteCallBackErr函数"><a href="#实现WriteCallBackErr函数" class="headerlink" title="实现WriteCallBackErr函数"></a>实现<code>WriteCallBackErr</code>函数</h3><p>因为WriteCallBackErr函数为三个参数且为成员函数，而<strong>async_write_some需要的回调函数为两个参数</strong>，所以我们通过bind将三个参数转换为两个参数的普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, </span></span><br><span class="hljs-params"><span class="hljs-function">    std::<span class="hljs-type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len <br>        &lt; msg_node-&gt;_total_len) &#123;<br>        _send_node-&gt;_cur_len += bytes_transferred;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,<br>            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单凭这两个不可以投入使用，具体原因是</p></blockquote><p>我们可以通过队列保证应用层的发送顺序。我们在Session中定义一个发送队列，然后重新定义正确的异步发送函数和回调处理</p><h3 id="定义queue写入消息（重点）"><a href="#定义queue写入消息（重点）" class="headerlink" title="定义queue写入消息（重点）"></a>定义queue写入消息（重点）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;<span class="hljs-comment">//用来缓存要发送的消息节点</span><br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    <span class="hljs-type">bool</span> _send_pending;<span class="hljs-comment">//该变量为true表示一个节点还未发送完。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现queue异步写入功能"><a href="#实现queue异步写入功能" class="headerlink" title="实现queue异步写入功能"></a><strong>实现queue异步写入功能</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf), std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标志正在发送消息...</span><br>&#125;<br><br><span class="hljs-comment">//回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec,  std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//取出队首元素即当前未发送完数据</span><br>    <span class="hljs-keyword">auto</span> &amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>    send_data-&gt;_cur_len += bytes_transferred;<br>    <br>    <span class="hljs-comment">//数据未发送完， 则继续发送（相当于递归）</span><br>    <span class="hljs-keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len-send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>    _send_pending=<span class="hljs-literal">false</span>;<span class="hljs-comment">//消息发送完毕</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="async-send方式"><a href="#async-send方式" class="headerlink" title="async_send方式"></a>async_send方式</h2><blockquote><p>一次性发送完数据</p></blockquote><p>其内部的实现原理就是帮我们不断的调用async_write_some直到完成发送，<code>async_send不能和async_write_some混合使用</code>，我们基于async_send封装另外一个发送函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不能与async_write_some混合使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果发送完，此时一定发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步读操作"><a href="#异步读操作" class="headerlink" title="异步读操作"></a>异步读操作</h1><h2 id="async-read-some方式"><a href="#async-read-some方式" class="headerlink" title="async_read_some方式"></a>async_read_some方式</h2><blockquote><p>触发的回调函数获取的读数据的长度可能会小于要求读取的总长度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadFromSocket</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    std::shared_ptr&lt;MsgNode&gt; _recv_node;<br>    <span class="hljs-type">bool</span> _recv_pending;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>recv_node用来缓存接收的数据，_recv_pending为true表示节点正在接收数据，还未接受完。</code></p><p><strong>具体实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不考虑粘包情况， 先用固定的字节接收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    <br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//没读完继续读</span><br>    <span class="hljs-keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;<br>        _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len,<br>            _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="async-receive方式"><a href="#async-receive方式" class="headerlink" title="async_receive方式"></a>async_receive方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，async_read_some和async_receive不能混合使用，否则会出现逻辑问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>（a）对于异步写操作，流程如下</p><ol><li>设置队列</li><li>将需要写的放入队列里</li><li>如果此时在写，则return</li><li>否则开启写操作，绑定回调函数,然后标志”正在写“</li><li>回调函数实现递归逻辑，按照顺序完成队列中所有的写操作</li></ol><p>（b）对于异步读操作，流程如下</p><ol><li>如果此时在读，则return</li><li>否则开启读操作，绑定回调函数，然后标志”正在读“</li><li>回调函数实现递归逻辑，读完为止</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>对于写操作，尽量使用async_send<br>对于读操作，尽量使用async_read_some</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//async_write_some</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造发送数据</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">// 异步发送数据</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br><br><span class="hljs-comment">//async_send</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造发送数据</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">// 异步发送数据</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <span class="hljs-comment">//注意，这个一定是直接发完了，所以不需要指定长度******</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//async_read_some</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    <span class="hljs-comment">// 异步读取数据</span><br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//async_receive</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    <span class="hljs-comment">// 异步读取数据必须指定大小，表示接受多少数据</span><br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio socket同步读写</title>
    <link href="/2023/11/12/asio%20socket%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99/"/>
    <url>/2023/11/12/asio%20socket%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="同步写write-some"><a href="#同步写write-some" class="headerlink" title="同步写write_some"></a>同步写write_some</h1><p>write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wirte_to_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>std::string buf = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::<span class="hljs-type">size_t</span> total_bytes_written = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (total_bytes_written != buf.<span class="hljs-built_in">length</span>()) &#123;<br>total_bytes_written += sock.<span class="hljs-built_in">write_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>() + total_bytes_written, buf.<span class="hljs-built_in">length</span>() - total_bytes_written)<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步写send"><a href="#同步写send" class="headerlink" title="同步写send"></a>同步写send</h1><p>send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_send</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br>std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-type">int</span> send_length = sock.<span class="hljs-built_in">send</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步写write"><a href="#同步写write" class="headerlink" title="同步写write"></a>同步写write</h1><p>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_wirte</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br>std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-type">int</span> send_length = asio::<span class="hljs-built_in">write</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读read-some"><a href="#同步读read-some" class="headerlink" title="同步读read_some"></a>同步读read_some</h1><p>同步读和同步写类似，提供了读取指定字节数的接口read_some</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">read_from_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MESSAGE_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buf[MESSAGE_SIZE];<br>std::<span class="hljs-type">size_t</span> total_bytes_read = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//如果没有读到7个字节，那么一直阻塞</span><br><span class="hljs-keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;<br>total_bytes_read += sock.<span class="hljs-built_in">read_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf + total_bytes_read,<br>MESSAGE_SIZE - total_bytes_read));<br>&#125;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buf, total_bytes_read);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read_some</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-comment">//读取数据</span><br><span class="hljs-built_in">read_from_socket</span>(sock);<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读receive"><a href="#同步读receive" class="headerlink" title="同步读receive"></a>同步读receive</h1><p>可以一次性同步读取对方发送的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_receive</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = sock.<span class="hljs-built_in">receive</span>(asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br><span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读read"><a href="#同步读read" class="headerlink" title="同步读read"></a>同步读read</h1><p>可以一次性同步接收对方发送的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = asio::<span class="hljs-built_in">read</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br><span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读取直到指定字符"><a href="#读取直到指定字符" class="headerlink" title="读取直到指定字符"></a>读取直到指定字符</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string  <span class="hljs-title">read_data_by_until</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>    asio::streambuf buf;<br>    <span class="hljs-comment">// Synchronously read data from the socket until</span><br>    <span class="hljs-comment">// &#x27;\n&#x27; symbol is encountered.  </span><br>    asio::<span class="hljs-built_in">read_until</span>(sock, buf, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    std::string message;<br>    <span class="hljs-comment">// Because buffer &#x27;buf&#x27; may contain some other data</span><br>    <span class="hljs-comment">// after &#x27;\n&#x27; symbol, we have to parse the buffer and</span><br>    <span class="hljs-comment">// extract only symbols before the delimiter. </span><br>    <span class="hljs-function">std::istream <span class="hljs-title">input_stream</span><span class="hljs-params">(&amp;buf)</span></span>;<br>    std::<span class="hljs-built_in">getline</span>(input_stream, message);<br>    <span class="hljs-keyword">return</span> message;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限制+修改单调队列（Ropeway）</title>
    <link href="/2023/11/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%B8%A6%E4%BF%AE%E6%94%B9/"/>
    <url>/2023/11/11/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%B8%A6%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/104128/problem/B">2022ICPC 南京B.Ropeway</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>n+2个点编号0到n+1，每个点有点权，要求选若干个点使得总点权最小，其中编号为0 和n + 1的点必须选且点权为0 ，同时满足任意两个被选的点之间的距离不超过k 。</p><p>此外还会给一个01串，表示1到n这些点是否为必选的点，1为必选，0为可选可不选</p><p>现在会给m个询问，每个询问为如果将<code>编号为x</code>的点权修改为v,答案是多少？每次询问互不影响</p><p>n&lt;&#x3D;5e5,m,k&lt;&#x3D;3e3</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>一眼单调队列，但是和普通单调队列不同，有些位置必须选，而且0，n+1都有一个点权为0的点，普通的单调队列是：0位置点权为0，而且每个点可选可不选</li><li>位置0和n+1容易处理，只需要设pre[i]为从前往后扫描，而且选i的最小花费，suf[i]表示从后往前扫描，而且选i的最小花费</li><li>有些位置必须选，可以这样思考，处理pre[i]的时候，枚举j的位置，j的区间为[i-m,i-1],表示上一个选的什么，但是如果i的前面有必须选的，那么j的范围就要改变，变成[k,i-1],k表示上一个必须选的位置，具体实现见代码</li><li>现在考虑修改，如果将位置x的值修改，那么会影响到pre和suf数组，会影响多少呢？对于pre来说，x到n全部被影响到，suf同理。</li><li>考虑答案是如何产生的，任选一个长度为k的区间，遍历这个区间所有的点，答案为min(pre[i]+suf[i]-a[i])</li><li>所以修改一个位置，保证suf不动，那么答案可以在[i,i+k]中产生，此时需要修改pre数组</li><li>但是6无法保证i+k&lt;&#x3D;n，但好像也没有关系，因为n+1这个点必选，那么从答案从n+1更新即可</li></ol><blockquote><p>第5点十分重要！！！</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> q[N],hh,tt;<span class="hljs-comment">//单调队列，存数组下标 </span><br><br><span class="hljs-type">int</span> n,k;<br>ll a[N];<span class="hljs-comment">//权值 </span><br><span class="hljs-type">char</span> s[N];<span class="hljs-comment">//s数组是01串，1表示必须选</span><br><br><span class="hljs-comment">//pre和suf表示分别从前后遍历，结尾为i的最小花费</span><br>ll pre[N],suf[N],tem[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//初始化队头队尾</span><br>hh=<span class="hljs-number">1</span>,tt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">(ll f[])</span> </span>&#123;<br><span class="hljs-built_in">init</span>();<br>q[++tt]=<span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n+<span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k) &#123;<br>hh++;<br>&#125;<br>f[i]=f[q[hh]]+a[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;f[q[tt]]&gt;=f[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//处理presuf数组</span><br><span class="hljs-built_in">get</span>(pre);<br><span class="hljs-built_in">reverse</span>(a,a+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">reverse</span>(s,s+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">get</span>(suf);<br><span class="hljs-built_in">reverse</span>(suf,suf+n+<span class="hljs-number">2</span>);<span class="hljs-comment">//反转suf数组</span><br><span class="hljs-comment">//复原</span><br><span class="hljs-built_in">reverse</span>(a,a+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">reverse</span>(s,s+n+<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br><span class="hljs-comment">//利用[pos+1,pos+k]更新答案</span><br><span class="hljs-built_in">init</span>();<br>ll ans=<span class="hljs-number">1e18</span>;<br><br><span class="hljs-comment">//对[pos-k,pos-1]做一遍单调队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,pos-k); i&lt;pos; i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k)hh++;<br>tem[i]=pre[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;pre[q[tt]]&gt;=pre[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>&#125;<br> <br><span class="hljs-comment">//更新答案[pos,pos+k-1] </span><br>    <br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时suf数组在pos位置是不准确的，但是为什么还可以用来更新答案呢？？</span><br><span class="hljs-comment">因为suf数组表示以pos为结尾，选上pos但是不计算pos的答案，也就是说，pos位置的数无论是多少，都不影响suf</span><br><span class="hljs-comment">那么此时suf值在pos位置就是准确的。</span><br><span class="hljs-comment">此时，修改pos位置，影响到suf的区间[0,pos-1]!!!!!</span><br><span class="hljs-comment">    */</span><br>    <br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos; i&lt;=<span class="hljs-built_in">min</span>(n+<span class="hljs-number">1</span>,pos+k<span class="hljs-number">-1</span>); i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k)hh++;<br>tem[i]=tem[q[hh]]+a[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;tem[q[tt]]&gt;=tem[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>ans=<span class="hljs-built_in">min</span>(ans,tem[i]+suf[i]);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">init</span>();<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>a[<span class="hljs-number">0</span>]=a[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>cin&gt;&gt;s+<span class="hljs-number">1</span>;<br>s[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;1&#x27;</span>,s[n+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;1&#x27;</span>;<span class="hljs-comment">//必须选</span><br><span class="hljs-built_in">get</span>();<span class="hljs-comment">//处理pre，suf数组</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>suf[i]-=a[i];<br>        <br>        <br><span class="hljs-comment">/*需要做这个处理</span><br><span class="hljs-comment">suf数组表示选第i个，但是第i个权值并没有算进去</span><br><span class="hljs-comment">这样ask询问好算，而且此处理后，pos修改只会影响[0,pos-1]的suf值，具体见ask处</span><br><span class="hljs-comment">*/</span><br>        <br>        <br>&#125;<br><br><span class="hljs-type">int</span> m;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--) &#123;<br><span class="hljs-type">int</span> pos,val;<br>cin&gt;&gt;pos&gt;&gt;val;<br><span class="hljs-type">int</span> back=a[pos];<br>a[pos]=val;<br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(pos)&lt;&lt;endl;<span class="hljs-comment">//计算答案</span><br>a[pos]=back;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>a.对于本题目的答案ans</p><blockquote><ol><li>对于任何一个必须选的点x，ans&#x3D;pre[x]+suf[x]-a[x]</li><li>特殊的，ans&#x3D;suf[0]+pre[n+1]</li><li>对于任何一个非必选的x，在一个长度为k的区间内，假设区间内的所有位置都非必选，则ans&#x3D;min(pre[i]+suf[i]-a[i])</li><li>第3条，假设区间内存在必须选的位置，ans&#x3D;min(pre[i]+suf[i]-a[i])&#x3D;pre[pos]+suf[pos]-a[pos]，(pos是必须要选的位置)</li></ol></blockquote><p>b.代码中，如果x+k-1&gt;n+1，也没事，因为答案会在n+1处取得</p><p>c.     注意本题目的suf数组的具体含义（见代码注释），因为这样处理，在ask询问中比较容易做，而且改变了<code>a[pos]的修改</code>对suf的影响！！！。</p>]]></content>
    
    
    <categories>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有限制的背包（No Bug No Game）</title>
    <link href="/2023/11/11/%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%83%8C%E5%8C%85/"/>
    <url>/2023/11/11/%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/104090/problem/C">2022 ICPC杭州 C. No Bug No Game</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有n个物品，背包容量为k，给出n组物品，每一组物品有pi个，每个物品的体积从1到pi递增，取的体积不同，获得的价值也不同，体积从1到pi(连续），价值从w1到wj   （j&#x3D;pi）</p><p>如果当前背包容量足够，则必须取完整的重量</p><p>否则必须可以取部分体积来填满剩余的背包容量，问能取得的最大价值是多少</p><p>数据范围：<code>n，k&lt;=3000,  pi&lt;=10 , wj&lt;=1e5</code></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>对于每一组物品，如果此时剩余容量大于pi，则必须取最后一个，否则必须取相应体积的物品，此时容量为0</li><li>而且，体积小的物体可能有更大的价值</li><li>显然，取的顺序有所谓，前面组必须取最后，最后一组必须取中间的某个</li><li>我们无法贪心的排序，但是可以这样想，只有一组取中间，其他组取最后，可以dp</li><li>设dp[i][j][0\1]表示前i组，且此时恰好装了j体积的最大价值，0和1表示，恰好装到j时，前i组有没有取到中间的某个物品</li></ol><p>我们发现，这样设转移方程是可以转移的，因为可以表示所有状态，第i组刚结束，并且恰好取到了j，还知道此时是否可以取中间</p><p>转移方程见代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">10</span>;<br><br>ll dp[N][N][<span class="hljs-number">2</span>];<br>ll w[N][<span class="hljs-number">15</span>];<br>ll p[N];<br>ll n,k;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br>ll sum0=<span class="hljs-number">0</span>,sum1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;p[i];<br>sum0+=p[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=p[i]; j++) &#123;<br>cin&gt;&gt;w[i][j]; <br>&#125;<br>sum1+=w[i][p[i]];<br>&#125;<br><br><span class="hljs-keyword">if</span>(sum0&lt;=k)&#123;<br>cout&lt;&lt;sum1&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=k; j++) &#123;<br>dp[i][j][<span class="hljs-number">0</span>]=dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-number">-1e18</span>;<br>&#125;<br>&#125;<br><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//前0个物品,恰好选0体积，而且没有选中间某个物品,最大价值为0</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=k; j++) &#123;<br><span class="hljs-comment">//可以选择不选当前组</span><br>dp[i][j][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>];<br>dp[i][j][<span class="hljs-number">1</span>]=dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">1</span>];<br><br><br><span class="hljs-comment">//选当前组最后一个物品</span><br><span class="hljs-comment">//更新dp[i][j][0],dp[i][j][1]</span><br><span class="hljs-keyword">if</span>(j&gt;=p[i]) &#123;<br>dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][j-p[i]][<span class="hljs-number">0</span>]+w[i][p[i]]);<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][j-p[i]][<span class="hljs-number">1</span>]+w[i][p[i]]);<br>&#125;<br><br><span class="hljs-comment">//选当前组的中间物品</span><br><span class="hljs-comment">//更新dp[i][j][1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>; t&lt;p[i]; t++) &#123;<br><span class="hljs-keyword">if</span>(j&gt;=t) &#123;<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][j-t][<span class="hljs-number">0</span>]+w[i][t]);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">千万不可以这样写！！！ </span><br><span class="hljs-comment">ans=max(ans,max(dp[i][j][0],dp[i][j][1]));</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//cout&lt;&lt;ans&lt;&lt;endl; </span><br>cout&lt;&lt;<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,<span class="hljs-built_in">max</span>(dp[n][k][<span class="hljs-number">0</span>],dp[n][k][<span class="hljs-number">1</span>]));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">千万不可以这样写！！！ </span><br><span class="hljs-comment">ans=max(ans,max(dp[i][j][0],dp[i][j][1]));</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 为什么不可以这样做？？</li></ul><p>设想这样一个情景，假设有一组，其中物品价值是 1， 1，INF，1，1</p><p>此时，dp[i][j][1]可以是前i组，容量恰好选完j，且此时选到了中间的INF，此时价值是正无穷，可是，如果实际情况是永远也不可能选到INF，这样更新会导致答案错误。</p><p>下面证明实际情况存在可能选不到INF：</p><ol><li>前i-1层遍历完，并且仅<code>dp[i-1][j][0]</code>有值，<code>dp[i-1][[j][1]</code>为-INF，实际上，不需要考虑<code>dp[i-1][j][1]</code></li><li>遍历第i层，<code>dp[i][j][1]</code>用<code>dp[i-1][j’][0]</code>更新，此时遇到了INF,被更新为INF，导致答案错误</li></ol>]]></content>
    
    
    <categories>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio socket的创建和连接</title>
    <link href="/2023/11/11/asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/11/asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="TCP和IP协议"><a href="#TCP和IP协议" class="headerlink" title="TCP和IP协议"></a>TCP和IP协议</h3><ol><li><strong>TCP（传输控制协议）</strong>：TCP是一种网络通信协议，它在互联网协议套件（TCP&#x2F;IP）中负责确保数据的可靠传输。TCP提供了一种可靠的、面向连接的通信方式。这意味着在数据开始传输之前，两个网络设备（比如计算机）之间必须首先建立一个连接。TCP还负责确保数据的完整性和顺序正确。</li><li><strong>IP协议（互联网协议）</strong>：IP协议是另一种关键的网络通信协议，负责在网络上路由和传输数据包。IP有两个主要版本：IPv4和IPv6。IPv4是目前最广泛使用的版本，但由于地址空间限制，IPv6正在逐渐被采用。</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul><li><strong>Socket是什么</strong>：Socket是网络通信的端点。您可以将其想象为电话插座，它是网络上两个程序（运行在不同计算机上或同一计算机上的不同进程）进行数据交换的接口。</li><li><strong>Socket的用途</strong>：Socket使得程序可以读写网络上的数据。在创建Socket时，您需要指定使用的协议（如TCP）。一旦建立了Socket连接，数据就可以通过这个连接在网络上进行传输。</li></ul><h3 id="TCP连接和IP协议的关系"><a href="#TCP连接和IP协议的关系" class="headerlink" title="TCP连接和IP协议的关系"></a>TCP连接和IP协议的关系</h3><ul><li>在进行TCP网络通信时，通常会使用IP协议（无论是IPv4还是IPv6）。这是因为TCP负责在两个端点之间建立一个稳定的连接，并确保数据可靠地传输，而IP协议负责将数据包路由到正确的目的地。</li><li>当您在编程中创建一个TCP Socket时，您需要指定使用的IP协议版本。例如，在Boost.Asio中，您可以创建一个使用IPv4的TCP Socket（<code>asio::ip::tcp::socket</code>），这意味着它将使用IPv4协议来路由数据。</li></ul><h1 id="网络编程基本流程"><a href="#网络编程基本流程" class="headerlink" title="网络编程基本流程"></a>网络编程基本流程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>1）socket——创建socket对象。</p><p>2）bind——绑定本机ip+port。</p><p>3）listen——监听来电，若在监听到来电，则建立起连接。</p><p>4）accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。</p><p>5）read、write——就是收发消息了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>1）socket——创建socket对象。</p><p>2）connect——根据服务端ip+port，发起连接请求。</p><p>3）write、read——建立连接后，就可发收消息了。</p><h1 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h1><h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><p><code>客户端</code>可以通过对端的ip和端口构造一个endpoint，用这个endpoint和<code>服务端</code>通信。</p><p>步骤如下：</p><ol><li>设置服务器<code>IP地址</code>（string）和 <code>PORT</code>（unsigned short）</li><li>定义<code> boost::system::error_code</code>状态码，用于存储解析<code> IP</code>时候可能发生的错误</li><li>解析IP地址,获取<code>asio::ip::address</code>对象</li><li>如果解析失败，反悔错误码</li><li>解析成功，根据<code>ip::address</code>和<code>PORT</code>建立TCP连接，获取<code>asio::ip::tcp::endpoint</code>对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义client_end_point函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">client_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 设置服务器IP地址和端口号</span><br>    <span class="hljs-comment">// 使用本地回环地址127.0.0.1进行测试</span><br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;           <br><br>    <span class="hljs-comment">// Step 2: 用于存储解析IP地址时可能发生的错误的变量</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 3: 解析IP地址</span><br>    asio::ip::address ip_address = asio::ip::address::<span class="hljs-built_in">from_string</span>(raw_ip_address, ec);<br><br>    <span class="hljs-comment">// Step 4: 检查IP地址是否正确解析</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果解析出错，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to parse the IP address. Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Step 5: 使用解析好的IP地址和端口号创建TCP端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 6: 输出端点信息，验证创建是否成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Endpoint created: IP Address = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">address</span>() <br>              &lt;&lt; <span class="hljs-string">&quot;, Port = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">port</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用client_end_point函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">client_end_point</span>();<br><br>    <span class="hljs-comment">// 检查client_end_point函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during endpoint creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 端点创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Endpoint creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p>步骤如下：</p><ol><li>定义端口号（unsigned short）</li><li>根据本机IPv6<code>asio::ip::address_v6::any()</code>协议创建<code>asio::ip::address</code>对象</li><li>根据<code>ip::address</code>和<code>Port</code>创建<code>asio::ip::tcp::endpoint</code>对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义server_end_point函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">server_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-comment">// 这里我们假设服务器应用程序已经获取了端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个特殊的asio::ip::address对象</span><br>    <span class="hljs-comment">// 它指定了主机上所有可用的IP地址</span><br>    <span class="hljs-comment">// 注意，这里我们假设服务器工作在IPv6协议上</span><br>    asio::ip::address ip_address = asio::ip::address_v6::<span class="hljs-built_in">any</span>();<br><br>    <span class="hljs-comment">// Step 3: 使用指定的IP地址和端口号创建TCP端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 端点创建完成，可以用来指定服务器应用程序希望监听传入连接的IP地址和端口号</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server endpoint created: IP Address = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">address</span>() <br>              &lt;&lt; <span class="hljs-string">&quot;, Port = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">port</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用server_end_point函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">server_end_point</span>();<br><br>    <span class="hljs-comment">// 检查server_end_point函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during server endpoint creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 服务器端点创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server endpoint creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h1><h2 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h2><p>步骤：</p><ol><li>创建<code>asio::io_context</code>对象</li><li>创建一个代表TCP协议的<code>asio::ip::tcp</code>对象protocol</li><li>创建TCP套接字对象<code>asio::ip::tcp::socket</code>,将它与<code>asio::io_context</code>对象关联</li><li>定义一个<code>boost::system::error_code</code>变量</li><li>打开套接字（使用TCP协议protocol，错误码error_code)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义create_tcp_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 创建asio::io_context对象</span><br>    <span class="hljs-comment">// io_service（或io_context）是Boost.Asio中的核心类，用于处理所有I/O操作</span><br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// Step 2: 创建一个代表TCP协议的asio::ip::tcp对象</span><br>    <span class="hljs-comment">// 这里我们使用IPv4作为底层协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3: 实例化一个活动的TCP套接字对象</span><br>    <span class="hljs-comment">// 套接字用于网络通信，这里我们将它与io_service对象关联</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储打开套接字时可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 打开套接字</span><br>    <span class="hljs-comment">// 使用之前定义的TCP协议（IPv4）打开套接字</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查套接字是否成功打开</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果打开失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用create_tcp_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br><br>    <span class="hljs-comment">// 检查create_tcp_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during socket creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 套接字创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Socket creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h2><p>需要生成一个acceptor的socket，用来接收新的连接。</p><p>步骤：</p><ol><li>创建<code>asio::io_context</code>对象</li><li>创建一个代表TCP协议的<code>asio::ip::tcp</code>对象protocol</li><li>实例化一个接收器（Acceptor） 套接字对象<code>asio::ip::tcp::acceptor</code>,参数是ios</li><li>定义一个<code>boost::system::error_code</code>变量</li><li>打开套接字（使用TCP协议protocol，错误码error_code)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义create_acceptor_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 创建asio::io_context对象</span><br>    <span class="hljs-comment">// io_service（或io_context）是Boost.Asio中的核心类，用于处理所有I/O操作</span><br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// Step 2: 创建一个代表TCP协议的asio::ip::tcp对象</span><br>    <span class="hljs-comment">// 这里我们使用IPv6作为底层协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v6</span>();<br><br>    <span class="hljs-comment">// Step 3: 实例化一个接收器（Acceptor）套接字对象</span><br>    <span class="hljs-comment">// 接收器套接字用于监听和接受传入的TCP连接</span><br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储打开接收器套接字时可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 打开接收器套接字</span><br>    <span class="hljs-comment">// 使用之前定义的TCP协议（IPv6）打开接收器</span><br>    acceptor.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查接收器套接字是否成功打开</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果打开失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to open the acceptor socket! Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用create_acceptor_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_acceptor_socket</span>();<br><br>    <span class="hljs-comment">// 检查create_acceptor_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during acceptor socket creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收器套接字创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Acceptor socket creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h1><p>acceptor类型的socket，服务器要将其绑定到指定的端点,所有连接这个端点的连接都可以被接收到</p><p>步骤：</p><ol><li>设置端口号port</li><li>创建一个端点 <code>asio::ip::tcp::endpoint</code>,利用IP，prot</li><li>创建并打开一个接收器套接字<code>asio::ip::tcp::acceptor</code>，根据<code>ios</code>和<code>协议</code></li><li>定义一个error_code变量</li><li>将接收器套接字（accecptor）绑定到端点（endpoint）， <code>acceptor.bind(ep, ec)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义bind_acceptor_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-comment">// 这里我们假设服务器应用程序已经获取了端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个端点</span><br>    <span class="hljs-comment">// 使用asio::ip::address_v4::any()表示服务器将接受发送到本机任何IPv4地址的连接</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(), port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 3: 创建并打开一个接收器套接字</span><br>    asio::io_context ios;<br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储绑定操作过程中可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 将接收器套接字绑定到端点</span><br>    acceptor.<span class="hljs-built_in">bind</span>(ep, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查接收器套接字是否成功绑定</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果绑定失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to bind the acceptor socket. Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用bind_acceptor_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">bind_acceptor_socket</span>();<br><br>    <span class="hljs-comment">// 检查bind_acceptor_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during acceptor socket binding. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收器套接字绑定成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Acceptor socket binding successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="客户端连接到指定的端点"><a href="#客户端连接到指定的端点" class="headerlink" title="客户端连接到指定的端点"></a>客户端连接到指定的端点</h1><p>步骤：</p><ol><li>获取目标服务器的IP地址和端口号</li><li>创建一个指向目标应用程序的端点endpoint，需要ip和端口号</li><li>创建并打开一个套接字socket，需要ios和IP协议</li><li>socket连接endpoint</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义connect_to_end函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect_to_end</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取目标服务器的IP地址和端口号</span><br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Step 2: 创建一个指向目标服务器应用程序的端点</span><br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;<br><br>        asio::io_context ios;<br><br>        <span class="hljs-comment">// Step 3: 创建并打开一个套接字</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>        <span class="hljs-comment">// Step 4: 连接套接字</span><br>        sock.<span class="hljs-built_in">connect</span>(ep);<br><br>        <span class="hljs-comment">// 连接成功，套接字现在可以用于发送和接收数据</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occurred! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>                  &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用connect_to_end函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">connect_to_end</span>();<br><br>    <span class="hljs-comment">// 检查connect_to_end函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during connection. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 连接成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Connection successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务端接收连接"><a href="#服务端接收连接" class="headerlink" title="服务端接收连接"></a>服务端接收连接</h1><p>步骤：</p><ol><li>设置端口号</li><li>创建端点endpoint，需要IP地址和Port</li><li>创建<code>接收器套接字</code>，需要ios和IP协议</li><li>接收器套接字<code>accecptor</code>绑定指定<code>endpoint</code></li><li>开始监听传入的连接请求 <code>acceptor.listen(BACKLOG_SIZE)</code></li><li>创建一个活动套接字sock,需要ios</li><li>接收连接请求，将活动套接字连接到客户端<code>acceptor.accept(sock)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义accept_new_connection函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept_new_connection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BACKLOG_SIZE = <span class="hljs-number">30</span>; <span class="hljs-comment">// 等待连接请求的队列大小</span><br><br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个服务器端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(), port_num)</span></span>;<br><br>    asio::io_context ios;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Step 3: 实例化并打开一个接收器套接字</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>        <span class="hljs-comment">// Step 4: 将接收器套接字绑定到服务器端点</span><br>        acceptor.<span class="hljs-built_in">bind</span>(ep);<br><br>        <span class="hljs-comment">// Step 5: 开始监听传入的连接请求</span><br>        acceptor.<span class="hljs-built_in">listen</span>(BACKLOG_SIZE);<br><br>        <span class="hljs-comment">// Step 6: 创建一个活动套接字</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>        <span class="hljs-comment">// Step 7: 接收连接请求，将活动套接字连接到客户端</span><br>        acceptor.<span class="hljs-built_in">accept</span>(sock);<br><br>        <span class="hljs-comment">// 连接成功，套接字现在可以用于与客户端进行数据交换</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occurred! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>                  &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用accept_new_connection函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">accept_new_connection</span>();<br><br>    <span class="hljs-comment">// 检查accept_new_connection函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during accepting connection. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收连接成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Accepting connection successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="概念和疑问"><a href="#概念和疑问" class="headerlink" title="概念和疑问"></a>概念和疑问</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p><input disabled="" type="checkbox"> 端点，套接字，接收器套接字对于客户端和服务端的作用</p></li><li><p><strong>客户端端点创建</strong> (<code>client_end_point</code>):</p><ul><li>设置目标服务器的IP和端口，创建客户端端点以连接服务器。</li></ul></li><li><p><strong>服务器端点创建</strong> (<code>server_end_point</code>):</p><ul><li>设置端口号，创建服务器端点以便监听来自客户端的连接。</li></ul></li><li><p><strong>创建TCP套接字</strong> (<code>create_tcp_socket</code>):</p><ul><li>创建套接字，用于客户端的连接或服务器的通信。</li></ul></li><li><p><strong>创建接收器套接字</strong> (<code>create_acceptor_socket</code>):</p><ul><li>创建接收器套接字，用于服务器端接受客户端的连接请求。</li></ul></li><li><p><strong>绑定接收器套接字</strong> (<code>bind_acceptor_socket</code>):</p><ul><li>将接收器套接字绑定到一个特定的端点，用于监听来自该端点的连接请求。</li></ul></li><li><p><strong>连接到端点</strong> (<code>connect_to_end</code>):</p><ul><li>客户端使用套接字连接到指定的服务器端点。</li></ul></li><li><p><strong>接收新连接</strong> (<code>accept_new_connection</code>):</p><ul><li>服务端监听并接受来自客户端的新连接请求。<strong>创建一个新的套接字与客户端进行通信</strong>。（注意，创建新的套接字通信）</li></ul></li><li><p><input disabled="" type="checkbox"> 端点，套接字，接收器套接字代码</p></li></ul><table><thead><tr><th>组件</th><th>功能</th><th>参数</th><th>示例代码</th><th>应用场景</th></tr></thead><tbody><tr><td>boost::system::error_code</td><td>错误代码对象</td><td>-</td><td>boost::system::error_code ec;</td><td>用于处理网络操作中的错误，如套接字打开或绑定失败。</td></tr><tr><td>asio::ip::address</td><td>表示一个IP地址</td><td>1.IP地址字符串<br />2.错误代码对象</td><td>asio::ip::address ip_address &#x3D; asio::ip::address::from_string(“127.0.0.1”, ec);</td><td>定义网络通信的IP地址，用于创建端点。</td></tr><tr><td>asio::ip::tcp::endpoint</td><td>表示一个TCP网络端点</td><td>1.ip_address<br />2.port_num</td><td>asio::ip::tcp::endpoint ep(ip_address, port_num);</td><td>用于定义TCP连接的目标地址和端口，客户端和服务器都会使用。</td></tr><tr><td>asio::io_context</td><td>提供I&#x2F;O功能</td><td>-</td><td>asio::io_context ios;</td><td>用于管理异步I&#x2F;O操作，是Boost.Asio程序的核心。</td></tr><tr><td>asio::ip::tcp::socket</td><td>TCP套接字，用于网络通信</td><td>1.<code>io_context</code>对象<br />2.协议</td><td>asio::ip::tcp::socket sock(ios);</td><td>用于客户端发起连接和服务器与客户端之间的数据交换。</td></tr><tr><td>asio::ip::tcp::acceptor</td><td>接收器套接字，用于接受连接</td><td>1.<code>io_context</code>对象<br />2.协议</td><td>asio::ip::tcp::acceptor acceptor(ios, protocol);</td><td>服务器端使用，用于监听和接受来自客户端的连接。</td></tr></tbody></table><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="1-关于地址解析"><a href="#1-关于地址解析" class="headerlink" title="1. 关于地址解析"></a>1. 关于地址解析</h4><p><strong>问题</strong>：根据string类型的ip地址解析，创建address对象，如果这个ip不是本机ip，是别的服务器的ip，就有可能解析不成功。如果是本机ip，一定可以成功。</p><p><strong>答案</strong>：当你使用一个字符串类型的IP地址来创建<code>asio::ip::address</code>对象时，如果IP地址格式正确，它应该能够成功解析，无论这个IP是否属于本机。解析失败通常是由于格式错误或不支持的地址类型。</p><h4 id="2-创建端点endpoint对象需要address对象和端口"><a href="#2-创建端点endpoint对象需要address对象和端口" class="headerlink" title="2. 创建端点endpoint对象需要address对象和端口"></a>2. 创建端点endpoint对象需要address对象和端口</h4><p><strong>问题</strong>：创建端点endpoint对象需要address对象和端口。</p><p><strong>答案</strong>：正确，<code>asio::ip::tcp::endpoint</code>对象的创建需要一个IP地址（<code>asio::ip::address</code>对象）和一个端口号。</p><h4 id="3-关于创建和打开socket"><a href="#3-关于创建和打开socket" class="headerlink" title="3. 关于创建和打开socket"></a>3. 关于创建和打开<code>socket</code></h4><p><strong>问题</strong>：创建socket对象需要ios，打开socket需要protocol和error_code?为啥需要打开呢？打开的时候在什么情况下会出错呢？</p><p><strong>答案</strong>：<code>asio::ip::tcp::socket</code>对象需要一个<code>asio::io_context</code>对象来处理I&#x2F;O操作。打开<code>socket</code>指的是使其准备好进行网络通信。如果指定的协议不支持，或者系统资源不足（如端口号被占用），打开<code>socket</code>可能会出错。</p><h4 id="4-关于acceptor"><a href="#4-关于acceptor" class="headerlink" title="4. 关于acceptor"></a>4. 关于<code>acceptor</code></h4><p><strong>问题</strong>：accecptor也是一个接收器socket，也需要打开，并且流程跟socket一样？</p><p><strong>答案</strong>：<code>asio::ip::tcp::acceptor</code>类似于一个特殊的<code>socket</code>，专门用于监听和接受来自客户端的连接。它也需要被打开和绑定到一个端点上，以便知道在哪个端口上监听。</p><h4 id="5-绑定acceptor"><a href="#5-绑定acceptor" class="headerlink" title="5. 绑定acceptor"></a>5. 绑定<code>acceptor</code></h4><p><strong>问题</strong>：绑定accecptor，是先创建，然后在将他绑定到endpoint上么？然后listen，就可以接受ip：port的消息了？</p><p><strong>答案</strong>：你需要先创建一个<code>acceptor</code>，然后将其绑定到一个<code>endpoint</code>上（一个IP地址和端口号的组合）。一旦绑定并调用了<code>listen()</code>，它就开始监听该端点上的入站连接。</p><h4 id="6-客户端访问服务端"><a href="#6-客户端访问服务端" class="headerlink" title="6. 客户端访问服务端"></a>6. 客户端访问服务端</h4><p><strong>问题</strong>：客户端访问服务端，需要socket绑定endpoint（服务器的ip:port）。</p><p><strong>答案</strong>：客户端的<code>socket</code>需要连接到服务器的<code>endpoint</code>（服务器的IP地址和端口号）。</p><h4 id="7-关于asio-ip-address-v6-any"><a href="#7-关于asio-ip-address-v6-any" class="headerlink" title="7. 关于asio::ip::address_v6::any()"></a>7. 关于<code>asio::ip::address_v6::any()</code></h4><p><strong>问题</strong>：asio::ip::address_v6::any()，这种代码只会在服务器上创建endpoint上使用，而且基本不会出错？</p><p><strong>答案</strong>：<code>asio::ip::address_v6::any()</code>在服务器上创建一个可以接受任何IPv6地址的端点，这意味着它可以从任何IPv6地址接收连接。这通常不会出错，除非有底层网络配置问题。</p><h4 id="8-关于接收器端点的访问"><a href="#8-关于接收器端点的访问" class="headerlink" title="8. 关于接收器端点的访问"></a>8. 关于接收器端点的访问</h4><p><strong>问题</strong>：接收器接受服务器的端点，此时是不是只用（端点的ip，和端口号）访问？比如开放了公网ip，那只可以用“公网ip:端口”访问，如果用“127.0.0.1：3333”就不可以（如果服务器在本地）。</p><p><strong>答案</strong>：如果服务器监听公网IP和端口，那么客户端必须使用这个公网IP和端口来连接。如果服务器监听的是本地地址（如127.0.0.1），那么只有本地客户端（在同一台机器上）可以使用这个地址和端口连接。</p><h4 id="9-理解asio-io-context的重要性"><a href="#9-理解asio-io-context的重要性" class="headerlink" title="9. 理解asio::io_context的重要性"></a>9. 理解<code>asio::io_context</code>的重要性</h4><p><strong>问题</strong>：如果不理解asio::io_context，是不是可以先跳过？</p><p><strong>答案</strong>：<code>asio::io_context</code>是Boost Asio库的核心，负责管理所有I&#x2F;O服务。虽然一开始可能不容易理解，但它在Asio编程中非常重要，建议不要跳过。随着实践的增加，你会逐渐理解它的用途和重要性。</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置docker服务器</title>
    <link href="/2023/11/07/docker%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/07/docker%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ul><li>本文介绍如何在ubuntu环境下创建docker容器，并且将此容器设置成一个“服务器”</li><li>然后如何ssh进docker容器(root用户)，并且配置免密登录</li></ul><p><em>步骤如下</em></p><hr><h1 id="1-创建Dockerfile文件"><a href="#1-创建Dockerfile文件" class="headerlink" title="1.创建Dockerfile文件"></a>1.创建Dockerfile文件</h1><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Docker"><span class="hljs-comment"># 使用官方Ubuntu基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-comment"># 避免在自动化构建时出现提示</span><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># 安装开发所需的包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span><br><span class="language-bash">    vim \</span><br><span class="language-bash">    git \</span><br><span class="language-bash">    curl \</span><br><span class="language-bash">    wget \</span><br><span class="language-bash">    build-essential \</span><br><span class="language-bash">    lsb-release \</span><br><span class="language-bash">    sudo \</span><br><span class="language-bash">    man \</span><br><span class="language-bash">    software-properties-common \</span><br><span class="language-bash">    ca-certificates \</span><br><span class="language-bash">    &amp;&amp; apt-get clean \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># 如果需要其他语言环境或工具，可以在这里继续安装，比如对于Python开发：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3 python3-pip</span><br><br><span class="hljs-comment"># 对于Node.js开发：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -sL https://deb.nodesource.com/setup_14.x | bash - &amp;&amp; apt-get update &amp;&amp; apt-get install -y nodejs</span><br><br><span class="hljs-comment"># 清理apt缓存以减少镜像大小</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get clean &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># （可选）设置工作目录，这是容器内的目录，你的项目代码可以放在这里</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><br><span class="hljs-comment"># 设置默认运行的命令，此命令将保持容器运行</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;tail&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;/dev/null&quot;</span>]</span><br></code></pre></td></tr></table></figure><hr><h1 id="2-执行命令创建镜像"><a href="#2-执行命令创建镜像" class="headerlink" title="2.执行命令创建镜像"></a>2.执行命令创建镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t mydocker .<br></code></pre></td></tr></table></figure><p>将<code>mydocker</code>换成你想要的镜像名称</p><hr><h1 id="3-利用镜像创建容器"><a href="#3-利用镜像创建容器" class="headerlink" title="3.利用镜像创建容器"></a>3.利用镜像创建容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name mydocker-container -p 8080:8080 -p 20000:22 mydocker<br></code></pre></td></tr></table></figure><p>将<code>mydocker-container</code>换成你自己的容器名称，<code>mydocker</code>是镜像名称</p><hr><p>此时容器已经创建成功，可以进入容器查看 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it myapp-container /bin/bash<br></code></pre></td></tr></table></figure><h1 id="4-配置并开启docker容器的ssh服务"><a href="#4-配置并开启docker容器的ssh服务" class="headerlink" title="4.配置并开启docker容器的ssh服务"></a>4.配置并开启docker容器的ssh服务</h1><h2 id="a-确保-SSH-服务已经在容器内安装并正在运行。"><a href="#a-确保-SSH-服务已经在容器内安装并正在运行。" class="headerlink" title="(a)确保 SSH 服务已经在容器内安装并正在运行。"></a>(a)确保 SSH 服务已经在容器内安装并正在运行。</h2><p>可以使用以下命令来安装并启动 SSH 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker apt-get update<br>docker <span class="hljs-built_in">exec</span> -it xddocker apt-get install -y openssh-server<br>docker <span class="hljs-built_in">exec</span> -it xddocker service ssh start<br></code></pre></td></tr></table></figure><p>如果 <code>service ssh start</code> 不工作，您也可以尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker /etc/init.d/ssh start<br></code></pre></td></tr></table></figure><p>或者直接使用 systemctl（如果您的容器支持 systemd）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker systemctl start ssh<br></code></pre></td></tr></table></figure><h2 id="b-设置-root-用户的密码。"><a href="#b-设置-root-用户的密码。" class="headerlink" title="(b)设置 root 用户的密码。"></a>(b)设置 <code>root</code> 用户的密码。</h2><p>你需要使用 <code>passwd</code> 命令来为 <code>root</code> 用户设置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker passwd root<br></code></pre></td></tr></table></figure><p>当系统提示时输入并确认密码。</p><h2 id="d-配置-SSH-以允许-root-用户登录。"><a href="#d-配置-SSH-以允许-root-用户登录。" class="headerlink" title="(d)配置 SSH 以允许 root 用户登录。"></a>(d)配置 SSH 以允许 <code>root</code> 用户登录。</h2><p>编辑容器中的 <code>/etc/ssh/sshd_config</code> 文件，将 <code>PermitRootLogin</code> 的值更改为 <code>yes</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker sed -i <span class="hljs-string">&#x27;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><h2 id="e-重新启动-SSH-服务以使更改生效："><a href="#e-重新启动-SSH-服务以使更改生效：" class="headerlink" title="(e)重新启动 SSH 服务以使更改生效："></a>(e)重新启动 SSH 服务以使更改生效：</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> xddocker service ssh restart<br></code></pre></td></tr></table></figure><h2 id="f-使用-SSH-连接到容器："><a href="#f-使用-SSH-连接到容器：" class="headerlink" title="(f)使用 SSH 连接到容器："></a>(f)使用 SSH 连接到容器：</h2><p>现在您应该可以使用 SSH 连接到容器的 <code>root</code> 用户了。使用宿主机的端口 <code>20000</code> 来连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@localhost -p 20000<br></code></pre></td></tr></table></figure><hr><p><strong>到此为止，docker容器的ssh已经完全配置好了</strong></p><hr><h1 id="5-配置免密登录"><a href="#5-配置免密登录" class="headerlink" title="5.配置免密登录"></a>5.配置免密登录</h1><p>以下是在Windows系统使用Git Bash来完成这个过程的详细步骤</p><hr><h2 id="a-生成SSH密钥对"><a href="#a-生成SSH密钥对" class="headerlink" title="(a)生成SSH密钥对"></a>(a)生成SSH密钥对</h2><p>打开<code>git bash</code>,输入命令生成密钥对，一路回车，密钥对在 <code>/c/Users/&lt;你的用户名&gt;/.ssh/id_rsa</code>文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure><h2 id="b-复制SSH公钥到远程服务器"><a href="#b-复制SSH公钥到远程服务器" class="headerlink" title="(b)复制SSH公钥到远程服务器"></a>(b)复制SSH公钥到远程服务器</h2><p>本地git bash中查看公钥内容,复制下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>然后登录远程主机   (端口号20000，这是映射的端口)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@远程主机ip -p 20000<br></code></pre></td></tr></table></figure><p>登录到远程服务器后，执行以下命令来编辑（或创建）<code>authorized_keys</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.ssh<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">touch</span> ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br>vim ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>将复制的公钥粘贴进文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basj">按i键进入编辑模式<br>按住Shift+Insert进行粘贴<br>按Esc退出面积模式<br>输入&quot;:wq&quot;保存退出<br></code></pre></td></tr></table></figure><h2 id="c-退出后，即可进行免密登录"><a href="#c-退出后，即可进行免密登录" class="headerlink" title="(c)退出后，即可进行免密登录"></a>(c)退出后，即可进行免密登录</h2>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树逆序对（Master of Both）</title>
    <link href="/2023/11/07/%E5%AD%97%E5%85%B8%E6%A0%91%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2023/11/07/%E5%AD%97%E5%85%B8%E6%A0%91%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p> <a href="https://codeforces.com/gym/104090/problem/K">2022ICPC杭州K题 Master of Both</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定n和m，表示n个字符串和m组询问</p><p>字符串长度1e5，总长度不超过1e6</p><p>m组询问中，每次给定一个字符串（只含有26个不同的小写字母），表示比较规则（前面小于后面），求n个字符串中的逆序对个数</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>首先发现，对于n个字符串中任意两个字符串a,b，只有两种情况</p><ul><li><input disabled="" type="checkbox"> a是b的前缀，那么此时a&lt;b一定成立，在任何比较规则下</li><li><input disabled="" type="checkbox"> a不是b的前缀，那么，首先找到<code>最长公共前缀的下一个字符</code>，这俩字符即可决定a和b的大小关系，并且a和b的大小关系只由这一对字符决定</li></ul><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><ol><li>字典树</li><li>插入字符串的时候维护res数组和cnt数组。</li><li>设res[i][j]表示 字母i&gt;字母j的情况下，产生的逆序对个数</li><li>设cnt数组表示字典树中节点i的字数中有多少个单词</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> t[N][<span class="hljs-number">26</span>],idx;<br>ll cnt[N];<span class="hljs-comment">//trie中每个节点的权值 </span><br>ll res[<span class="hljs-number">26</span>][<span class="hljs-number">26</span>];<span class="hljs-comment">//在i&gt;j的规则下，整个序列产生的逆序对 </span><br>ll chushi;<span class="hljs-comment">//表示一定会产生的逆序对个数 </span><br>ll n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_res</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-comment">//当前在p节点，要经过边q</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br><span class="hljs-comment">//当i&gt;q的时候，产生的逆序对个数增加 cnt个 </span><br>res[i][q]+=cnt[t[p][i]];<br>&#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>&#123;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前节点 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-type">int</span> q=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//边的方向</span><br><span class="hljs-keyword">if</span>(!t[p][q])t[p][q]=++idx;<br><br><span class="hljs-built_in">update_res</span>(p,q);<br><br>p=t[p][q];<br><br>cnt[p]++; <br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>chushi+=cnt[t[p][i]];<span class="hljs-comment">//一定会产生的逆序对 </span><br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>&#123;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br><span class="hljs-comment">//注意j在i前面，因为s[j]&gt;s[i] </span><br>ans+=res[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">insert</span>(s);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>string s;<br>cin&gt;&gt;s;<br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(s)+chushi&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>字典树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悬线法dp(玉蟾宫+ICPC银川K)</title>
    <link href="/2023/11/07/%E6%82%AC%E7%BA%BF%E6%B3%95dp/"/>
    <url>/2023/11/07/%E6%82%AC%E7%BA%BF%E6%B3%95dp/</url>
    
    <content type="html"><![CDATA[<h1 id="玉蟾宫"><a href="#玉蟾宫" class="headerlink" title="玉蟾宫"></a>玉蟾宫</h1><p><a href="https://www.luogu.com.cn/problem/P4147">洛谷P4147玉蟾宫</a></p><p>给一个矩阵，一些点有障碍物，求最大子矩阵</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p><code>悬线法dp</code>，第一次听说。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>（1）结论：答案一定是一个矩形（废话。。。）<br>（2）最大矩形一定是：由其中<code>某个点</code>，<code>先</code>向上扩展到最大，<code>然后</code>再分别向左、向右走到最远。<br>（3）由于（2）的结论对所有点这样操作，一定可以找到最大矩形<br>  (4)  注意<code>先初始化h，L，R</code>，然后在<code>h=1的时候预处理L,R</code>，然后<code>再更新h，同时更新L，R</code>，并且统计答案   </p><h2 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">char</span> a[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][N];<span class="hljs-comment">//每个点往上延申的最大长度</span><br><span class="hljs-type">int</span> L[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往左走最远到哪</span><br><span class="hljs-type">int</span> R[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往右走最远到哪</span><br><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)h[i][j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//自己</span><br>L[i][j]=R[i][j]=j;<span class="hljs-comment">//自己 </span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//在h=1的情况下处理L和R </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//处理L </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>L[i][j]=L[i][j<span class="hljs-number">-1</span>];<br>&#125; <br>&#125; <br><span class="hljs-comment">//处理R </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>R[i][j]=R[i][j+<span class="hljs-number">1</span>];<br>&#125; <br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<span class="hljs-comment">//h数组扩展 </span><br><br><span class="hljs-comment">//L、R向内收缩 </span><br>L[i][j]=<span class="hljs-built_in">max</span>(L[i][j],L[i<span class="hljs-number">-1</span>][j]);<br>R[i][j]=<span class="hljs-built_in">min</span>(R[i][j],R[i<span class="hljs-number">-1</span>][j]); <br>&#125;<br><br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,h[i][j]*(R[i][j]-L[i][j]+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>&#125; <br>cout&lt;&lt;ans*<span class="hljs-number">3</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="ICPC银川"><a href="#ICPC银川" class="headerlink" title="ICPC银川"></a>ICPC银川</h1><p><a href="https://codeforces.com/gym/104021/problem/K">Largest Common Submatrix</a></p><p>给定一个矩阵A和一个矩阵B，求最大子矩阵，满足最大子矩阵同时是A的最大子矩阵和B的最大子矩阵</p><h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>悬线法dp，注意转移条件，以及<code>边界问题</code>！！！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> b[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][N];<span class="hljs-comment">//每个点往上延申的最大长度</span><br><span class="hljs-type">int</span> L[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往左走最远到哪</span><br><span class="hljs-type">int</span> R[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往右走最远到哪</span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;pos[N*N];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br>cin&gt;&gt;a[i][j];<br>h[i][j]=<span class="hljs-number">1</span>;<br>L[i][j]=R[i][j]=j;<span class="hljs-comment">//自己</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br>cin&gt;&gt;b[i][j];<br>pos[b[i][j]]= &#123;i,j&#125;;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//在h=1的情况下处理L和R</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">//处理L</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j&lt;=m; j++) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//a中当前数字的左边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[x].first;<br><span class="hljs-type">int</span> by=pos[x].second;<br><br><span class="hljs-comment">//如果可以向左边扩展</span><br><span class="hljs-keyword">if</span>(b[bx][by<span class="hljs-number">-1</span>]==y) &#123;<br>L[i][j]=L[i][j<span class="hljs-number">-1</span>];<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//处理R</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">1</span>; j--) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i][j+<span class="hljs-number">1</span>];<span class="hljs-comment">//a中当前数字的右边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[x].first;<br><span class="hljs-type">int</span> by=pos[x].second;<br><br><span class="hljs-comment">//如果可以向右边扩展</span><br><span class="hljs-keyword">if</span>(b[bx][by+<span class="hljs-number">1</span>]==y) &#123;<br>R[i][j]=R[i][j+<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//更新h,L,R ，统计答案</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">//a中当前数字的上边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[a[i][j]].first;<br><span class="hljs-type">int</span> by=pos[a[i][j]].second;<br><br><span class="hljs-comment">//如果可以向上边扩展</span><br><span class="hljs-keyword">if</span>(y&amp;&amp;b[bx<span class="hljs-number">-1</span>][by]==y) &#123;<br>h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>L[i][j]=<span class="hljs-built_in">max</span>(L[i][j],L[i<span class="hljs-number">-1</span>][j]);<br>R[i][j]=<span class="hljs-built_in">min</span>(R[i][j],R[i<span class="hljs-number">-1</span>][j]);<br>&#125;<br>ans=<span class="hljs-built_in">max</span>(ans,h[i][j]*(R[i][j]-L[i][j]+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
