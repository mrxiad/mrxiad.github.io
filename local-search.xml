<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker服务器 &amp; docker-compose</title>
    <link href="/2024/03/19/linux/docker/"/>
    <url>/2024/03/19/linux/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker服务器"><a href="#docker服务器" class="headerlink" title="docker服务器"></a>docker服务器</h1><ul><li>介绍如何在ubuntu环境下创建docker容器，并且将此容器设置成一个“服务器”</li><li>然后如何ssh进docker容器(root用户)，并且配置免密登录</li></ul><p><em>步骤如下</em></p><h2 id="1-创建Dockerfile文件"><a href="#1-创建Dockerfile文件" class="headerlink" title="1.创建Dockerfile文件"></a>1.创建Dockerfile文件</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Docker"><span class="hljs-comment"># 使用官方Ubuntu基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-comment"># 避免在自动化构建时出现提示</span><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><br><span class="hljs-comment"># 安装开发所需的包</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span><br><span class="language-bash">    vim \</span><br><span class="language-bash">    git \</span><br><span class="language-bash">    curl \</span><br><span class="language-bash">    wget \</span><br><span class="language-bash">    build-essential \</span><br><span class="language-bash">    lsb-release \</span><br><span class="language-bash">    sudo \</span><br><span class="language-bash">    man \</span><br><span class="language-bash">    software-properties-common \</span><br><span class="language-bash">    ca-certificates \</span><br><span class="language-bash">    &amp;&amp; apt-get clean \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># 如果需要其他语言环境或工具，可以在这里继续安装，比如对于Python开发：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3 python3-pip</span><br><br><span class="hljs-comment"># 对于Node.js开发：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -sL https://deb.nodesource.com/setup_14.x | bash - &amp;&amp; apt-get update &amp;&amp; apt-get install -y nodejs</span><br><br><span class="hljs-comment"># 清理apt缓存以减少镜像大小</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get clean &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># （可选）设置工作目录，这是容器内的目录，你的项目代码可以放在这里</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><br><span class="hljs-comment"># 设置默认运行的命令，此命令将保持容器运行</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;tail&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;/dev/null&quot;</span>]</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-执行命令创建镜像"><a href="#2-执行命令创建镜像" class="headerlink" title="2.执行命令创建镜像"></a>2.执行命令创建镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t mydocker .<br></code></pre></td></tr></table></figure><p>将<code>mydocker</code>换成你想要的镜像名称</p><hr><h2 id="3-利用镜像创建容器"><a href="#3-利用镜像创建容器" class="headerlink" title="3.利用镜像创建容器"></a>3.利用镜像创建容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name mydocker-container -p 8080:8080 -p 20000:22 mydocker<br></code></pre></td></tr></table></figure><p>将<code>mydocker-container</code>换成你自己的容器名称，<code>mydocker</code>是镜像名称</p><hr><p>此时容器已经创建成功，可以进入容器查看 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it myapp-container /bin/bash<br></code></pre></td></tr></table></figure><h2 id="4-配置并开启docker容器的ssh服务"><a href="#4-配置并开启docker容器的ssh服务" class="headerlink" title="4.配置并开启docker容器的ssh服务"></a>4.配置并开启docker容器的ssh服务</h2><h3 id="a-确保-SSH-服务已经在容器内安装并正在运行。"><a href="#a-确保-SSH-服务已经在容器内安装并正在运行。" class="headerlink" title="(a)确保 SSH 服务已经在容器内安装并正在运行。"></a>(a)确保 SSH 服务已经在容器内安装并正在运行。</h3><p>可以使用以下命令来安装并启动 SSH 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker apt-get update<br>docker <span class="hljs-built_in">exec</span> -it xddocker apt-get install -y openssh-server<br>docker <span class="hljs-built_in">exec</span> -it xddocker service ssh start<br></code></pre></td></tr></table></figure><p>如果 <code>service ssh start</code> 不工作，您也可以尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker /etc/init.d/ssh start<br></code></pre></td></tr></table></figure><p>或者直接使用 systemctl（如果您的容器支持 systemd）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker systemctl start ssh<br></code></pre></td></tr></table></figure><h3 id="b-设置-root-用户的密码。"><a href="#b-设置-root-用户的密码。" class="headerlink" title="(b)设置 root 用户的密码。"></a>(b)设置 <code>root</code> 用户的密码。</h3><p>你需要使用 <code>passwd</code> 命令来为 <code>root</code> 用户设置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker passwd root<br></code></pre></td></tr></table></figure><p>当系统提示时输入并确认密码。</p><h3 id="d-配置-SSH-以允许-root-用户登录。"><a href="#d-配置-SSH-以允许-root-用户登录。" class="headerlink" title="(d)配置 SSH 以允许 root 用户登录。"></a>(d)配置 SSH 以允许 <code>root</code> 用户登录。</h3><p>编辑容器中的 <code>/etc/ssh/sshd_config</code> 文件，将 <code>PermitRootLogin</code> 的值更改为 <code>yes</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it xddocker sed -i <span class="hljs-string">&#x27;s/#PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><h3 id="e-重新启动-SSH-服务以使更改生效："><a href="#e-重新启动-SSH-服务以使更改生效：" class="headerlink" title="(e)重新启动 SSH 服务以使更改生效："></a>(e)重新启动 SSH 服务以使更改生效：</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> xddocker service ssh restart<br></code></pre></td></tr></table></figure><h3 id="f-使用-SSH-连接到容器："><a href="#f-使用-SSH-连接到容器：" class="headerlink" title="(f)使用 SSH 连接到容器："></a>(f)使用 SSH 连接到容器：</h3><p>现在您应该可以使用 SSH 连接到容器的 <code>root</code> 用户了。使用宿主机的端口 <code>20000</code> 来连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@localhost -p 20000<br></code></pre></td></tr></table></figure><hr><p><strong>到此为止，docker容器的ssh已经完全配置好了</strong></p><hr><h2 id="5-配置免密登录"><a href="#5-配置免密登录" class="headerlink" title="5.配置免密登录"></a>5.配置免密登录</h2><p>以下是在Windows系统使用Git Bash来完成这个过程的详细步骤</p><hr><h3 id="a-生成SSH密钥对"><a href="#a-生成SSH密钥对" class="headerlink" title="(a)生成SSH密钥对"></a>(a)生成SSH密钥对</h3><p>打开<code>git bash</code>,输入命令生成密钥对，一路回车，密钥对在 <code>/c/Users/&lt;你的用户名&gt;/.ssh/id_rsa</code>文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096<br></code></pre></td></tr></table></figure><h3 id="b-复制SSH公钥到远程服务器"><a href="#b-复制SSH公钥到远程服务器" class="headerlink" title="(b)复制SSH公钥到远程服务器"></a>(b)复制SSH公钥到远程服务器</h3><p>本地git bash中查看公钥内容,复制下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>然后登录远程主机   (端口号20000，这是映射的端口)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@远程主机ip -p 20000<br></code></pre></td></tr></table></figure><p>登录到远程服务器后，执行以下命令来编辑（或创建）<code>authorized_keys</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.ssh<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">touch</span> ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br>vim ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>将复制的公钥粘贴进文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basj">按i键进入编辑模式<br>按住Shift+Insert进行粘贴<br>按Esc退出面积模式<br>输入&quot;:wq&quot;保存退出<br></code></pre></td></tr></table></figure><h3 id="c-退出后，即可进行免密登录"><a href="#c-退出后，即可进行免密登录" class="headerlink" title="(c)退出后，即可进行免密登录"></a>(c)退出后，即可进行免密登录</h3><h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><blockquote><p> docker-compose示例</p></blockquote><p>使用Docker Compose可以将一系列创建及映射资源（网络、数据卷等）操作放在配置文件中，并且可以通过depends_on参数指定容器的启动顺序，通过environment参数指定Kafka需要的基本参数信息</p><h2 id="1-创建kafka-group-yml，保存以下信息"><a href="#1-创建kafka-group-yml，保存以下信息" class="headerlink" title="1.创建kafka-group.yml，保存以下信息"></a>1.创建<strong>kafka-group.yml</strong>，保存以下信息</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">zookeeper-test:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zookeeper</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;2181:2181&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper_vol:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper_vol:/datalog</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper_vol:/logs</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zookeeper-test</span><br><br>  <span class="hljs-attr">kafka-test:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wurstmeister/kafka</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9092:9092&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="hljs-string">&quot;60.205.9.142&quot;</span>   <span class="hljs-comment">#注意这个改成公网ip</span><br>      <span class="hljs-attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">&quot;zookeeper-test:2181&quot;</span><br>      <span class="hljs-attr">KAFKA_LOG_DIRS:</span> <span class="hljs-string">&quot;/kafka/logs&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">kafka_vol:/kafka</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper-test</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">kafka-test</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">zookeeper_vol:</span> &#123;&#125;<br>  <span class="hljs-attr">kafka_vol:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="2-启动容器组"><a href="#2-启动容器组" class="headerlink" title="2.启动容器组"></a>2.启动容器组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动Kafka容器组</span><br>docker compose -f kafka-group.yml up -d<br><br><span class="hljs-comment">#停止并移除容器以及数据卷</span><br>docker-compose -f kafka-group.yml down -v<br><br><span class="hljs-comment"># 输出示例</span><br> ✔ Network kafka-group_default         Created <br> ✔ Volume <span class="hljs-string">&quot;kafka-group_zookeeper_vol&quot;</span>  Created <br> ✔ Volume <span class="hljs-string">&quot;kafka-group_kafka_vol&quot;</span>      Created <br> ✔ Container zookeeper-test            Started <br> ✔ Container kafka-test                Started<br></code></pre></td></tr></table></figure><h2 id="3-进入kafka容器检查所有topic-以及所有消息"><a href="#3-进入kafka容器检查所有topic-以及所有消息" class="headerlink" title="3.进入kafka容器检查所有topic(以及所有消息)"></a>3.进入kafka容器检查所有topic(以及所有消息)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it kafka-test /bin/bash<br><br><span class="hljs-comment">#检测所有topic</span><br>/opt/kafka/bin/kafka-topics.sh --list --zookeeper zookeeper-test:2181<br><br><span class="hljs-comment">#检测topic为[test]的所有信息</span><br>/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql主从复制</title>
    <link href="/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><strong>主服务器IP</strong>: 假设为 <code>43.138.20.23</code>（公网IP或局域网IP）</li><li><strong>从服务器IP</strong>: 假设为从服务器的IP地址</li><li><strong>MySQL版本</strong>: 保证主从服务器的MySQL版本相同或兼容</li></ul><h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><ol><li><p><strong>配置MySQL</strong>:</p><ul><li>编辑MySQL配置文件（通常位于<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>或<code>/etc/my.cnf</code>）。</li><li>确保设置了唯一的<code>server-id</code>。</li><li>启用二进制日志（binlog）。</li><li>指定要复制的数据库（可选）。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs config">server-id=1<br>log_bin=mysql-bin<br>binlog_do_db=要复制的数据库名（如果复制整个实例，可以省略此行）<br></code></pre></td></tr></table></figure></li><li><p><strong>创建复制用户</strong>:</p><ul><li>在MySQL命令行中，创建一个专用的复制用户。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER &#x27;replica&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;<br>GRANT REPLICATION SLAVE ON *.* TO &#x27;replica&#x27;@&#x27;%&#x27;;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p><strong>获取主服务器状态</strong>:</p><ul><li>记录二进制日志文件名和位置，这将用于<code>从服务器</code>配置。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW MASTER STATUS;<br></code></pre></td></tr></table></figure></li></ol><h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><ol><li><p><strong>配置MySQL</strong>:</p><ul><li>同样编辑MySQL配置文件。</li><li>设置一个与主服务器不同的<code>server-id</code>。</li></ul> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置复制</strong>:</p><ul><li>根据主服务器提供的信息，配置从服务器连接到主服务器。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO<br>MASTER_HOST=&#x27;主服务器IP&#x27;,<br>MASTER_USER=&#x27;replica&#x27;,<br>MASTER_PASSWORD=&#x27;password&#x27;,<br>MASTER_LOG_FILE=&#x27;记录的文件名&#x27;,<br>MASTER_LOG_POS=记录的位置;<br></code></pre></td></tr></table></figure></li><li><p><strong>启动复制</strong>:</p><ul><li>开始复制进程。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START SLAVE;<br></code></pre></td></tr></table></figure></li><li><p><strong>验证复制状态</strong>:</p><ul><li>检查复制是否成功启动，关注<code>Slave_IO_Running</code>和<code>Slave_SQL_Running</code>状态是否都是<code>Yes</code>。</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW SLAVE STATUS\G;<br></code></pre></td></tr></table></figure></li></ol><h3 id="每一步骤的作用"><a href="#每一步骤的作用" class="headerlink" title="每一步骤的作用"></a>每一步骤的作用</h3><ul><li><strong>配置MySQL</strong>: 设置<code>server-id</code>和启用binlog是复制所必需的，因为它们使MySQL服务器能够在复制过程中唯一地标识自己并记录更改。</li><li><strong>创建复制用户</strong>: 为了安全性和权限管理，复制过程应该使用一个专用账户。这一步创建了这样的账户并授权它进行复制。</li><li><strong>获取主服务器状态</strong>: 获取当前的binlog文件和位置是为了让从服务器知道从哪里开始复制数据。</li><li><strong>配置复制</strong>: 这一步实际上是在告诉从服务器如何连接到主服务器，包括使用哪个用户、从哪个binlog文件和位置开始复制。</li><li><strong>启动复制</strong>: 这一步启动了实际的数据复制过程。</li><li><strong>验证复制状态</strong>: 最后一步是确认复制是否按预期运行，通过检查<code>SHOW SLAVE STATUS</code>的输出来完成。</li></ul><blockquote><p><strong>只有主服务器需要显式地创建并配置一个专用的复制用户</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql命令</title>
    <link href="/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="查看客户端连接了"><a href="#查看客户端连接了" class="headerlink" title="查看客户端连接了"></a>查看客户端连接了</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show processlist;<br></code></pre></td></tr></table></figure><h2 id="查看空闲连接最大空闲时长"><a href="#查看空闲连接最大空闲时长" class="headerlink" title="查看空闲连接最大空闲时长"></a>查看空闲连接最大空闲时长</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;wait_timeout&#x27;;<br></code></pre></td></tr></table></figure><h2 id="手动断开空闲的连接"><a href="#手动断开空闲的连接" class="headerlink" title="手动断开空闲的连接"></a>手动断开空闲的连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">kill connection +6;  -- 6是id<br></code></pre></td></tr></table></figure><h2 id="查看最大连接数"><a href="#查看最大连接数" class="headerlink" title="查看最大连接数"></a>查看最大连接数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;max_connections&#x27;;<br></code></pre></td></tr></table></figure><h1 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h1><h2 id="数据库的文件存放目录"><a href="#数据库的文件存放目录" class="headerlink" title="数据库的文件存放目录"></a>数据库的文件存放目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;<br><br>+---------------+-----------------+<br>| Variable_name | Value           |<br>+---------------+-----------------+<br>| datadir       | /var/lib/mysql/ |<br>+---------------+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="对数据库加锁"><a href="#对数据库加锁" class="headerlink" title="对数据库加锁"></a>对数据库加锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush tables with read lock;<br></code></pre></td></tr></table></figure><blockquote><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul></blockquote><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">unlock tables;<br></code></pre></td></tr></table></figure><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump --single-transaction -u username -p database_name &gt; backup_file.sql<br></code></pre></td></tr></table></figure><ul><li><code>--single-transaction</code>：这个选项告诉<code>mysqldump</code>在备份开始时开启一个新的事务。为了保持一致性视图，事务的隔离级别会被设置为可重复读。这样，备份操作看到的数据是在事务开始时刻的一致性快照，<strong>而备份操作本身不会阻塞后续的写操作</strong>。</li><li><code>-u username</code>：指定用于连接数据库的用户名。</li><li><code>-p</code>：提示输入用于连接数据库的用户密码。</li><li><code>database_name</code>：指定要备份的数据库名。</li><li><code>&gt; backup_file.sql</code>：将备份输出重定向到一个文件中。</li></ul><h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u username -p database_name &lt; backup_file.sql<br></code></pre></td></tr></table></figure><ul><li><code>-u username</code>：指定用于连接数据库的用户名。</li><li><code>-p</code>：在命令执行后，你会被提示输入该用户的密码。出于安全考虑，建议不要在命令行中直接包含密码。</li><li><code>database_name</code>：指定要恢复到的目标数据库名。这个数据库应该已经存在于MySQL服务器上，<code>mysql</code>命令不会自动创建数据库。</li><li><code>&lt; backup_file.sql</code>：这部分告诉shell从<code>backup_file.sql</code>文件中读取SQL语句并将其作为输入传递给<code>mysql</code>命令。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95%E7%AF%87/"/>
    <url>/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h1 id="自动创建索引"><a href="#自动创建索引" class="headerlink" title="自动创建索引"></a>自动创建索引</h1><blockquote><p>主键 —— 不包含NULL值的唯一列—— 自动生成一个隐式自增id</p></blockquote><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择<strong>第一个不包含 NULL 值的唯一列</strong>作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><h1 id="查询效率"><a href="#查询效率" class="headerlink" title="查询效率"></a>查询效率</h1><p>B+Tree 存储<strong>千万级的数据</strong>只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p><h1 id="B-树和其他数据结构"><a href="#B-树和其他数据结构" class="headerlink" title="B+树和其他数据结构"></a>B+树和其他数据结构</h1><p><em><strong>B+Tree vs B Tree</strong></em></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><em><strong>B+Tree vs 二叉树</strong></em></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p><p><em><strong>B+Tree vs Hash</strong></em></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>从物理存储的角度来看，索引分为<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</p><p>区别：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据</li></ul><p>在<strong>查询时使用了二级索引</strong>，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong></p><h1 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h1><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，<strong>一张表最多只有一个主键索引</strong>，索引列的值不允许有空值。</p><p>在创建表时，创建主键索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  <span class="hljs-keyword">PRIMARY</span> KEY (index_column_1) <span class="hljs-keyword">USING</span> BTREE<br>);<br></code></pre></td></tr></table></figure><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>在创建表时，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  <span class="hljs-keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>在创建表时，创建普通索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  INDEX(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p>建表后，如果要创建普通索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_column_1,index_column_2,...); <br></code></pre></td></tr></table></figure><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了<strong>减少索引占用的存储空间，提升查询效率</strong>。</p><p>在创建表时，创建前缀索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(<br>    column_list,<br>    INDEX(column_name(length))<br>); <br></code></pre></td></tr></table></figure><p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(column_name(length)); <br></code></pre></td></tr></table></figure><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有<strong>查询优化器，所以 a 字段在 where 子句的顺序并不重要。</strong></p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><p>联合索引的最左匹配原则，在<strong>遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配**，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，**对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong>，前面我也用了四个例子说明了。</p><h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>现在我们知道，对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h1 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h1><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度 &#x3D; 某个字段 column 不同值的个数「除以」表的总行数</p><p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p><p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p><h1 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h1><p>这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure><p>有的同学会认为，单独给 status 建立一个索引就可以了。</p><p>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p><p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。</p><h1 id="什么时候需要-不需要创建索引？"><a href="#什么时候需要-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h1><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的<strong>增删改的效率</strong>，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护</li></ul><h1 id="什么时候适用索引？（查询的时候）"><a href="#什么时候适用索引？（查询的时候）" class="headerlink" title="什么时候适用索引？（查询的时候）"></a>什么时候适用索引？（查询的时候）</h1><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h1 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h1><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h1 id="优化索引的方法？"><a href="#优化索引的方法？" class="headerlink" title="优化索引的方法？"></a>优化索引的方法？</h1><ul><li>前缀索引优化；</li><li>覆盖索引优化；</li><li>主键索引最好是自增的，并且<code>NOT NULL</code>；</li><li>防止索引失效；</li></ul><p><strong>前缀索引有一定的局限性</strong>，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><p><strong>主键索引最好是自增的</strong></p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><blockquote><p>执行<code>EXPLAIN</code>命令来分析一个SQL查询时，MySQL会返回该查询的执行计划，但实际上并不执行这个查询，实际速度会比真正的查询要快，</p></blockquote><p>对于执行计划，参数有：</p><ul><li>possible_keys 字段表示可能用到的索引；</li><li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li><li>key_len 表示索引的长度；</li><li>rows 表示扫描的数据行数。</li><li><strong>type</strong> 表示数据扫描类型，我们需要重点看这个。</li><li>extra</li></ul><h2 id="type-字段就是描述了找到所需数据时使用的扫描方式是什么"><a href="#type-字段就是描述了找到所需数据时使用的扫描方式是什么" class="headerlink" title="type 字段就是描述了找到所需数据时使用的扫描方式是什么"></a>type 字段就是描述了找到所需数据时使用的扫描方式是什么</h2><p>常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p><ul><li>All（全表扫描）；</li><li>index（全索引扫描）；</li><li>range（索引范围扫描）；</li><li>ref（非唯一索引扫描）；</li><li>eq_ref（唯一索引扫描）；</li><li>const（结果只有一条的主键或唯一索引扫描）。</li></ul><blockquote><p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。</p></blockquote><h2 id="extra-显示的结果"><a href="#extra-显示的结果" class="headerlink" title="extra 显示的结果"></a>extra 显示的结果</h2><ul><li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li><li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li><li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，<strong>效率不错</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁</title>
    <link href="/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%94%81/"/>
    <url>/2024/03/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock;<br></code></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><blockquote><p>全局锁应用场景是什么？</p></blockquote><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><blockquote><p>缺点</p></blockquote><p>加上全局锁，意味着整个数据库都是只读状态。</p><p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><blockquote><p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p></blockquote><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br></code></pre></td></tr></table></figure><p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><p>另外，当会话退出后，也会释放所有表锁。</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong></p><blockquote><p> 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在<code>表级</code>别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在<code>表级</code>别加上一个「意向独占锁」；</li></ul><blockquote><p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的</p><p>执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h2 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h2><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ul><li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>当 innodb_autoinc_lock_mode &#x3D; 1：<ul><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li></ul><blockquote><p>问题：</p></blockquote><p>当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。</p><p>要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p><p>所以，<strong>当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题</strong>。</p><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>**除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对操作的记录加独占锁(X型锁)<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">table</span> .... <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对操作的记录加独占锁(X型锁)<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><blockquote><p> 在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。</p></blockquote><p><strong>可重复读</strong>隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h2 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h2><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）</li></ul><h2 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h2><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下<strong>幻读</strong>的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p><blockquote><p><strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong></p></blockquote><h2 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h2><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p><blockquote><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p></blockquote><h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><blockquote><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p></blockquote><h1 id="MySQL-是怎么加行级锁的？"><a href="#MySQL-是怎么加行级锁的？" class="headerlink" title="MySQL 是怎么加行级锁的？"></a>MySQL 是怎么加行级锁的？</h1><p>行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。</p><p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p><p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。</p><p>那到底是什么场景呢？总结一句，<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。</p><h2 id="唯一索引等值查询【其他情况等待完成】"><a href="#唯一索引等值查询【其他情况等待完成】" class="headerlink" title="唯一索引等值查询【其他情况等待完成】"></a>唯一索引等值查询【其他情况等待完成】</h2><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li><li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li></ul><blockquote><p>为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 next-key lock 会退化成「间隙锁」？</p></blockquote><ul><li>为什么 id &#x3D; 5 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id &#x3D; 5 这条记录，但是这次的案例是查询 id &#x3D; 2 的记录，只要保证前后两次查询 id &#x3D; 2 的结果集相同，就能避免幻读的问题了，所以即使 id &#x3D;5 被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id &#x3D; 5 加间隙锁，避免其他事务插入 id &#x3D; 2 的新记录就行了。</li><li>为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录</li></ul><h1 id="防止全表扫描"><a href="#防止全表扫描" class="headerlink" title="防止全表扫描"></a>防止全表扫描</h1><p>1.当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。</p><p>2.我们可以打开 MySQL <code>sql_safe_updates</code> 参数，这样可以预防 update 操作时 where 条件没有带上索引列。</p><p>3.如果发现即使在 where 条件中带上了列索引列，优化器走的还是全标扫描，这时我们就要使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引。</p><h1 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h1><blockquote><p>在执行插入语句时，如果插入的记录在<strong>其他事务</strong>持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</p></blockquote><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><p><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</p><p><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTp</title>
    <link href="/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
    <url>/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h1><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h1 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h1><ul><li><p>HOST：客户端发送请求时，用来指定服务器的域名</p></li><li><p>Content-Length：服务器在返回数据时，表明本次回应的数据长度。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。<br></code></pre></td></tr></table></figure></li><li><p>Connection：客户端要求服务器使用「HTTP 长连接」机制</p><blockquote><p>HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p></blockquote></li><li><p>Content-Type：服务器回应客户端，本次数据是什么格式。</p></li><li><p>Accept：客户端请求的时候，声明自己可以接受哪些数据格式</p></li><li><p>Content-Encoding：服务器返回的数据使用了什么压缩格式</p></li><li><p>Accept-Encoding：客户端可以接受哪些压缩方法。</p></li></ul><h1 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p><h2 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h2><p>先说明下安全和幂等的概念：</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><blockquote><p>GET 请求可以带 body，POST 请求的 URL 中也可以有参数的。</p></blockquote><h1 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h1><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。</p><p>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong></p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p><p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><h1 id="HTTP-1-1-的优点有哪些？"><a href="#HTTP-1-1-的优点有哪些？" class="headerlink" title="HTTP&#x2F;1.1 的优点有哪些？"></a>HTTP&#x2F;1.1 的优点有哪些？</h1><p>HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p><p><em>1. 简单</em></p><p>HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><p><em>2. 灵活和易于扩展</em></p><p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：</p><ul><li>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</li><li>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</li></ul><p><em>3. 应用广泛和跨平台</em></p><p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p><h1 id="HTTP-1-1-的性能如何？"><a href="#HTTP-1-1-的性能如何？" class="headerlink" title="HTTP&#x2F;1.1 的性能如何？"></a>HTTP&#x2F;1.1 的性能如何？</h1><p><em>1.长连接</em></p><p> <em>2.管道网络传输</em>：即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><blockquote><p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p><p>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</p></blockquote><p><strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><blockquote><p> 实际上 HTTP&#x2F;1.1 管道化技术不是默认开启，而且浏览器基本都没有支持.</p></blockquote><p><em>3. 队头阻塞</em></p><p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p><h1 id="HTTPS和HTTP区别"><a href="#HTTPS和HTTP区别" class="headerlink" title="HTTPS和HTTP区别"></a>HTTPS和HTTP区别</h1><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><blockquote><p> 如何实现的？</p></blockquote><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h1 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h1><p><em>1. 混合加密</em></p><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><p><em>2. 摘要算法 + 数字签名</em></p><p>为了<strong>保证传输的内容</strong>不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</p><p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong></p><blockquote><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p></blockquote><p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p><ul><li>一个是公钥，这个是可以公开给所有人的；</li><li>一个是私钥，这个必须由本人管理，不可泄露。</li></ul><p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p><p>流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><blockquote><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p></blockquote><blockquote><p>数字签名</p></blockquote><p>数字签名是一种用于验证数字信息（如文档、电子邮件、代码等）真实性、完整性和未被篡改的技术。它利用了非对称加密技术，确保了数据传输和通信的安全。数字签名不仅能证明数据来自签名者，还能保证数据自签名后未被修改过。</p><blockquote><p> 工作原理</p></blockquote><ol><li><strong>生成摘要（哈希值）</strong>：首先，使用哈希函数（如SHA-256）计算原始数据的摘要（即哈希值）。哈希函数能将任意长度的数据映射到固定长度的哈希值，这个值对于原始数据是唯一的。任何对数据的微小更改都会导致哈希值发生显著变化。</li><li><strong>加密摘要</strong>：然后，数据发送者使用自己的私钥对这个摘要（哈希值）进行加密，生成数字签名。私钥是只有发送者知道的密钥，因此这个过程确保了签名的独特性。</li><li><strong>附加签名发送数据</strong>：加密后的摘要（数字签名）随原始数据一起发送给接收方。接收方收到数据后，可以使用发送者的公钥对数字签名进行解密。</li><li><strong>验证签名</strong>：解密后得到的摘要与接收方用相同哈希函数对收到的原始数据计算出的摘要进行对比。如果两个摘要相匹配，说明数据未被篡改且确实是由持有相应私钥的发送方发送的</li></ol><p><em>3. 数字证书</em></p><ul><li>可以通过哈希算法来保证消息的完整性；</li><li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li></ul><p>但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p><h1 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h1><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是 TLS 握手阶段。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础篇</title>
    <link href="/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p>TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中<strong>途有一个分块丢失或损坏了，只需要重新发送这一个分块</strong>，而不用重新发送整个数据包。</p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p><p>由于传输层的<strong>报文中会携带端口号</strong>，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p>TCP头部包含端口号、序列号、确认号</p></blockquote><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将<strong>传输层的报文作为数据部分</strong>，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是<strong>寻址</strong>起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>除了<strong>寻址</strong>能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><blockquote><p>IP头部包含了源IP地址、目的IP地址以及其他控制信息</p></blockquote><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><h1 id="真实地址查询-——-DNS"><a href="#真实地址查询-——-DNS" class="headerlink" title="真实地址查询 —— DNS"></a>真实地址查询 —— DNS</h1><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><ol><li>客户端向本地DNS服务器发送请求</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。否则去向根DNS服务器发送请求</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，返回 .com 顶级域名服务器地址</li><li>本地DNS服务器收到地址后，向顶级域名服务器发送请求</li><li>顶级域名服务器返回权威DNS服务器地址</li><li>本地DNS服务器向权威DNS服务器发送请求</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><h1 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h1><p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p><p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</p><p>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。<code>流量控制是TCP协议中用来防止发送方过快发送数据导致接收方处理不过来的机制</code></p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。<code>是发送方为了避免网络中的过度拥塞而调整发送速度的机制</code>。</p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><blockquote><p>TCP 报文生成</p></blockquote><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>）。</p><p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p><h1 id="出口-——-网卡"><a href="#出口-——-网卡" class="headerlink" title="出口 —— 网卡"></a>出口 —— 网卡</h1><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="1-HTTP层的数据封装"><a href="#1-HTTP层的数据封装" class="headerlink" title="1. HTTP层的数据封装"></a>1. HTTP层的数据封装</h3><p>HTTP（超文本传输协议）位于OSI模型的应用层，负责定义客户端与服务器之间的请求和响应格式。当你浏览网页时，浏览器（客户端）会通过HTTP协议向服务器发送一个请求。这个请求包含了请求行（例如，<code>GET /index.html HTTP/1.1</code>）、请求头（包含用户代理、接受的内容类型等信息）和请求体（在POST请求中使用）。</p><h3 id="2-TCP层的数据封装"><a href="#2-TCP层的数据封装" class="headerlink" title="2. TCP层的数据封装"></a>2. TCP层的数据封装</h3><p>TCP（传输控制协议）位于传输层，负责在数据发送之前将HTTP数据分割成TCP报文段，并在这些数据到达目的地时重组。TCP为HTTP提供了一种可靠的数据传输服务，确保数据按顺序且完整无误地到达目的地。每个TCP报文段包含了源端口和目的端口信息、序列号（用于确保数据按正确顺序重组）、确认应答号（用于确认接收）以及控制信息（如同步SYN和结束FIN标志）。</p><h3 id="3-IP层的数据封装"><a href="#3-IP层的数据封装" class="headerlink" title="3. IP层的数据封装"></a>3. IP层的数据封装</h3><p>IP（互联网协议）位于网络层，负责将TCP报文段进一步封装成IP数据包，添加上源IP地址和目的IP地址等信息，并通过网络将数据包发送给目的地。IP协议负责寻找从源到目的地的最佳路径，但不保证数据包的顺序或完整性（这是TCP协议的任务）。</p><ul><li>传输层，给应用数据前面增加了 TCP 头；</li><li>网络层，给 TCP 数据包前面增加了 IP 头；</li><li>网络接口层，给 IP 数据包前后分别增加了帧头和帧尾；</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><blockquote><p>操作系统是如何管理虚拟地址与物理地址之间的关系？</p></blockquote><p><strong>内存分段和内存分页</strong></p><h1 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h1><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（*Segmentation*）的形式把这些段分离出来。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/"/>
    <url>/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h1><p>计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，<strong>让内核作为应用连接硬件设备的桥梁</strong>，应用程序只需关心与内核交互，不用关心硬件的细节。、</p><p>内核一般会提供 4 个基本能力</p><ul><li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li><li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li><li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li><li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li></ul><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域：</p><ul><li>内核空间，这个内存空间只有内核程序可以访问；</li><li>用户空间，这个内存空间专门给应用程序使用；‘</li></ul><p>内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD/"/>
    <url>/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="中断是什么"><a href="#中断是什么" class="headerlink" title="中断是什么"></a>中断是什么</h1><p>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</p><h1 id="什么是软中断？"><a href="#什么是软中断？" class="headerlink" title="什么是软中断？"></a>什么是软中断？</h1><p>中断请求的处理程序应该要短且快，这样才能减少对正常进程运行调度地影响，而且中断处理程序可能会暂时关闭中断，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求。</p><p>那 Linux 系统<strong>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</strong>。</p><ul><li><p><strong>上半部用来快速处理中断</strong>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</p></li><li><p><strong>下半部用来延迟处理上半部未完成的工作</strong>，一般以「内核线程」的方式运行。</p></li><li><p>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</p></li><li><p>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；</p></li></ul><blockquote><p>example</p></blockquote><p>网卡收到网络包后，通过 DMA 方式将接收到的数据写入内存，接着会通过<strong>硬件中断</strong>通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来处理该事件，这个事件的处理也是会分成上半部和下半部。</p><p>上部分要做的事情很少，会先禁止网卡中断，避免频繁硬中断，而降低内核的工作效率。接着，内核会触发一个<strong>软中断</strong>，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU/"/>
    <url>/2024/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU/</url>
    
    <content type="html"><![CDATA[<h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><ul><li>寄存器；</li><li>CPU Cache；<ol><li>L1-Cache；</li><li>L2-Cache；</li><li>L3-Cahce；</li></ol></li><li>内存；</li><li>SSD&#x2F;HDD 硬盘</li></ul><p>每个 CPU 核心<strong>都有一块属于自己的 L1 高速缓存</strong>，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。</p><p>L2 高速缓存同样每个 CPU 核心都有，但是 L2 高速缓存位置比 L1 高速缓存距离 CPU 核心 更远，它大小比 L1 高速缓存更大，CPU 型号不同大小也就不同，通常大小在几百 KB 到几 MB 不等，访问速度则更慢，速度在 <code>10~20</code> 个时钟周期。</p><p>L3 高速缓存通常是多个 CPU 核心共用的，位置比 L2 高速缓存距离 CPU 核心 更远，大小也会更大些，通常大小在几 MB 到几十 MB 不等，具体值根据 CPU 型号而定。</p><blockquote><p><strong>L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。</strong></p></blockquote><h1 id="存储器的层次关系"><a href="#存储器的层次关系" class="headerlink" title="存储器的层次关系"></a>存储器的层次关系</h1><p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p><p>比如，CPU Cache 的数<strong>据是从内存加载过来的</strong>，写回数据的时候也<strong>只写回到内存</strong>，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p><h1 id="访问速度"><a href="#访问速度" class="headerlink" title="访问速度"></a>访问速度</h1><p>L1 Cache 的访问延时是 1 纳秒，而内存已经是 100 纳秒了，相比 L1 Cache 速度慢了 <code>100</code> 倍。另外，机械硬盘的访问延时更是高达 10 毫秒，相比 L1 Cache 速度慢了 <code>10000000</code> 倍，差了好几个数量级别。</p><h1 id="CPU-Cache-的数据结构和读取过程"><a href="#CPU-Cache-的数据结构和读取过程" class="headerlink" title="CPU Cache 的数据结构和读取过程"></a>CPU Cache 的数据结构和读取过程</h1><p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为 <strong>Cache Line（缓存块）</strong>。</p><h1 id="如何写出让-CPU-跑得更快的代码？"><a href="#如何写出让-CPU-跑得更快的代码？" class="headerlink" title="如何写出让 CPU 跑得更快的代码？"></a>如何写出让 CPU 跑得更快的代码？</h1><p>访问的数据在 CPU Cache 中的话，意味着<strong>缓存命中</strong>，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快</p><ol><li>对于<strong>数据缓存</strong>，我们在遍历数据的时候，应该按照<strong>内存布局</strong>的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；</li><li>对于<strong>指令缓存</strong>，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率</li><li>对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑<strong>把线程绑定 CPU 到某一个 CPU 核心</strong>。</li></ol><h1 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h1><p>两种针对写入数据的方法：</p><ul><li>写直达（<em>Write Through</em>）</li><li>写回（<em>Write Back</em>）</li></ul><h2 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h2><p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达（*Write Through*）</strong>。</p><p>在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：</p><ul><li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li><li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li></ul><p><strong>问题明显</strong>，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</p><h2 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h2><p>既然写直达由于每次写操作都会把数据写回到内存，而导致影响性能，于是为了要减少数据写回内存的频率，就出现了<strong>写回（*Write Back*）的方法</strong>。</p><p>在写回机制中，<strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。</p><h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><p>要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：</p><ul><li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（*Write Propagation*）</strong>；</li><li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化（*Transaction Serialization*）</strong>。</li></ul><p>要实现<strong>事务串行化</strong>，要做到 2 点：</p><ul><li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li><li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li></ul><h3 id="写传播和事务串行化具体是用什么技术"><a href="#写传播和事务串行化具体是用什么技术" class="headerlink" title="写传播和事务串行化具体是用什么技术"></a>写传播和事务串行化具体是用什么技术</h3><h4 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h4><p>总线嗅探方法很简单， CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。</p><h4 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h4><blockquote><p>基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力</p></blockquote><ul><li><em>Modified</em>，已修改</li><li><em>Exclusive</em>，独占</li><li><em>Shared</em>，共享</li><li><em>Invalidated</em>，已失效</li></ul><p>「已修改」状态就是我们前面提到的<strong>脏标记</strong>，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。</p><p>「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。</p><p>「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。</p><p>[独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，<strong>独占状态下的数据就会变成共享状态。</strong></p><p>「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</p><h1 id="解决伪共享"><a href="#解决伪共享" class="headerlink" title="解决伪共享"></a>解决伪共享</h1><h3 id="缓存行大小对齐"><a href="#缓存行大小对齐" class="headerlink" title="缓存行大小对齐"></a>缓存行大小对齐</h3><p>缓存行对齐是指在设计数据结构时，确保它们的起始地址与缓存行的大小对齐。这意味着数据结构的起始地址是缓存行大小（例如，64字节）的整数倍。</p><p><strong>目的</strong>：通过这种方式，可以确保数据结构不会跨越多个缓存行。这有助于减少缓存行的加载和替换操作，因为整个数据结构可以通过单次缓存行加载操作被完整地加载到缓存中，提高了访问效率。</p><p><strong>实现</strong>：在多数编程语言中，可以通过特定的关键字或属性（如C&#x2F;C++中的<code>__attribute__((aligned(N)))</code>）来指定变量或数据结构的对齐。</p><h3 id="字节填充（Padding）"><a href="#字节填充（Padding）" class="headerlink" title="字节填充（Padding）"></a>字节填充（Padding）</h3><p>字节填充是在数据结构中故意添加额外的字节，以改变其大小，使其更好地与缓存行边界对齐。</p><p><strong>目的</strong>：这种方法主要用于避免“伪共享”（False Sharing）。伪共享发生在多线程程序中，当不同线程在同一缓存行上操作不同的变量时，即使这些变量不直接相关，它们的更新也可能导致不必要的缓存同步操作。通过添加填充，可以确保频繁修改的变量不会位于同一缓存行，减少缓存无效化的次数，提高程序性能。</p><p>假设有一个结构体，包含几个整型变量，而且我们知道缓存行大小是64字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Example</span> &#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-comment">// 填充以确保a单独占用一个缓存行</span><br>    <span class="hljs-type">char</span> padding[<span class="hljs-number">60</span>];<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，通过在<code>a</code>和<code>b</code>之间添加60个字节的填充，确保<code>a</code>和<code>b</code>分别位于不同的缓存行中。这样，在多线程环境下，如果不同线程分别修改<code>a</code>和<code>b</code>，它们的操作就不会因为伪共享而互相影响性能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql面试题</title>
    <link href="/2024/02/28/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/"/>
    <url>/2024/02/28/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql/</url>
    
    <content type="html"><![CDATA[<p>mysql为什么要用B+树而不用B树</p><p>B+树的查询的时间复杂度是多少</p><p>聚簇索引和非聚簇索引区别</p><p>聚簇索引和非聚簇索引是如何优化查询的</p><p>覆盖索引是什么</p><p>四种隔离级别是什么，分别解决什么问题</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络面试题</title>
    <link href="/2024/02/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/02/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>TCP 为什么三次握手</p><p>TCP 断开连接的时候的timewait和closewait讲述</p><p>http请求返回的cookie是如何设置进去的</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法面试题</title>
    <link href="/2024/02/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2024/02/28/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><p>两个链表，在某个节点相遇，给定两个头节点，在<code>空间复杂度O(1)</code>的条件下找到相遇节点</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>初始化<code>cur1=head1，cur2=head2</code>,然后执行下面的循环，循环退出的时候<code>cur1=cur2</code>，此时为答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cur1!=cur2)&#123;<br>    <br>    <span class="hljs-keyword">if</span>(cur1-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>    cur1=cur1-&gt;next;<br>    <span class="hljs-keyword">else</span> cur1=head2;<br>    <br>    <span class="hljs-keyword">if</span>(cur2-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        cur2=cur2-&gt;next;<br>    <span class="hljs-keyword">else</span> cur2=head1;    <br>&#125;<br>ans=cur1;<br><span class="hljs-comment">//第一次相遇的时候为答案</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务篇</title>
    <link href="/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E7%AF%87/"/>
    <url>/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h1><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h1 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h1><ol><li>脏读：一个事务读到了另一个事务未提交的数据</li><li>不可重复读:一个事务读到了另一个事务**已经提交(update)**的数据。引发另一个事务，在事务中的多次查询结<br> 果不一致。</li><li>虚读 &#x2F;幻读:一个事务读到了另一个事务**已经插入(insert)**的数据。导致另一个事务，在事务中多次查询的结果不一致。</li><li>丢失更新的问题!</li></ol><h1 id="隔离级别（四种）"><a href="#隔离级别（四种）" class="headerlink" title="隔离级别（四种）"></a>隔离级别（四种）</h1><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><blockquote><p>这四种隔离级别具体是如何实现的呢？</p></blockquote><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li></ul><h1 id="事务并发问题解方案"><a href="#事务并发问题解方案" class="headerlink" title="事务并发问题解方案"></a>事务并发问题解方案</h1><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了）</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h1 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h1><h2 id="Read-View-有四个重要的字段："><a href="#Read-View-有四个重要的字段：" class="headerlink" title="Read View 有四个重要的字段："></a>Read View 有四个重要的字段：</h2><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><blockquote><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p></blockquote><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><h2 id="可重复读的工作原理"><a href="#可重复读的工作原理" class="headerlink" title="可重复读的工作原理"></a>可重复读的工作原理</h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><h2 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><h1 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h1><ol><li><h3 id="快照读-Snapshot-Read"><a href="#快照读-Snapshot-Read" class="headerlink" title="快照读 (Snapshot Read)"></a>快照读 (Snapshot Read)</h3><ul><li><strong>定义</strong>：快照读是指读取的是数据的某个历史版本，这个版本对于启动读操作的事务是一致的，即使其他事务提交了新的更改，这些更改也不会影响到当前事务看到的数据。在MySQL的InnoDB存储引擎中，这通过多版本并发控制（MVCC）来实现。</li><li><strong>场景</strong>：普通的<code>SELECT</code>操作，不包括任何锁定语句（如<code>FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>）。</li></ul></li><li><h3 id="当前读-Current-Read"><a href="#当前读-Current-Read" class="headerlink" title="当前读 (Current Read)"></a>当前读 (Current Read)</h3><ul><li><strong>定义</strong>：当前读是指读取的是数据的最新版本，包括其他事务已经提交的更改。当前读操作通常涉及锁定，以防止其他事务并发地修改同一数据。</li><li><strong>场景</strong>：<code>SELECT ... FOR UPDATE</code>、<code>SELECT ... LOCK IN SHARE MODE</code>、<code>UPDATE</code>、<code>DELETE</code>等。</li></ul></li></ol><h1 id="基于锁的并发控制LBCC"><a href="#基于锁的并发控制LBCC" class="headerlink" title="基于锁的并发控制LBCC"></a>基于锁的并发控制LBCC</h1><h1 id="基于版本的并发控制MVCC"><a href="#基于版本的并发控制MVCC" class="headerlink" title="基于版本的并发控制MVCC"></a>基于版本的并发控制MVCC</h1><h3 id="（A）undo-log"><a href="#（A）undo-log" class="headerlink" title="（A）undo log"></a>（A）undo log</h3><ul><li><p>insert undo log</p></li><li><p>update undo log :</p></li></ul><h3 id="（B）ReadView"><a href="#（B）ReadView" class="headerlink" title="（B）ReadView"></a>（B）ReadView</h3><ul><li><p>什么星ReadView?</p></li><li><p>ReadView怎么产生，什么时候生成</p></li><li><p>如何判断可见性?</p></li></ul><h3 id="（C）-ReadView案例分析案例"><a href="#（C）-ReadView案例分析案例" class="headerlink" title="（C） ReadView案例分析案例"></a>（C） ReadView案例分析案例</h3><ul><li>读已提交RC案</li><li>可重复读RR</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>MVCC指在使用RC、RR隔离级别下，使不同事务的读-写、写-读操作并发执行，提升系统性能。MVCC核心思想是读不加锁，读写不冲突，</li><li>RC、RR这两个隔离级别的一个很大不同就是生成Readview的时机不同:<ul><li>RC在每一次进行普通 SELECT操作前都会生成一个<code>Readview</code>，</li><li>RR在第一次进行普通 SELECT操作前生成一个<code>Readview</code>，之后的查询操作都重复这个Readview。</li></ul></li></ol><h1 id="事务回滚与数据恢复"><a href="#事务回滚与数据恢复" class="headerlink" title="事务回滚与数据恢复"></a>事务回滚与数据恢复</h1><p>事务的隔离级别是由MVCC和锁实现。<br>事务的持久性主要是通过redolog、undolog和Force Log at Commit机制机制来完成的。</p><ul><li>Force Log at Commit机制保证事务提交后redo log日志都已经持久化。</li><li>undo log用于对事务的影响进行撤销，也可用于多版本控制。</li><li>redo log用于在崩溃时恢复数据，事务回滚和数据恢复是如何实现的呢?</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql架构篇</title>
    <link href="/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%9E%B6%E6%9E%84%E7%AF%87/"/>
    <url>/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%9E%B6%E6%9E%84%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/485523251/answer/3354411600">参考文章</a></p><h1 id="mysql日志系统-等待完成"><a href="#mysql日志系统-等待完成" class="headerlink" title="mysql日志系统[等待完成]"></a>mysql日志系统[等待完成]</h1><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><h2 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h2><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h1 id="mysql分层"><a href="#mysql分层" class="headerlink" title="mysql分层"></a>mysql分层</h1><p><code>MySQL分为两层：Server层 和 存储引擎层</code></p><blockquote><p>server 层</p></blockquote><p>负责建立和维护客户端连接、<code>SQL分析</code>、<code>权限校验</code>、<code>SQL执行</code>等功能。</p><p>主要功能模块:<code> 连接器—&gt;查询缓存—&gt;分析器—&gt;预处理器—&gt;优化器—&gt;执行器等。</code></p><p> 还包括其他跨存储引擎的功能，比如函数、存储过程、触发器等。</p><blockquote><p>存储引擎层</p></blockquote><p>目前MySQL支持的存储引擎有 InnoDB、MyISAM、Memory 等。</p><p>索引、锁（部分，比如行锁）、事务等功能都是由存储引擎实现的。</p><h1 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h1><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -h$IP -P$port -u$USER -p<br><br>-- 当你通过上面方式去连接MySQL的时候，由于MySQL是基于TCP协议进行传输数据的，所以会先经历TCP三次握手。当TCP连接建立以后，MySQL会校验你的密码是否正确，如果密码错误你会收到如下错误：<br><br>MySQL Error 1045: Access denied for user &#x27;root&#x27;@&#x27;127.0.0.1&#x27; (using password: YES)<br><br>-- 密码校验通过之后，紧接着会去权限表查询当前用户的权限，然后将权限保存在内存中，方面下次SQL交互时进行权限验证。<br></code></pre></td></tr></table></figure><blockquote><p>注意：因为在连接建立时MySQL就把<strong>用户权限</strong>查询到内存中了，并且后续的请求权限校验都是在内存中进行的。所以当连接建立以后即使更改了当前用户的权限，也不会影响当前用户已经建立的连接。</p></blockquote><h3 id="查看有多少连接"><a href="#查看有多少连接" class="headerlink" title="查看有多少连接"></a>查看有多少连接</h3><p>通过<code>show processlist ;</code> 语句查询目前有多少存在连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show processlist ;<br>+----+------+-----------+------+---------+------+----------+------------------+<br>| Id | User | Host      | db   | Command | Time | State    | Info             |<br>+----+------+-----------+------+---------+------+----------+------------------+<br>|  2 | root | localhost | NULL | Sleep   |   35 |          | NULL             |<br>|  3 | root | localhost | NULL | Query   |    0 | starting | show processlist |<br>+----+------+-----------+------+---------+------+----------+------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p>其中<code>Command</code>列为<code>Sleep</code> 值，就表示是一个空闲连接，<code>Time</code>列的值表示空闲了多长时间。</p></blockquote><hr><p><strong>以下是mysql服务端如何主动关闭连接</strong></p><h3 id="手动关闭连接"><a href="#手动关闭连接" class="headerlink" title="手动关闭连接"></a>手动关闭连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; kill connection +2;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="自动关闭连接"><a href="#自动关闭连接" class="headerlink" title="自动关闭连接"></a>自动关闭连接</h3><p>MySQL主动断开连接，由参数 <code>wait_timeout</code> 控制，默认是8小时，当一个连接空闲时间超过<code>wait_timeout</code> 时，MySQL就会主动断开这个连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;wait_timeout&#x27;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| wait_timeout  | 28800 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p>MySQL主动断开的连接不会通知客户端，只是当客户端使用该连接重新操作时会收到如下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show databases;<br>ERROR 2006 (HY000): MySQL server has gone away<br>No connection. Trying to reconnect...<br>Connection id:    6<br></code></pre></td></tr></table></figure></blockquote><h3 id="MySQL连接上限"><a href="#MySQL连接上限" class="headerlink" title="MySQL连接上限"></a>MySQL连接上限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;max_connections&#x27;</span>;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;max_connections&#x27;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 151   |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p>当超过最大连接数时，系统会拒绝新的连接请求，并响应错误<code>Too many connections</code> 。</p></blockquote><h3 id="长连接-和-短连接"><a href="#长连接-和-短连接" class="headerlink" title="长连接 和 短连接"></a>长连接 和 短连接</h3><p>MySQL的连接是基于TCP协议的，并且建立连接后会把用户权限查询到内存中，如果我们每执行一条SQL就重新创建连接的话是非常消耗资源的，所以<code>推荐使用长连接</code></p><blockquote><p>MySQL在执行查询过程中使用的内存并不是查询结束就清理了，而是在断开连接的时候才会释放内存。所以如果长连接过多可能会导致MySQL内存占用过大，然后被系统强制杀掉，现象就是MySQL异常重启。</p></blockquote><h3 id="解决长连接占用内存问题"><a href="#解决长连接占用内存问题" class="headerlink" title="解决长连接占用内存问题"></a>解决长连接占用内存问题</h3><p>1：定期断开长连接。既然在断开连接的时候MySQL会释放内存，那我们只需要定期去清理那些空闲的长连接就行了。</p><p>2：MySQL 5.7 以后提供了一个重置连接的函数<code>mysql_reset_connection()</code> ，这个函数不会断开重新连接，而是将连接重置到刚建立连接时的状态。所以我们可以在执行完一个大操作以后，调用一下这个函数。</p><blockquote><p>注意，这个函数是编程语言去调用</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>建立和维护客户端的连接</li><li>建立连接时会将用户权限读取到内存中，后续校验权限的时候从内存中获取权限，所以更改用户权限不会对已经建立好的连接生效。</li><li>一般情况下建议使用长连接，避免频繁的创建连接和校验权限。但是要注意长连接内存占用问题，要么定期清理空闲的长连接，要么执行大操作以后调用<code>mysql_reset_connection()</code> 函数</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>查询缓存功能在MySQL 8.0以后已经没有了</p><p>当咱们通过连接器建立连接以后，接下来就是执行SQL了。如果SQL是查询语句，MySQL会先查询缓存。如果命中缓存，在返回数据<code>之前</code>会做一次权限校验，<code>权限校验通过以后</code>把数据返回给客户端。</p><p>如果没有命中缓存，则会继续往下执行，当拿到结果以后会将结果放进缓存。SQL作为缓存的key，结果作为缓存的value。</p><h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><ol><li><p>为什么在返回数据之前做权限校验？</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为查询缓存是所有用户所有连接共享的。有可能用户A对表t有查询权限，但是用户B没有，所以需要做权限校验。<br></code></pre></td></tr></table></figure></li><li><p>为什么不在查询缓存之前做?</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为在查询缓存之前没有经过分析器，MySQL这时候是无法识别出表和字段，所以也就无法做权限校验。<br></code></pre></td></tr></table></figure></li><li><p>为什么MySQL要删除查询缓存功能？</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">因为查询缓存失效非常频繁，只要对表有更新，无论是数据更新还是表结构更新，都会导致该表的所有缓存被清空。<br></code></pre></td></tr></table></figure></li></ol><p>手动关闭查询缓存后，也可以在查询的时候使用<code>SQL_CACHE</code>显示指定使用查询缓存。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select SQL_CACHE id from t where id &gt; 1;<br></code></pre></td></tr></table></figure><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>主要有两个功能：<code>词法分析</code> 和 <code>语法分析</code>。</p><p><code>词法分析</code>就是把SQL根据空格拆分成一个个字符串，然后识别出每个字符串代表什么。example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id from t where id &gt; 1;<br></code></pre></td></tr></table></figure><p>MySQL会将<code>select</code> <code>from</code> <code>where</code>识别为语法关键字，从而得知这条SQL是一条查询语句；把<code>id</code> 识别为需要查询的表字段；<code>t</code> 识别为表名；</p><p><code>语法分析</code>会把上面解析出来的结果，根据语法规则检查SQL语句是否正确，如果SQL错误就会收到错误提示。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ERROR: 1064: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;form user&#x27; at line 1<br></code></pre></td></tr></table></figure><blockquote><p>表不存在或者字段不存在，不是在解析器里做的</p></blockquote><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>这时候MySQL会做一些预处理操作，其中包括<code>检查表和字段是否存在</code>，以及<code>权限校验。</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from tt;<br>ERROR 1146 (42S02): Table &#x27;gin.tt&#x27; doesn&#x27;t exist<br></code></pre></td></tr></table></figure><p>校验完表和字段以后，这里MySQL已经拿到表和字段信息了，所以接着会做一次权限校验，检查用户对表或者字段是否有操作权限。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id, name, age from user where name = &#x27;hello&#x27; and age &lt; 18;<br></code></pre></td></tr></table></figure><p>如果表中有两个索引，一个是<code>name</code>字段的索引，还有一个<code>(name, age)</code>的组合索引，优化器会选择使用哪个索引？还是使用全表扫描？选择索引，这就是优化器的作用。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>在开始执行之前，MySQL还有再做一次<code>权限校验</code>。确保用户对本次操作所涉及的所有表有操作权限。</p><blockquote><p>为什么要再做一次权限校验</p></blockquote><p>虽然在预处理器阶段已经做了权限校验了，但是某些操作可能在预处理阶段是无法知道的，比如触发器。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>一条SQL语句执行步骤：</p><ol><li>连接器：建立和维护连接、校验用户信息（密码、登录权限、主机权限）。</li><li>查询缓存：使用SQL语句为key查询value为结果，如果命中缓存还会校验权限（8.0以后没了）。</li><li>分析器(<code>解析sql</code>）：词法分析和语法分析，把SQL语句拆分得到关键字、表名、字段等信息，然后根据语法规则校验语法是否正确。</li><li>预处理器（<code>执行sql</code>）：检查表和字段是否存在，以及校验用户对表和字段是否有操作权限。</li><li>优化器（<code>执行sql</code>）：选择索引，以及多表join时，选择join顺序。</li><li>执行器（<code>执行sql</code>）：校验用户对操作所有涉及的表是否有权限（包括触发器涉及的表），调用存储引擎的接口操作数据，将操作结果返回客户端。</li></ol><h1 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h1><ol><li>采用的是<code>插拔式</code>的插件方式；</li><li>存储引擎是指定在表之上的，即<code>一个库中的每一个表都可以指定选择存储引擎</code>；</li><li>不管表采用什么样的存储引擎，都会在数据区，产生对应的一个<code>.frm</code>文件（表结构定义描述文件）</li></ol><h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines;<br></code></pre></td></tr></table></figure><h2 id="查看数据文件位置"><a href="#查看数据文件位置" class="headerlink" title="查看数据文件位置"></a>查看数据文件位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#x27;datadir&#x27;;<br><br>+---------------+-----------------+<br>| Variable_name | Value           |<br>+---------------+-----------------+<br>| datadir       | /var/lib/mysql/ |<br>+---------------+--------<br></code></pre></td></tr></table></figure><h2 id="查看表数据文件位置"><a href="#查看表数据文件位置" class="headerlink" title="查看表数据文件位置"></a>查看表数据文件位置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">root@LAPTOP-HI3T64V4:/var/lib/mysql/test# pwd<br>/var/lib/mysql/test   -- 数据库test的所有表存放目录<br><br><br>root@LAPTOP-HI3T64V4:/var/lib/mysql/test# ls -l<br>total 112<br>-rw-r----- 1 mysql mysql    65 Feb 28 13:27 db.opt<br>-rw-r----- 1 mysql mysql  8556 Feb 28 13:28 user.frm<br>-rw-r----- 1 mysql mysql 98304 Feb 28 13:28 user.ibd<br></code></pre></td></tr></table></figure><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><blockquote><p>在 MySQL 5.5 及以后版本后，MySQL 选择使用 InnoDB为默认存储引擎。在创建数据库表时，不指定存储引擎时，使用的就是 InnoDB。如需使用其他存储引擎，可以手动来指定。</p></blockquote><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>InnoDB 支持事务操作；（每一条SQL都默认封装成事务，自动提交，会影响速度）</li><li>InnoDB 支持外键；</li><li>InnoDB 是聚集索引（聚簇索引）；</li><li>InnoDB 不保存表的总条数；</li><li>InnoDB 5.7版本之前不支持全文检索；</li><li>InnoDB 支持表级锁、行级锁，默认为行级锁；</li><li>InnoDB 表必须有主键（如果我们没有明确去指定创建主键索引。它会帮我们隐藏的生成一个 6 byte 的 int 型的索引作为主键索引）；</li><li>InnoDB 文件存储方式为.frm文件存储表结构，ibd文件存储数据内容。</li></ol><h3 id="聚簇索引（Clustered-Index）"><a href="#聚簇索引（Clustered-Index）" class="headerlink" title="聚簇索引（Clustered Index）"></a>聚簇索引（Clustered Index）</h3><ul><li><strong>数据存储</strong>: 在聚簇索引中，表中的数据行物理上按索引键（Key）的顺序存储。这意味着，聚簇索引的叶子节点直接包含了表中的数据行。因此，在一个表中，只能有一个聚簇索引，因为你不能以两种不同的顺序来物理存储同一组数据行。</li><li><strong>主键索引</strong>: 在 InnoDB 存储引擎中，聚簇索引通常就是表的主键索引。如果表定义了主键，InnoDB 就会使用这个主键作为聚簇索引；如果没有定义主键，MySQL 会选择一个唯一索引代替；如果这些都不存在，MySQL 会生成一个隐藏的唯一ID作为聚簇索引。</li><li><strong>性能优势</strong>: 聚簇索引能提供快速的数据访问速度，因为索引搜索可以直接定位到包含数据的叶子节点。对于按索引顺序的扫描操作，聚簇索引也非常高效。</li><li><strong>更新成本</strong>: 由于数据是按照聚簇索引的顺序存储的，因此在插入或更新数据时，如果需要改变数据的物理顺序，这可能导致数据页的分裂或合并，增加了维护索引的成本。</li></ul><h3 id="非聚簇索引（Non-Clustered-Index）"><a href="#非聚簇索引（Non-Clustered-Index）" class="headerlink" title="非聚簇索引（Non-Clustered Index）"></a>非聚簇索引（Non-Clustered Index）</h3><ul><li><strong>数据存储</strong>: 非聚簇索引的叶子节点并不直接存储数据行。相反，它们包含索引键和对应数据行的指针（在 InnoDB 中是主键的值），这意味着非聚簇索引需要通过索引键找到主键，然后再通过主键定位到实际的数据行。</li><li><strong>多个索引</strong>: 一个表可以拥有多个非聚簇索引，因为它们不影响数据的物理存储顺序。</li><li><strong>辅助索引</strong>: 在 InnoDB 中，非聚簇索引有时也被称为辅助索引（Secondary Index）。它们为数据提供了另一种检索路径，有助于提高查询的性能，尤其是对那些不涉及聚簇索引键的查询。</li></ul><h3 id="frm-和-ibd-格式文件介绍-frm-和-ibd-格式文件介绍"><a href="#frm-和-ibd-格式文件介绍-frm-和-ibd-格式文件介绍" class="headerlink" title=".frm 和 .ibd 格式文件介绍.frm 和 .ibd 格式文件介绍"></a>.frm 和 .ibd 格式文件介绍.frm 和 .ibd 格式文件介绍</h3><p><code>.frm 文件</code></p><ul><li><strong>作用</strong>：<code>.frm</code> 文件用于存储表的<strong>结构定义信息</strong>。这包括了表的列定义（比如列名、数据类型）、索引信息、表的约束（如主键、外键约束）等元数据信息。</li><li><strong>每个表一个</strong>：在 MySQL 中，每个表都会有一个对应的 <code>.frm</code> 文件来描述该表的结构。</li><li><strong>版本兼容性</strong>：<code>.frm</code> 文件的格式设计得相对独立，这意味着即使在不同版本的 MySQL 之间迁移数据，只要 <code>.frm</code> 文件没有损坏，就能被识别和使用。</li></ul><p> <code>.ibd 文件</code></p><ul><li><strong>作用</strong>：<code>.ibd</code> 文件是 InnoDB 存储引擎的表空间文件，用于存储表的<strong>实际数据和索引数据</strong>。这包括了行数据、B+树索引等。</li><li><strong>文件格式</strong>：<code>.ibd</code> 文件是 InnoDB 特有的，它支持 InnoDB 的高级特性，如事务、行级锁定、外键等。</li><li><strong>表空间配置</strong>：默认情况下，InnoDB 存储引擎会为每个表创建一个独立的 <code>.ibd</code> 文件（这是在 MySQL 5.6.6 以后的版本中引入的“文件-每表”表空间模式）。但是，也可以配置 InnoDB 使用共享表空间模式，这种情况下，多个表的数据可能存储在同一个 <code>.ibd</code> 文件或几个 <code>.ibd</code> 文件中。</li></ul><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><a href="https://blog.csdn.net/weixin_43935927/article/details/113982766?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170910717316800186586670%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170910717316800186586670&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-113982766-null-null.142%5Ev99%5Epc_search_result_base3&utm_term=innodb%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4187">参考文章</a></p><h3 id="缓冲池Buffer-Pool"><a href="#缓冲池Buffer-Pool" class="headerlink" title="缓冲池Buffer Pool"></a>缓冲池Buffer Pool</h3><p> InnoDB使用了一种缓冲池的技术，也就是把磁盘读到的<code>页</code>放到一块内存区域里面。这个内存区域就叫Buffer Pool。</p><p>修改数据的时候，先修改缓冲池里面的页。<code>内存的数据页和磁盘数据不一致的时候，我们把它叫做脏页</code>。InnoDB里面有专门的后台线程把Buffer Pool的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p><h3 id="修改缓冲-Change-Buffer"><a href="#修改缓冲-Change-Buffer" class="headerlink" title="修改缓冲 Change Buffer"></a>修改缓冲 Change Buffer</h3><p>如果这个数据页不是唯一索引（注：唯一索引就是在同一字段下不能有相同值），也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓冲池中，从而提升更新语句（Insert、Delete、Update）的执行速度。</p><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>InnoDB会根据访问的频率和模式，为热点页建立哈希索引，来提高查询效率。InnoDB存储引擎会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引，所以叫做自适应哈希索引。</p><h3 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h3><p>MySQL 在更新数据时，为了减少磁盘的随机 IO，因此并不会直接更新磁盘上的数据，而是先更新 Buffer Pool 中缓存页的数据，等到合适的时间点，再将这个缓存页持久化到磁盘。而 Buffer Pool 中所有缓存页都是处于内存当中的，当 MySQL 宕机或者机器断电，内存中的数据就会丢失，因此 MySQL 为了防止缓存页中的数据在更新后出现数据丢失的现象，引入了 redo log 机制。</p><p>当进行增删改操作时，MySQL 会在更新 Buffer Pool 中的缓存页数据时，会记录一条对应操作的 redo log 日志，这样如果出现 MySQL 宕机或者断电时，如果有缓存页的数据还没来得及刷入磁盘，那么当 MySQL 重新启动时，可以根据 redo log 日志文件，进行数据重做，将数据恢复到宕机或者断电前的状态，保证了更新的数据不丢失，因此 redo log 又叫做重做日志。它的本质是保证事务提交后，更新的数据不丢失。——用它来实现事务的持久性。</p><h2 id="磁盘文件表空间-等待完成"><a href="#磁盘文件表空间-等待完成" class="headerlink" title="磁盘文件表空间 [等待完成]"></a>磁盘文件表空间 [等待完成]</h2><p><a href="https://blog.csdn.net/u010647035/article/details/105009979?ops_request_misc=&request_id=&biz_id=102&utm_term=mysql%20%20%E7%A3%81%E7%9B%98%E8%A1%A8%E7%A9%BA%E9%97%B4&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-105009979.142%5Ev99%5Epc_search_result_base3&spm=1018.2226.3001.4187">参考文章</a></p><h3 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h3><p>共享表空间是由<code>ibdata1</code>文件（或者配置中指定的其他文件）表示的，它是系统的默认设置，在这种配置下，所有InnoDB表的数据和索引会被存储在一个共享的文件中。这种设计在早期版本的MySQL中更常见。共享表空间的优点是简化了文件管理，但它也有缺点，如恢复单个表变得更复杂，而且随着数据的增加，<code>ibdata1</code>文件可能会变得非常大，并且即使删除了数据，文件大小也不会减小。</p><h3 id="独占表空间"><a href="#独占表空间" class="headerlink" title="独占表空间"></a>独占表空间</h3><p>独占表空间是指每个InnoDB表都使用自己的<code>.ibd</code>文件来存储数据和索引的配置。这是通过设置<code>innodb_file_per_table</code>参数为1来实现的，从MySQL 5.6.6版本开始，这个参数的默认值就是1。独占表空间提供了更好的数据管理灵活性，如更易于表级别的备份和恢复，以及更高效的磁盘空间使用，因为删除表会立即回收空间。</p><h2 id="磁盘文件存储结构"><a href="#磁盘文件存储结构" class="headerlink" title="磁盘文件存储结构"></a>磁盘文件存储结构</h2><p>从 InnoDB 逻辑存储结构来看，所有的数据都被逻辑的存放在一个空间中，这个空间就叫做表空间（tablespace）。表空间有 段（segment）、区（extent）、页（page）组成。</p><p>2.1、段（segment）<br>段(Segment)分为索引段，数据段，回滚段等。其中索引段就是非叶子结点部分，而数据段就是叶子结点部分，回滚段用于数据的回滚和多版本控制。一个段包含256个区(256M大小)。</p><p>2.2、区（extent）<br>区是页的集合，一个区包含64个连续的页，默认大小为 1MB (64*16K)。</p><p>2.3、页（page）<br>页是 InnoDB 管理的最小单位，常见的有 FSP_HDR，INODE, INDEX 等类型。所有页的结构都是一样的，分为文件头(前38字节)，页数据和文件尾(后8字节)。页数据根据页的类型不同而不一样。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><h2 id="内存数据落盘-等待完成"><a href="#内存数据落盘-等待完成" class="headerlink" title="内存数据落盘[等待完成]"></a>内存数据落盘[等待完成]</h2><ol><li><p>改内存:  通过事务，修改内存的数据，形成脏页。</p><blockquote><p>日志记录完整修改的过程。事务提交，必须将记录的日志顺序写入磁盘!</p></blockquote></li><li><p>CheckPoint:同步内存的脏页到磁盘的数据机制</p></li></ol><p>日志写道磁盘中不是IO么？？为什么他就没事，其他写道磁盘就必须用检查点机制?</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql基础篇</title>
    <link href="/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2024/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -uroot -p123456<br></code></pre></td></tr></table></figure><h2 id="重置密码步骤-linux"><a href="#重置密码步骤-linux" class="headerlink" title="重置密码步骤(linux)"></a>重置密码步骤(linux)</h2><h3 id="1-停止-MySQL-服务"><a href="#1-停止-MySQL-服务" class="headerlink" title="1.停止 MySQL 服务"></a>1.停止 MySQL 服务</h3><p>首先，你需要停止正在运行的 MySQL 服务。这个步骤根据你的操作系统会有所不同。</p><ul><li><p><strong>对于 Linux 系统</strong>，可以使用以下命令之一，具体取决于你的系统管理工具：</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">bashCopy codesudo systemctl <span class="hljs-literal">stop</span> mysql<br><span class="hljs-comment"># 或者</span><br>sudo /etc/init.d/mysql <span class="hljs-literal">stop</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-启动-MySQL-无密码模式"><a href="#2-启动-MySQL-无密码模式" class="headerlink" title="2. 启动 MySQL 无密码模式"></a>2. 启动 MySQL 无密码模式</h3><p>接下来，你需要以无密码模式启动 MySQL。这允许你以 root 用户身份登录而不需要密码，从而可以重置丢失的密码。</p><ul><li><p><strong>对于 Linux</strong>，启动 MySQL 时添加 <code>--skip-grant-tables</code> 参数：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mysqld_safe --skip-grant-tables &amp;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-重置密码"><a href="#3-重置密码" class="headerlink" title="3. 重置密码"></a>3. 重置密码</h3><p>现在，你可以登录到 MySQL 服务器而不需要密码，然后重置密码。</p><ol><li><p>登录到 MySQL：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root<br></code></pre></td></tr></table></figure></li><li><p>选择 MySQL 数据库：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE mysql;<br></code></pre></td></tr></table></figure></li><li><p>更新 root 用户的密码。根据你的 MySQL 版本，命令可能略有不同：</p><ul><li><p><strong>MySQL 5.7 及以前版本</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE user SET password=PASSWORD(&quot;新密码&quot;) WHERE User=&#x27;root&#x27;;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p><strong>MySQL 5.7.6 及之后版本</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p><strong>MariaDB</strong> 可能也支持 <code>ALTER USER</code> 或需要使用 <code>UPDATE</code> 语句。</p></li></ul></li><li><p>退出 MySQL：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">quit<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-重启-MySQL-服务"><a href="#4-重启-MySQL-服务" class="headerlink" title="4. 重启 MySQL 服务"></a>4. 重启 MySQL 服务</h3><p>最后，停止无密码模式下运行的 MySQL 服务，然后正常启动 MySQL 服务。</p><ul><li><p><strong>对于 Linux</strong>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl stop mysqld<br>sudo systemctl start mysql<br><span class="hljs-comment"># 或者使用 /etc/init.d/mysql stop 和 start</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="更改密码（已知密码）"><a href="#更改密码（已知密码）" class="headerlink" title="更改密码（已知密码）"></a>更改密码（已知密码）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 需要先进入数据库<br><br>-- 这里把数据库登录密码改为111111<br>alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;111111&#x27;; <br>  <br>-- 账号和地址不带引号也可以  <br>alter user root@localhost identified by &#x27;88888888&#x27; ;   <br></code></pre></td></tr></table></figure><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>MySQL 数据库乱码问题通常是由于字符集设置不一致导致的。解决这个问题通常涉及检查和设置数据库、表或连接的字符集和排序规则（collation）。</p><h3 id="检查当前的字符集设置"><a href="#检查当前的字符集设置" class="headerlink" title="检查当前的字符集设置"></a>检查当前的字符集设置</h3><p>首先，你需要检查 MySQL 的当前字符集和排序规则设置。可以使用以下命令查看全局、数据库级别和表级别的字符集和排序规则设置：</p><ul><li><p><strong>查看全局字符集和排序规则</strong>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;character_set_%&#x27;;<br>SHOW VARIABLES LIKE &#x27;collation_%&#x27;;<br></code></pre></td></tr></table></figure></li><li><p><strong>查看特定数据库的字符集和排序规则</strong>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME<br>FROM information_schema.SCHEMATA<br>WHERE SCHEMA_NAME = &#x27;your_database_name&#x27;;<br></code></pre></td></tr></table></figure></li><li><p><strong>查看特定表的字符集和排序规则</strong>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CCSA.character_set_name AS &#x27;Charset&#x27;, CCSA.collation_name AS &#x27;Collation&#x27;<br>FROM information_schema.`TABLES` T,<br>     information_schema.`COLLATION_CHARACTER_SET_APPLICABILITY` CCSA<br>WHERE CCSA.collation_name = T.table_collation<br>  AND T.table_schema = &quot;your_database_name&quot;<br>  AND T.table_name = &quot;your_table_name&quot;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-设置字符集"><a href="#2-设置字符集" class="headerlink" title="2. 设置字符集"></a>2. 设置字符集</h3><p>如果你发现字符集设置不正确，你可以通过以下方式进行调整：</p><ul><li><p><strong>设置数据库的默认字符集</strong>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure></li><li><p><strong>修改现有数据库的字符集</strong>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER DATABASE 数据库名 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure></li><li><p><strong>设置表的字符集</strong>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-设置连接字符集"><a href="#3-设置连接字符集" class="headerlink" title="3. 设置连接字符集"></a>3. 设置连接字符集</h3><p>当你的应用程序连接到 MySQL 服务器时，确保连接使用的字符集也是正确的。这可以通过在连接字符串中设置字符集来实现，具体方法取决于你使用的编程语言和数据库驱动。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>字符集选择</strong>：<code>utf8mb4</code>是一个好的通用选择，因为它支持所有Unicode字符，包括表情符号。如果你的应用不需要这么广泛的字符支持，你可以选择其他字符集，但最好保持数据库、表和连接字符集的一致性。</li><li><strong>备份数据</strong>：在对数据库或表进行字符集更改之前，务必备份你的数据，以避免潜在的数据丢失。</li><li><strong>测试更改</strong>：在生产环境应用任何更改之前，先在测试环境中进行测试，以确保更改不会导致应用程序中出现问题。</li></ul><h2 id="数据库的备份和恢复"><a href="#数据库的备份和恢复" class="headerlink" title="数据库的备份和恢复"></a>数据库的备份和恢复</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h4 id="使用-mysqldump-工具"><a href="#使用-mysqldump-工具" class="headerlink" title="使用 mysqldump 工具"></a>使用 <code>mysqldump</code> 工具</h4><p><code>mysqldump</code> 是 MySQL 自带的一个非常实用的工具，用于创建数据库的一份物理备份。</p><ul><li><p><strong>备份整个数据库</strong>:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -u [username] -p[password] [database_name] &gt; [backup_file].sql<br></code></pre></td></tr></table></figure><p>  这里，<code>[username]</code> 是你的数据库用户名，<code>[password]</code> 是密码（注意，<code>-p</code> 后面没有空格直接跟密码），<code>[database_name]</code> 是你要备份的数据库名，<code>[backup_file].sql</code> 是备份文件的名称。</p></li><li><p><strong>备份多个数据库</strong>:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -u [username] -p[password] --databases [database1] [database2] &gt; [backup_file].sql<br></code></pre></td></tr></table></figure></li><li><p><strong>备份所有数据库</strong>:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqldump -u [username] -p[password] --all-databases &gt; [backup_file].sql<br></code></pre></td></tr></table></figure></li></ul><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><h4 id="使用-mysql-客户端工具"><a href="#使用-mysql-客户端工具" class="headerlink" title="使用 mysql 客户端工具"></a>使用 <code>mysql</code> 客户端工具</h4><p>备份文件可以使用 <code>mysql</code> 命令行工具恢复到数据库中。</p><ul><li><p>恢复数据库：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u [username] -p[password] [database_name] &lt; [backup_file].sql<br></code></pre></td></tr></table></figure><p>  在这个命令中，你需要指定数据库名称（如果数据库不存在，需要先创建它），然后将备份文件导入到该数据库中。</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul><li><code>int</code> (integer): 整数类型。</li></ul><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><ul><li><code>double</code>: 双精度浮点类型。</li><li><code>decimal (m,d)</code>: 指定整数位与小数位长度的小数类型。例如，<code>decimal(10,2)</code> 表示总共10位数字，其中2位为小数。</li></ul><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ul><li><code>date</code>: 日期类型，格式为 <code>yyyy-MM-dd</code>，包含年月日，不包含时分秒。例如，<code>2019-05-06</code>。</li><li><code>datetime</code>: 日期类型，格式为 <code>YYYY-MM-DD HH:MM:SS</code>，包含年月日时分秒。例如，<code>2019-05-06 09:49:30</code>。</li><li><code>timestamp</code>: 日期类型，时间戳。</li></ul><h3 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h3><ul><li><code>varchar (M)</code>: 文本类型，<code>M</code> 为0-65535之间的整数。</li></ul><h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure><h3 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use db1;<br></code></pre></td></tr></table></figure><h3 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database()<br></code></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database 数据库名称;<br>-- 不存在则创建<br>create database if not exists db1;<br>-- 创建的时候指定字符集<br>create database db1 default character set gbk;<br></code></pre></td></tr></table></figure><h3 id="查看某个数据库定义信息"><a href="#查看某个数据库定义信息" class="headerlink" title="查看某个数据库定义信息"></a>查看某个数据库定义信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create database db1;<br></code></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database db1;<br></code></pre></td></tr></table></figure><h2 id="数据表基本操作"><a href="#数据表基本操作" class="headerlink" title="数据表基本操作"></a>数据表基本操作</h2><h3 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure><h3 id="查看表的具体信息"><a href="#查看表的具体信息" class="headerlink" title="查看表的具体信息"></a>查看表的具体信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc 表名;<br></code></pre></td></tr></table></figure><h3 id="查看如何创建的"><a href="#查看如何创建的" class="headerlink" title="查看如何创建的"></a>查看如何创建的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table 表名<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> create table 表名(<br>         字段1 字段类型,<br>         字段2 字段类型,<br>         …<br>         字段n 字段类型<br>);<br></code></pre></td></tr></table></figure><h3 id="修改表属性"><a href="#修改表属性" class="headerlink" title="修改表属性"></a>修改表属性</h3><ul><li><p>名称</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 【old_table_name】 RENAME TO 【new_table_name】;<br></code></pre></td></tr></table></figure></li><li><p>字段</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 添加字段<br>ALTER TABLE 【table_name】 ADD 【column_name datatype】;<br><br>-- 删除字段<br>ALTER TABLE 【table_name】 DROP COLUMN 【column_name】;<br><br><br></code></pre></td></tr></table></figure></li><li><p>字段类型</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 【table_name】 MODIFY 【column_name】 【new_datatype】;<br></code></pre></td></tr></table></figure></li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br></code></pre></td></tr></table></figure><h2 id="数据表的约束"><a href="#数据表的约束" class="headerlink" title="数据表的约束"></a>数据表的约束</h2><h3 id="表的约束条件"><a href="#表的约束条件" class="headerlink" title="表的约束条件"></a>表的约束条件</h3><p>表的约束条件用于限制表中字段的数据，以保证数据的正确性和唯一性。以下是五种常见的约束条件：</p><ul><li><p><strong>PRIMARY KEY</strong>: 主键约束用于唯一标识对应的记录。每个表只能有一个主键，主键列中的值必须唯一，且不能为NULL。</p></li><li><p><strong>FOREIGN KEY</strong>: 外键约束，用于建立两个表之间的链接。外键在当前表中不能有唯一值，其值必须是另一个表中主键或唯一约束的值，或者为NULL。</p></li><li><p><strong>NOT NULL</strong>: 非空约束，确保该字段的每条记录都必须含有值，即该字段不能存储NULL值。</p></li><li><p><strong>UNIQUE</strong>: 唯一性约束，保证所有记录中的该字段的每个值都必须唯一。不同的记录中可以包含NULL值。</p></li><li><p><strong>DEFAULT</strong>: 默认值约束，用于设置字段的默认值。如果在插入记录时没有指定该字段的值，则会使用默认值。</p></li></ul><p>表的约束实际上就是表中数据的限制条件，它们是维护数据完整性的重要工具。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><ul><li><p>主键约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">字段名 数据类型 primary key;<br></code></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE persons (<br>    firstName varchar(255),<br>    lastName varchar(255),<br>    address varchar(255),<br>    city varchar(255)<br>);<br><br>ALTER TABLE persons ADD PRIMARY KEY (firstName, lastName);-- 设置主键<br></code></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE persons DROP PRIMARY KEY; -- 撤销主键约束<br></code></pre></td></tr></table></figure></li><li><p>外键约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 在创建数据表时语法如下：<br>CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段)<br>-- 将创建数据表创号后语法如下：<br>ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段);<br></code></pre></td></tr></table></figure><blockquote><p>主表数据删除，从表数据也要删除</p></blockquote></li><li><p>非空约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql’">字段名 数据类型 NOT NULL;<br></code></pre></td></tr></table></figure></li><li><p>唯一性约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">字段名 数据类型 UNIQUE;<br></code></pre></td></tr></table></figure></li><li><p>默认值约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">字段名 数据类型 DEFAULT 默认值；<br></code></pre></td></tr></table></figure></li></ul><h3 id="级联删除（CASCADE）"><a href="#级联删除（CASCADE）" class="headerlink" title="级联删除（CASCADE）"></a>级联删除（CASCADE）</h3><p>设置级联删除，如果主表中的一条记录被删除，那么从表中所有引用了该记录的行也会被自动删除。这是为了保持数据库的引用完整性，避免出现“悬挂”的外键引用，即从表中有数据引用了已经不存在的主表数据。</p><h2 id="数据表内容基本操作"><a href="#数据表内容基本操作" class="headerlink" title="数据表内容基本操作"></a>数据表内容基本操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...);<br><br>INSERT INTO 表名 VALUES (值1，值2,...)  -- 每个字段都得填写，主键用null<br><br>-- 插入多条<br>INSERT INTO 表名 (字段名1,字段名2,...) VALUES (值 1,值 2,…),(值 1,值 2,…),...;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表名 SET 字段名=值, 字段名=值 WHERE 条件表达式;<br><br>-- example<br>update student set age=20,gender=&#x27;female&#x27; where name=&#x27;tom&#x27;;<br><br>-- 全部更新<br>update student set age=18;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 WHERE 条件表达式;<br><br>-- example<br><br>-- 删除表中所有数据<br>delete from user;<br><br>-- 删除 uid 为1的数据<br>delete from user where uid = 1;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">truncate table 表名;<br></code></pre></td></tr></table></figure><blockquote><p>区别：</p><p>delete :一条一条删除，不清空 ayto_increment 记录数。</p><p>truncate :直接将表删除，重新建表，auto_increment 将置为零，从新开始</p></blockquote><h3 id="查看auto-increment当前值"><a href="#查看auto-increment当前值" class="headerlink" title="查看auto_increment当前值"></a>查看auto_increment当前值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AUTO_INCREMENT<br>FROM information_schema.tables<br>WHERE table_name = &#x27;your_table_name&#x27;<br>AND table_schema = &#x27;your_database_name&#x27;;<br></code></pre></td></tr></table></figure><h3 id="修改auto-increment值"><a href="#修改auto-increment值" class="headerlink" title="修改auto_increment值"></a>修改auto_increment值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 AUTO_INCREMENT=100<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT 列名 from 表名;-- 去重<br></code></pre></td></tr></table></figure><h4 id="改字段查询"><a href="#改字段查询" class="headerlink" title="改字段查询"></a>改字段查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT pname, price + 2 from products;-- price+2 &amp;&amp; 去重<br></code></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 条件查询<br>SELECT * FROM products WHERE price&gt;40 AND price &lt;900;<br><br>SELECT * FROM products WHERE price BETWEEN 20 AND 98;<br><br>SELECT * FROM products WHERE price NOT IN (20,38,98);<br></code></pre></td></tr></table></figure><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from products where price like &#x27;%&#x27;;<br>-- %表示任意多个 _表示一个<br><br>-- 查找价格中包含数字&quot;5&quot;的产品<br>SELECT * FROM products WHERE CAST(price AS CHAR) LIKE &#x27;%5%&#x27;; -- 尽量不要使用，效率不高<br></code></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 聚合查询（对单列进行分析）<br><br>select count(*) from products;<br>select max(price) as 商品价格最大值 from products;<br>select min(price) as 商品价格最小值 from products;<br>select sum(price) as 商品总价 from products;<br>select avg(price) as 平均价格 from products;<br></code></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><blockquote><p>注意事项：</p><h3 id="分组查询的注意事项："><a href="#分组查询的注意事项：" class="headerlink" title="分组查询的注意事项："></a>分组查询的注意事项：</h3><ol><li><strong>选择的非聚合列必须在GROUP BY子句中声明</strong>：在<code>SELECT</code>语句中，如果你使用了聚合函数，那么除了聚合函数外的其他所有列都应该包含在<code>GROUP BY</code>子句中。这是因为非聚合列的值在分组聚合中是不明确的。</li><li><strong>HAVING子句的使用</strong>：<code>HAVING</code>子句是在分组后对聚合结果应用条件的方式。它类似于<code>WHERE</code>子句，但<code>WHERE</code>子句在数据分组前过滤行，而<code>HAVING</code>子句在数据分组和聚合之后过滤组。</li><li><strong>性能考虑</strong>：大量数据的分组查询可能会导致性能下降，特别是如果分组依据的列没有被索引。优化分组查询通常涉及确保适当的索引存在，以及尽量减少需要处理的数据量。</li><li><strong>聚合函数和NULL值</strong>：大多数聚合函数在计算时会忽略NULL值。因此，如果分组列中包含NULL值，这些值会被视为一个单独的组。</li><li><strong>分组的结果</strong>：使用<code>GROUP BY</code>时，可以把它想象成对于每个唯一的分组键（本例中的<code>sid</code>），SQL都会创建一个“虚拟的子表”（虽然这不是在物理上发生的），然后对每个这样的“子表”应用聚合函数。<code>GROUP BY sid</code>后，查询就像是对每个由<code>sid</code>定义的分组单独进行了。</li><li><strong>排序分组结果</strong>：可以使用<code>ORDER BY</code>子句对分组查询的结果进行排序，但需要注意的是，排序是在所有分组完成后进行的。</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 分组查询<br>select sid as 商品分类,count(*) as 商品个数 from products group by sid;<br>select sid as 商品分类,avg(price) as 平均价格 from products group by sid having avg(price)&gt;=60;<br></code></pre></td></tr></table></figure><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM 表名 LIMIT 起始位置, 记录数;   -- 一般结合排序<br><br>-- example<br>SELECT product_id, name, price, added_on<br>FROM products<br>ORDER BY added_on DESC              <br>LIMIT 0, 5;<br></code></pre></td></tr></table></figure><h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><h3 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 查询字段1,查询字段2, ... FROM 表1 [INNER] JOIN 表2 ON 表1.关系字段=表2.关系字段<br></code></pre></td></tr></table></figure><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 查询字段1,查询字段2, ... FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.关系字段=表2.关系字段 WHERE 条件<br></code></pre></td></tr></table></figure><p><strong>1、LEFT [OUTER] JOIN 左(外)连接：返回包括左表中的所有记录和右表中符合连接条件的记录。<br>2、RIGHT [OUTER] JOIN 右(外)连接：返回包括右表中的所有记录和左表中符合连接条件的记录</strong></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="带比较运算符的子查询"><a href="#带比较运算符的子查询" class="headerlink" title="带比较运算符的子查询"></a>带比较运算符的子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from class where cid=(select classid from student where sname=&#x27;张三&#x27;);<br></code></pre></td></tr></table></figure><h3 id="带EXISTS关键字的子查询"><a href="#带EXISTS关键字的子查询" class="headerlink" title="带EXISTS关键字的子查询"></a>带EXISTS关键字的子查询</h3><p>EXISTS关键字后面的参数可以是任意一个子查询， 它不产生任何数据只返回TRUE或FALSE。当返回值为TRUE时外层查询才会 执行</p><blockquote><p>假如王五同学在学生表中则从班级表查询所有班级信息 MySQL命令：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from class where exists (select * from student where sname=&#x27;王五&#x27;);<br></code></pre></td></tr></table></figure><h3 id="带ANY关键字的子查询"><a href="#带ANY关键字的子查询" class="headerlink" title="带ANY关键字的子查询"></a>带ANY关键字的子查询</h3><p>ANY关键字表示满足其中任意一个条件就返回一个结果作为外层查询条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from class where cid &gt; any (select classid from student);<br></code></pre></td></tr></table></figure><h3 id="带ALL关键字的子查询"><a href="#带ALL关键字的子查询" class="headerlink" title="带ALL关键字的子查询"></a>带ALL关键字的子查询</h3><p>ALL关键字与ANY有点类似，只不过带ALL关键字的子査询返回的结果需同时满足所有内层査询条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from class where cid &gt; all (select classid from student);<br></code></pre></td></tr></table></figure><h2 id="各个指令的书写顺序【重要】"><a href="#各个指令的书写顺序【重要】" class="headerlink" title="各个指令的书写顺序【重要】"></a>各个指令的书写顺序【重要】</h2><ol><li><strong>SELECT</strong><ul><li>指定要从数据集中选择哪些列或进行哪些计算。</li></ul></li><li><strong>DISTINCT</strong><ul><li>用于返回唯一不同的值。如果使用，它紧跟在 SELECT 关键字后面。</li></ul></li><li><strong>FROM</strong><ul><li>指定要从哪个表中检索数据。这是定义数据源的地方。</li></ul></li><li><strong>JOIN</strong><ul><li>如果涉及多个表，使用 JOIN 来说明如何将这些表根据逻辑关系连接起来。</li></ul></li><li><strong>WHERE</strong><ul><li>对从 FROM 子句指定的表中检索到的数据进行条件过滤。</li></ul></li><li><strong>GROUP BY</strong><ul><li>如果需要按某一列或多列对结果集进行分组，使用 GROUP BY 子句。</li></ul></li><li><strong>HAVING</strong><ul><li>用于对 GROUP BY 分组后的结果集进行条件过滤。这是唯一可以在聚合函数上应用条件的地方。</li></ul></li><li><strong>ORDER BY</strong><ul><li>指定如何对查询结果进行排序（例如，按某列升序或降序）。</li></ul></li><li><strong>LIMIT</strong> &#x2F; <strong>OFFSET</strong><ul><li>用于限制返回的结果数量，或指定从哪一条记录开始返回。这在进行分页时特别有用。</li></ul></li></ol><h2 id="各个指令的执行顺序【重要】"><a href="#各个指令的执行顺序【重要】" class="headerlink" title="各个指令的执行顺序【重要】"></a>各个指令的执行顺序【重要】</h2><ol><li><strong>FROM</strong>子句<ul><li>这是第一步，数据库系统从指定的表中读取数据。如果有多个表，会进行相应的连接操作。</li></ul></li><li><strong>JOIN</strong>（如果有）<ul><li>如果查询涉及多个表，会在这一步根据 JOIN 条件进行表的连接。</li></ul></li><li><strong>WHERE</strong>子句<ul><li>接下来，数据库系统会根据 WHERE 子句中的条件过滤数据。这一步发生在任何分组（GROUP BY）之前，意味着 WHERE 条件是应用于原始数据上的。</li></ul></li><li><strong>GROUP BY</strong>子句<ul><li>如果查询指定了 GROUP BY，那么在 WHERE 过滤之后，下一步就是根据指定的列或表达式对结果集进行分组。</li></ul></li><li><strong>HAVING</strong>子句<ul><li>HAVING 子句用于过滤经过 GROUP BY 分组后的数据集。这意味着，与 WHERE 不同，HAVING 是在分组后对组应用的条件。</li></ul></li><li><strong>SELECT</strong>子句<ul><li>这一步选择从上一步结果中需要获取的列。如果有聚合函数（如 SUM、COUNT 等），它们也会在这一步计算。</li></ul></li><li><strong>DISTINCT</strong>（如果有）<ul><li>如果查询指定了 DISTINCT，那么在 SELECT 后，会去除重复的行。</li></ul></li><li><strong>ORDER BY</strong>子句<ul><li>接着，根据 ORDER BY 子句指定的列或表达式对结果集进行排序。注意，这是在所有的选择、聚合和过滤操作完成后进行的。</li></ul></li><li><strong>LIMIT</strong>子句（或 OFFSET）<ul><li>最后，如果指定了 LIMIT 或 OFFSET，数据库系统会根据这些限制来限定或跳过结果集中的一部分行。</li></ul></li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><a href="https://blog.csdn.net/qq_56880706/article/details/122653735?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170900723016800182152977%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170900723016800182152977&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-122653735-null-null.142%5Ev99%5Epc_search_result_base3&utm_term=mysql%E4%BA%8B%E5%8A%A1&spm=1018.2226.3001.4187">参考文章</a></p><ul><li>原子性（Atomicity）：指事务是一个不可分割的最小工作单位，事务中的操作只有都发生和都不发生两种情况</li><li>一致性（Consistency）：事务必须使数据库从一个一致状态变换到另外一个一致状态，举一个栗子，李二给王五转账50元，其事务就是让李二账户上减去50元，王五账户上加上50元；一致性是指其他事务看到的情况是要么李二还没有给王五转账的状态，要么王五已经成功接收到李二的50元转账。而对于李二少了50元，王五还没加上50元这个中间状态是不可见的。</li><li>隔离性（Isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability）：一个事务一旦提交成功，它对数据库中数据的改变将是永久性的，接下来的其他操作或故障不应对其有任何影响。</li></ul><h3 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h3><ul><li>隐式事务：该事务没有明显的开启和结束标记，它们都具有自动提交事务的功能；不妨思考一下，update语句修改数据时，是不是对表中数据进行改变了，它的本质其实就相当于一个事务</li><li>显示事务：该事务具有明显的开启和结束标记；也是本文重点要讲的东西。使用显式事务的前提是你得先把自动提交事务的功能给禁用。禁用自动提交功能就是设置<code>autocommit</code>变量值为0（0:禁用 1:开启）</li></ul><h3 id="查看是否自动提交"><a href="#查看是否自动提交" class="headerlink" title="查看是否自动提交"></a>查看是否自动提交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @@autocommit;  -- 为0为禁用<br></code></pre></td></tr></table></figure><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#步骤一：开启事务（可选）<br>start transaction;<br>#步骤二：编写事务中的sql语句（insert、update、delete）<br>#这里实现一下&quot;李二给王五转账&quot;的事务过程<br>update t_account set balance = 50 where vname = &quot;李二&quot;;<br>update t_account set balance = 130 where vname = &quot;王五&quot;;<br>#步骤三：结束事务<br>commit; #提交事务<br># rollback; #回滚事务:就是事务不执行，回滚到事务执行前的状态<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具汇总</title>
    <link href="/2024/02/22/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/02/22/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="bilibili视频下载网址"><a href="#bilibili视频下载网址" class="headerlink" title="bilibili视频下载网址"></a>bilibili视频下载网址</h2><p><a href="https://xbeibeix.com/api/bilibili/">https://xbeibeix.com/api/bilibili/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程面试题</title>
    <link href="/2024/02/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/02/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="细颗粒度读写锁"><a href="#细颗粒度读写锁" class="headerlink" title="细颗粒度读写锁"></a>细颗粒度读写锁</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给定一个长度为N(N&#x3D;100,000)的整数数组S，有M(M&gt;&#x3D;2)个工人并发访问和更新S。每个工人重复以下操作10,000次:生成随机数i和j，0&lt;&#x3D;i,j&lt;100,000。更新S使得<code>S(j)=S(1)+S(i+1)+S(i+2)</code>。如果i+1或i+2越界，则使用(i+1)%N或(i+2)%N。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h3><p>(a)请考虑并发保护，即读取<code>S(i)、S(i+1)、S(+2)</code>和更新<code>S(j)</code>是原子操作。<strong>参考两阶段锁定算法</strong><br>(b)注意锁的粒度。每个工人一次只读3个元素，写1个元素。总共有100,000个元素。并发工人访问相同元素的概率非常低。使用细粒度锁可以减少冲突并提高并发性。<br>(c)注意读锁和写锁之间的区别。<br>(d)<code>j</code>可能落在<code>[i,i+2]</code>范围内。<br>(e)额外思考:会发生死锁吗?如何避免?</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000</span>; <span class="hljs-comment">// 数组大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">10</span>;<span class="hljs-comment">//线程数目</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXNUM = <span class="hljs-number">10000</span>;<span class="hljs-comment">//轮询次数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">S</span><span class="hljs-params">(N, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">std::vector&lt;std::shared_mutex&gt; <span class="hljs-title">locks</span><span class="hljs-params">(N)</span></span>; <span class="hljs-comment">// 共享锁</span><br><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">generateRandomNumbers</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//获取随机数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(std::random_device&#123;&#125;())</span></span>;<br>    std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">dis</span>(<span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">dis</span>(gen);<br>    <span class="hljs-type">int</span> j = <span class="hljs-built_in">dis</span>(gen);<br>    <span class="hljs-keyword">return</span> &#123; i, j &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workerOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; MAXNUM; ++k) &#123;<br>        <span class="hljs-keyword">auto</span> tt = <span class="hljs-built_in">generateRandomNumbers</span>();<br>        <span class="hljs-type">int</span> i = tt.first;<br>        <span class="hljs-type">int</span> j = tt.second;<br><br>        <span class="hljs-comment">// 保证加锁顺序，从小到大，并且去重</span><br>        std::vector&lt;<span class="hljs-type">int</span>&gt; lockIndexes = &#123; i, (i + <span class="hljs-number">1</span>) % N, (i + <span class="hljs-number">2</span>) % N, j &#125;;<br>        std::<span class="hljs-built_in">sort</span>(lockIndexes.<span class="hljs-built_in">begin</span>(), lockIndexes.<span class="hljs-built_in">end</span>());<br>        lockIndexes.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(lockIndexes.<span class="hljs-built_in">begin</span>(), lockIndexes.<span class="hljs-built_in">end</span>()), lockIndexes.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-comment">// 加读锁和写锁</span><br>        std::vector&lt;std::shared_lock&lt;std::shared_mutex&gt;&gt; readLocks;<br>        std::unique_lock&lt;std::shared_mutex&gt; writeLock;<br><br>        <span class="hljs-comment">//保证加锁顺序,并且加不同的锁</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; index : lockIndexes) &#123;<br>            <span class="hljs-keyword">if</span> (index != j) &#123;<br>                readLocks.<span class="hljs-built_in">emplace_back</span>(locks[index]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                writeLock = std::<span class="hljs-built_in">unique_lock</span>&lt;std::shared_mutex&gt;(locks[index]);<br>            &#125;<br>        &#125;<br><br>        S[j] = S[i] + S[(i + <span class="hljs-number">1</span>) % N] + S[(i + <span class="hljs-number">2</span>) % N];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::thread&gt; workers;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; ++i) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; std::endl;<br>        workers.<span class="hljs-built_in">emplace_back</span>(workerOperation, i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; worker : workers) &#123;<br>        worker.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++恶心知识点</title>
    <link href="/2024/02/21/cpp/c++%E7%96%91%E9%9A%BE%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/02/21/cpp/c++%E7%96%91%E9%9A%BE%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍c-常用知识点"><a href="#本文介绍c-常用知识点" class="headerlink" title="本文介绍c++常用知识点"></a>本文介绍c++常用知识点</h1><h2 id="内存溢出和内存泄漏，数组越界"><a href="#内存溢出和内存泄漏，数组越界" class="headerlink" title="内存溢出和内存泄漏，数组越界"></a>内存溢出和内存泄漏，数组越界</h2><ul><li><strong>内存溢出（Memory Overflow）</strong>：这通常发生在试图分配的内存超过了系统可用内存的情况。例如，在一个有限的内存空间中创建太多对象或数据结构。</li><li><strong>内存泄漏（Memory Leak）</strong>：这发生在分配的内存没有得到适当释放的时候。如果程序反复分配内存而不释放，最终可能耗尽系统资源。</li><li><strong>数组越界（Array Index Out of Bound）</strong>：当试图访问数组之外的索引时发生。这是常见的编程错误，可能导致程序崩溃或不可预期的行为</li></ul><h2 id="多线程和多进程的关系"><a href="#多线程和多进程的关系" class="headerlink" title="多线程和多进程的关系"></a>多线程和多进程的关系</h2><ul><li><strong>多线程（Multithreading）</strong>：在一个进程内部，可以创建多个线程，这些线程共享相同的内存空间和资源，但可以并行执行不同的任务。多线程适用于轻量级的并行任务，尤其是在需要共享大量数据时。</li><li><strong>多进程（Multiprocessing）</strong>：每个进程有自己独立的内存空间和资源。多进程可以在不同的CPU核心上并行执行，适用于需要隔离和安全性的重量级任务。进程间通信比线程间通信更复杂和开销更大。</li></ul><h2 id="指针字节"><a href="#指针字节" class="headerlink" title="指针字节"></a>指针字节</h2><ul><li>在 32 位系统上，指针的大小通常是 4 字节（32 位）。</li><li>在 64 位系统上，指针的大小通常是 8 字节（64 位）。、</li></ul><p>去除x的第一个字节的数字（可以判断大端序小端序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br>    cout&lt;&lt;(<span class="hljs-type">int</span>)*(<span class="hljs-type">char</span>*)&amp;x;<span class="hljs-comment">//x占4字节，char*取出第一字节，转化为int类型输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历x的每个字节并打印输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        cout&lt;&lt;(<span class="hljs-type">int</span>)*((<span class="hljs-type">char</span>*)&amp;x+i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>任何类型的指针都是4字节</p></li><li><p>char*指向的内存为1字节，int*指向的内存为4字节</p></li></ul><p><strong><code>char*</code> 和 <code>int*</code> 指针的增加区别</strong>:</p><ul><li>当您对 <code>char*</code> 类型的指针执行 <code>++</code> 操作时，指针将向前移动 1 字节，因为 <code>char</code> 的大小是 1 字节。</li><li>相比之下，对 <code>int*</code> 类型的指针执行 <code>++</code> 操作时，指针将向前移动 <code>sizeof(int)</code> 字节，通常是 4 字节（这取决于编译器和系统架构）。</li><li>这反映了指针的算术操作是基于它们指向的数据类型的大小。</li></ul><h2 id="类里面尽量用指针"><a href="#类里面尽量用指针" class="headerlink" title="类里面尽量用指针"></a>类里面尽量用指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    A* a; <span class="hljs-comment">//不允许写成A a(不允许使用不完整的类型)</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-库目录和头文件目录"><a href="#C-库目录和头文件目录" class="headerlink" title="C++ 库目录和头文件目录"></a>C++ 库目录和头文件目录</h2><ul><li><strong>头文件目录</strong>：这是存放 C++ 头文件（通常以 <code>.h</code> 或 <code>.hpp</code> 结尾）的目录。这些头文件包含了类定义、模板和函数声明等。</li><li><strong>库目录</strong>：这是存放编译后的库文件的目录。对于静态库，通常是 <code>.a</code> 或 <code>.lib</code> 文件；对于动态库（共享库），是 <code>.so</code>（在 Linux 上）或 <code>.dll</code>（在 Windows 上）文件。</li></ul><h2 id="在-Linux-下指定动态链接库的目录"><a href="#在-Linux-下指定动态链接库的目录" class="headerlink" title="在 Linux 下指定动态链接库的目录:"></a>在 Linux 下指定动态链接库的目录:</h2><ul><li><strong>运行时指定动态链接库的目录</strong>:<ul><li>如果动态链接库不在标准的库目录（如 <code>/lib</code> 或 <code>/usr/lib</code>）中，可以通过设置环境变量 <code>LD_LIBRARY_PATH</code> 来指定额外的库搜索路径。</li><li><code>LD_LIBRARY_PATH</code> 环境变量包含一系列目录，运行时链接器（dynamic linker）将在这些目录中搜索动态链接库。</li><li>如果 <code>LD_LIBRARY_PATH</code> 没有正确设置，当程序尝试加载一个不在标准路径中的库时，会报错，如 “cannot open shared object file” 或类似的消息。</li></ul></li><li><strong>编译时指定动态链接库的目录</strong>:<ul><li>在编译阶段，使用 <code>g++</code> 或其他编译器时，确实需要指定动态链接库的位置，这样编译器能够正确链接这些库。</li><li>通过 <code>-L</code> 选项指定库所在的目录，例如 <code>g++ -L/path/to/library</code>。</li><li>同时，使用 <code>-l</code> 选项指定要链接的库的名称，例如 <code>g++ -lmylibrary</code>，这里 <code>mylibrary</code> 是库的名称，对应于 <code>libmylibrary.so</code> 文件。</li></ul></li><li><strong>注意事项</strong>:<ul><li>需要注意的是，<code>LD_LIBRARY_PATH</code> 是运行时的设置，而 <code>-L</code> 和 <code>-l</code> 是编译时的设置。</li><li>修改 <code>LD_LIBRARY_PATH</code> 对已经编译好的程序有效，但不会影响未来的编译过程。</li><li>同样，编译时使用的 <code>-L</code> 和 <code>-l</code> 选项不会影响已经编译好的可执行文件的运行。</li></ul></li><li><strong>最佳实践</strong>:<ul><li>尽管可以使用 <code>LD_LIBRARY_PATH</code> 来解决库的查找问题，但最佳实践是将库安装到标准路径，或者在程序的链接阶段正确指定库的位置。</li><li>对于开发和部署，保持一致的库路径有助于避免运行时错误。</li></ul></li></ul><h2 id="make-shared隐患"><a href="#make-shared隐患" class="headerlink" title="make_shared隐患"></a>make_shared隐患</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;<br>        p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]();<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        <span class="hljs-comment">//A类内部new出来的需要手动delete</span><br>        <span class="hljs-keyword">delete</span>[]p;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Hello World&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        <span class="hljs-keyword">private</span>:<br>    &#125;;<br>    B b;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">B <span class="hljs-title">getB</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    A::B b=a.<span class="hljs-built_in">getB</span>();<br>    b.<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意作用域</p></blockquote><h2 id="c-的按位取反操作"><a href="#c-的按位取反操作" class="headerlink" title="c++的按位取反操作"></a>c++的按位取反操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">-1e8</span>;i&lt;=<span class="hljs-number">1e8</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(-i!=(~i+<span class="hljs-number">1</span>))&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>最终输出yes</p></blockquote><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="基本函数指针语法"><a href="#基本函数指针语法" class="headerlink" title="基本函数指针语法"></a>基本函数指针语法</h3><p>假设我们有一个简单的函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了声明一个指向这个函数的指针，你可以使用以下语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span> (*functionPtr)(<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这里，<code>functionPtr</code>是一个指针，指向一个接受<code>int</code>参数并返回<code>void</code>的函数。你可以这样赋值给它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">functionPtr = myFunction;<br></code></pre></td></tr></table></figure><p>然后，你可以通过解引用指针来调用函数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(*functionPtr)(<span class="hljs-number">10</span>); <br><span class="hljs-comment">// 或者 functionPtr(10); 两者在这里是等价的</span><br></code></pre></td></tr></table></figure><h3 id="使用typedef简化函数指针"><a href="#使用typedef简化函数指针" class="headerlink" title="使用typedef简化函数指针"></a>使用typedef简化函数指针</h3><p>使用<code>typedef</code>可以使函数指针的声明更简单、更易读。继续使用上面的例子，我们可以这样定义一个类型别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*FunctionPointerType)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>然后使用这个别名来声明指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FunctionPointerType myPtr = myFunction;<br><span class="hljs-built_in">myPtr</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 调用函数</span><br></code></pre></td></tr></table></figure><h3 id="函数指针指向类成员函数"><a href="#函数指针指向类成员函数" class="headerlink" title="函数指针指向类成员函数"></a>函数指针指向类成员函数</h3><p>当你想要指针指向类的成员函数时，语法会稍有不同，因为你需要处理<code>this</code>指针。这里是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memberFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Class Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了声明一个指向这个成员函数的指针，你需要这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span> (MyClass::*ptr)(<span class="hljs-type">int</span>) = &amp;MyClass::memberFunction;<br></code></pre></td></tr></table></figure><p>使用<code>typedef</code>简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(MyClass::*MyClassFunctionPointer)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>MyClassFunctionPointer ptr = &amp;MyClass::memberFunction;<br></code></pre></td></tr></table></figure><p>调用这个成员函数指针时，你需要一个类的实例，并且使用<code>-&gt;*</code>或<code>.*</code>运算符，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass obj;<br>(obj.*ptr)(<span class="hljs-number">10</span>); <span class="hljs-comment">// 如果ptr是一个成员函数指针</span><br><br>MyClass *objPtr = &amp;obj;<br>(objPtr-&gt;*ptr)(<span class="hljs-number">10</span>); <span class="hljs-comment">// 如果ptr是一个成员函数指针并且你有一个指向对象的指针</span><br></code></pre></td></tr></table></figure><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><h3 id="1-类的静态函数和构造函数不可以定义为虚函数"><a href="#1-类的静态函数和构造函数不可以定义为虚函数" class="headerlink" title="1.类的静态函数和构造函数不可以定义为虚函数"></a>1.类的静态函数和构造函数不可以定义为虚函数</h3><h3 id="2-将析构函数定义为虚函数的作用"><a href="#2-将析构函数定义为虚函数的作用" class="headerlink" title="2.将析构函数定义为虚函数的作用"></a>2.将析构函数定义为虚函数的作用</h3><blockquote><p>类的构造函数不能定义为虚函数，析构函数可以定义为虚函数，这样当我们delete一个指向子类对象的基类指针时可以达到调用子类析构函数的作用，从而动态释放内存。</p></blockquote><h3 id="3-要点"><a href="#3-要点" class="headerlink" title="3.要点"></a>3.要点</h3><ul><li>虚函数表是虚函数指针数组</li><li>一个类对象其内存分布的基本结构为<strong>虚函数表地址+非静态成员变量</strong>，类的成员函数<strong>不占</strong>用类对象的空间，他们分布在一片属于类的共有区域。</li><li>类的静态成员函数喝成员变量不占用类对象的空间，他们分配在静态区。</li><li><strong>虚函数表的地址</strong>存储在类对象的起始位置。所以我们利用这个原理，通过寻址的方式访问虚函数表里的函数</li><li>一个类得所有实例共享一个虚函数表</li></ul><h2 id="4-代码演示"><a href="#4-代码演示" class="headerlink" title="4.代码演示"></a>4.代码演示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::func1&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A::func2&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123;&#125; <span class="hljs-comment">// 虚析构函数，确保派生类的正确析构</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-comment">// 获取虚函数表的地址</span><br>    <span class="hljs-type">void</span>** vptr = *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>***&gt;(&amp;a);<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*Func1Ptr)</span><span class="hljs-params">()</span></span>;<br>    Func1Ptr func1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;Func1Ptr&gt;(vptr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">func1</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*Func2Ptr)</span><span class="hljs-params">()</span></span>;<br>    Func2Ptr func2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;Func2Ptr&gt;(vptr[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">func2</span>(); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-多继承"><a href="#5-多继承" class="headerlink" title="5.多继承"></a>5.多继承</h3><blockquote><p>会含有多个虚函数表</p></blockquote><h2 id="对齐和补齐规则"><a href="#对齐和补齐规则" class="headerlink" title="对齐和补齐规则"></a>对齐和补齐规则</h2><p>对齐：类(结构体)对象每个成员分配内存的起始地址为其所占空间的整数倍。<br>补齐：类(结构体)对象所占用的总大小为其内部最大成员所占空间的整数倍。</p><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>引用折叠是C++中的一个规则，用于确定当模板实例化或类型别名声明中出现多重引用时，引用应该如何被处理。其规则如下：</p><ul><li><code>T&amp; &amp;</code>、<code>T&amp; &amp;&amp;</code>、<code>T&amp;&amp; &amp;</code>都折叠成<code>T&amp;</code></li><li><code>T&amp;&amp; &amp;&amp;</code>折叠成<code>T&amp;&amp;</code></li></ul><h2 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>通用引用的语法很简单，只需在类型后面加上<code>&amp;&amp;</code>，并且这个类型必须是模板参数的推导类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>T&amp;&amp;</code>类型的参数<code>arg</code>是一个通用引用。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>当一个左值被传递给<code>function</code>时，模板参数<code>T</code>被推导为左值引用类型。例如，如果你传递一个<code>int</code>类型的左值给<code>function</code>，<code>T</code>将被推导为<code>int&amp;</code>，使得<code>T&amp;&amp;</code>实际上成为<code>int&amp; &amp;&amp;</code>，根据引用折叠规则（Reference Collapsing Rules），它会变成<code>int&amp;</code>。</p><p>相反，如果一个右值被传递给<code>function</code>，<code>T</code>将被推导为该右值的实际类型，所以如果你传递一个<code>int</code>类型的右值，<code>T</code>将被推导为<code>int</code>，使得<code>T&amp;&amp;</code>实际上是<code>int&amp;&amp;</code>。</p><blockquote><p>通用引用避免重载</p></blockquote><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>直接转发会导致所有参数都被视为左值。为了保持参数的原始左值或右值属性，使用<code>std::forward</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 目标函数，接受一个右值引用参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;function called with right value\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 目标函数，重载版本接受一个左值引用参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;function called with left value\n&quot;</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 函数模板，使用通用引用和完美转发</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T&amp;&amp; arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 完美转发arg到另一个函数</span><br>    <span class="hljs-built_in">function</span>(std::forward&lt;T&gt;(arg));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">wrapper</span>(x);  <span class="hljs-comment">// 输出: function called with left value</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 输出: function called with right value</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完美转发与可变参数"><a href="#完美转发与可变参数" class="headerlink" title="完美转发与可变参数"></a>完美转发与可变参数</h2><p>当我们结合使用可变参数模板和完美转发时，可以创建非常通用的函数包装器，这些包装器能将任意数量和类型的参数完美地转发给其他函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(f(std::forward&lt;Args&gt;(args)...))</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>F&amp;&amp; f</code> 使用通用引用接受任何类型的函数或可调用对象。</li><li><code>Args&amp;&amp;... args</code> 是一个参数包，使用通用引用接受任意数量和类型的参数。</li><li><code>std::forward&lt;Args&gt;(args)...</code> 完美转发这些参数给函数<code>f</code>。</li><li><code>decltype(f(std::forward&lt;Args&gt;(args)...))</code> 用于推断函数<code>f</code>调用的返回类型。</li></ul><h3 id="展开参数包"><a href="#展开参数包" class="headerlink" title="展开参数包"></a>展开参数包</h3><p>参数包的展开是通过递归函数调用或初始化列表的方式实现的。在完美转发的上下文中，通常不需要手动展开参数包，因为<code>std::forward&lt;Args&gt;(args)...</code>语法已经为我们完成了这项工作。</p><h3 id="使用示例一"><a href="#使用示例一" class="headerlink" title="使用示例一"></a>使用示例一</h3><p>假设有一个函数<code>void print(int a, double b)</code>，我们想通过<code>wrapper</code>函数完美转发参数给它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">wrapper</span>(print, <span class="hljs-number">5</span>, <span class="hljs-number">3.14</span>); <span class="hljs-comment">// 完美转发5和3.14到print函数</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：这里<code>return void</code>是合法的</p></blockquote><h3 id="使用示例二"><a href="#使用示例二" class="headerlink" title="使用示例二"></a>使用示例二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// For std::forward</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 基础构造函数，执行主要的初始化逻辑</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> std::string&amp; name) : <span class="hljs-built_in">value</span>(x), <span class="hljs-built_in">name</span>(name) &#123;&#125;<br><br>    <span class="hljs-comment">// 模板构造函数，接受一个int和可变数量的其他参数</span><br>    <span class="hljs-comment">// 使用完美转发将其他参数转发到std::string的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> x, Args&amp;&amp;... args)</span></span><br><span class="hljs-function">        : MyClass(x, std::string(std::forward&lt;Args&gt;(args)...)) &#123;</span><span class="hljs-comment">//委托构造</span><br>        <span class="hljs-comment">// 这里可以添加特定于此构造函数的逻辑</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    std::string name;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h2 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h2><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ol><li><p>**<code>static_cast</code>**：</p><ul><li><p>用于非多态类型的转换。</p></li><li><p>可以进行基本数据类型之间的转换，如将<code>float</code>转换为<code>int</code>。</p></li><li><p>也用于类层次结构中基类和派生类之间的指针或引用的转换，但不进行运行时类型检查。</p></li><li><p><strong>场景示例</strong>：将<code>double</code>类型转换为<code>int</code>，或将基类指针转换为派生类指针（向下转型）。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> d = <span class="hljs-number">9.5</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(d); <span class="hljs-comment">// 将double转换为int</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>**<code>dynamic_cast</code>**：</p><ul><li><p>主要用于处理类层次中的向下转型，特别是在多态基类和派生类之间转换时。</p></li><li><p>进行转换时会进行类型安全检查，如果转换失败则返回<code>nullptr</code>（对于指针）。</p></li><li><p><strong>场景示例</strong>：在一个类继承体系中，将基类指针转换为派生类指针时检查安全性。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base* b = <span class="hljs-keyword">new</span> Derived;<br>Derived* d = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="hljs-comment">// 安全转换，检查b是否真的指向Derived或其派生类的对象</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>**<code>const_cast</code>**：</p><ul><li><p>用于修改类型的<code>const</code>或<code>volatile</code>属性，最常见的是去除<code>const</code>属性。</p></li><li><p><strong>场景示例</strong>：当你想在一个只接受非<code>const</code>参数的函数中使用<code>const</code>数据时。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* modifiable = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;ci); <span class="hljs-comment">// 去除const属性</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>**<code>reinterpret_cast</code>**：</p><ul><li><p>用于进行低级别的重新解释转换，几乎可以在任意指针类型之间转换，也可用于指针与足够大的整型之间的转换。</p></li><li><p>它不检查安全性，使用时需要特别小心。</p></li><li><p><strong>场景示例</strong>：将指针类型转换为一个足够大的整数类型，或在不同的函数指针类型之间转换。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ci = <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> p = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>&gt;(&amp;ci); <span class="hljs-comment">// 将指针转换为整数类型</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="使用场景总结："><a href="#使用场景总结：" class="headerlink" title="使用场景总结："></a>使用场景总结：</h3><ul><li>**<code>static_cast</code>**：适用于大多数类型转换，包括基础数据类型转换和非多态类型的转换。</li><li>**<code>dynamic_cast</code>**：适用于多态类型的安全向下转型，能够在运行时检查转换的有效性。</li><li>**<code>const_cast</code>**：适用于修改<code>const</code>或<code>volatile</code>属性的场景。</li><li>**<code>reinterpret_cast</code>**：适用于低级转换，如指针类型之间的转换，需要开发者非常小心使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git（github）</title>
    <link href="/2024/02/21/linux/git/"/>
    <url>/2024/02/21/linux/git/</url>
    
    <content type="html"><![CDATA[<h1 id="配置github的SSH-keys"><a href="#配置github的SSH-keys" class="headerlink" title="配置github的SSH keys"></a>配置github的SSH keys</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><h3 id="查看本机是否有已经生成公钥："><a href="#查看本机是否有已经生成公钥：" class="headerlink" title="查看本机是否有已经生成公钥："></a>查看本机是否有已经生成公钥：</h3> <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">ls -al ~/.ssh<br><br><span class="hljs-comment">#输出如下：</span><br>total 20<br>drwx------ <span class="hljs-number"> 2 </span>xiadong xiadong<span class="hljs-number"> 4096 </span>Feb<span class="hljs-number"> 21 </span>15:08 .<br>drwxr-xr-x<span class="hljs-number"> 24 </span>xiadong xiadong<span class="hljs-number"> 4096 </span>Feb<span class="hljs-number"> 21 </span>15:06 ..<br>-rw------- <span class="hljs-number"> 1 </span>xiadong xiadong<span class="hljs-number"> 3239 </span>Feb<span class="hljs-number"> 21 </span>15:08 id_rsa      <br>-rw-r--r-- <span class="hljs-number"> 1 </span>xiadong xiadong <span class="hljs-number"> 743 </span>Feb<span class="hljs-number"> 21 </span>15:08 id_rsa.pub<br>-rw-r--r-- <span class="hljs-number"> 1 </span>xiadong xiadong <span class="hljs-number"> 666 </span>Jan<span class="hljs-number"> 27 </span>19:50 known_hosts<br></code></pre></td></tr></table></figure></li><li><h2 id="如果没有id-rsa和id-rsa-pub，则生成公钥"><a href="#如果没有id-rsa和id-rsa-pub，则生成公钥" class="headerlink" title="如果没有id_rsa和id_rsa.pub，则生成公钥"></a>如果没有<code>id_rsa</code>和<code>id_rsa.pub</code>，则生成公钥</h2> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span>-keygen -t rsa -b <span class="hljs-number">4096</span> -C <span class="hljs-string">&quot;123@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p> <strong>一路回车即可</strong></p></li><li><h3 id="查看公钥内容"><a href="#查看公钥内容" class="headerlink" title="查看公钥内容"></a>查看公钥内容</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li><li><h3 id="复制公钥内容到github上即可"><a href="#复制公钥内容到github上即可" class="headerlink" title="复制公钥内容到github上即可"></a>复制公钥内容到github上即可</h3></li></ol><h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="git强制拉取远程分支"><a href="#git强制拉取远程分支" class="headerlink" title="git强制拉取远程分支"></a>git强制拉取远程分支</h2><ol><li><strong>重置本地分支到远程分支的状态：</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch origin<br>git reset --hard origin/master<br></code></pre></td></tr></table></figure><p>这将会使你的本地分支回到远程分支的状态，丢弃所有本地的更改。</p><ol><li><strong>如果需要，清理未跟踪的文件：</strong></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git clean -fd<br></code></pre></td></tr></table></figure><h2 id="git回滚到某个特定版本"><a href="#git回滚到某个特定版本" class="headerlink" title="git回滚到某个特定版本"></a>git回滚到某个特定版本</h2><p>如果你想将当前分支回滚到指定的提交，并且不介意放弃该提交之后的所有更改（在本地分支上），你可以使用 <code>git reset</code> 命令。这样做会重置你的 HEAD 指针到指定的提交，并且可以选择如何处理工作目录和暂存区的更改。</p><ul><li><strong>仅重置 HEAD 指针（保留工作目录和暂存区的更改）：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset --soft 07e95cc2d284e4f040e4c4aba407920cc11237d6<br></code></pre></td></tr></table></figure><ul><li><strong>重置 HEAD 指针，并且重置暂存区（但保留工作目录中的更改作为未提交的更改）：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset --mixed 07e95cc2d284e4f040e4c4aba407920cc11237d6<br></code></pre></td></tr></table></figure><p>或者简写为（因为 <code>--mixed</code> 是默认选项）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset 07e95cc2d284e4f040e4c4aba407920cc11237d6<br></code></pre></td></tr></table></figure><ul><li><strong>彻底回滚（重置 HEAD、暂存区和工作目录，放弃所有未提交的更改）：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset --hard 07e95cc2d284e4f040e4c4aba407920cc11237d6<br></code></pre></td></tr></table></figure><p>请注意，使用 <code>git reset --hard</code> 会丢失所有未提交的更改。确保在使用这个命令之前备份重要更改。</p><h2 id="git强制推送"><a href="#git强制推送" class="headerlink" title="git强制推送"></a>git强制推送</h2><p>强制推送到远程仓库的 <code>master</code> 分支可以使用以下命令，但请注意，这将覆盖远程分支上的所有更改，可能会导致其他人的工作丢失。因此，只有在你确实知道自己在做什么，并且这是解决问题的唯一方式时，才应该使用强制推送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master --force<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用指令</title>
    <link href="/2024/01/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/01/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="已知进程杀死进程"><a href="#已知进程杀死进程" class="headerlink" title="已知进程杀死进程"></a>已知进程杀死进程</h1><ul><li>ps aux：查看所有进程</li><li>ps aux | grep nginx : 查看nginx进程</li><li>kill -9 pid：杀死pid进程</li></ul><h1 id="已知端口杀死进程"><a href="#已知端口杀死进程" class="headerlink" title="已知端口杀死进程"></a>已知端口杀死进程</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul><li><p>查看哪些端口被占用（tcp，udp）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -tulnp<br></code></pre></td></tr></table></figure></li><li><p>杀死端口进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fuser -k [端口]<br><br></code></pre></td></tr></table></figure></li></ul><p>#例如<br>    sudo fuser -k 8080<br>    <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><br><br><br><br><br><span class="hljs-comment">## 方案二</span><br><br>- 查看端口的进程<br><br>  ```bash<br>  lsof -i :[端口]<br>  <br>  <span class="hljs-comment">#例如</span><br>  lsof -i :<span class="hljs-number">8080</span><br>  <br>  <span class="hljs-comment">#输出</span><br>  COMMAND     PID    <span class="hljs-keyword">USER</span>   <span class="hljs-title">FD</span>   <span class="hljs-keyword">TYPE</span>  DEVICE SIZE/OFF <span class="hljs-keyword">NODE</span> <span class="hljs-title">NAME</span><br>  httpServe <span class="hljs-number">24009</span> xiadong    <span class="hljs-number">3</span>u  IPv4 <span class="hljs-number">1496040</span>      <span class="hljs-number">0</span>t0  TCP *:http-alt (LISTEN)<br></code></pre></td></tr></table></figure></p><ul><li><p>杀死这个进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 [pid]<br><br></code></pre></td></tr></table></figure></li></ul><p>#例如<br>    kill -9 24009<br>    &#96;&#96;&#96;</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用指令</title>
    <link href="/2024/01/17/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/01/17/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="已知进程杀死进程"><a href="#已知进程杀死进程" class="headerlink" title="已知进程杀死进程"></a>已知进程杀死进程</h1><ul><li>ps aux：查看所有进程</li><li>ps aux | grep nginx : 查看nginx进程</li><li>kill -9 pid：杀死pid进程</li></ul><h1 id="已知端口杀死进程"><a href="#已知端口杀死进程" class="headerlink" title="已知端口杀死进程"></a>已知端口杀死进程</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul><li><p>查看哪些端口被占用（tcp，udp）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -tulnp<br></code></pre></td></tr></table></figure></li><li><p>杀死端口进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fuser -k [端口]<br><br><span class="hljs-comment">#例如</span><br>sudo fuser -k 8080<br></code></pre></td></tr></table></figure></li></ul><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><ul><li><p>查看端口的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i :[端口]<br><br><span class="hljs-comment">#例如</span><br>lsof -i :8080<br><br><span class="hljs-comment">#输出</span><br>COMMAND     PID    USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME<br>httpServe 24009 xiadong    3u  IPv4 1496040      0t0  TCP *:http-alt (LISTEN)<br></code></pre></td></tr></table></figure></li><li><p>杀死这个进程</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 [pid]<br><br><span class="hljs-comment">#例如</span><br><span class="hljs-built_in">kill</span> -9 24009<br></code></pre></td></tr></table></figure></li></ul><h1 id="查看公网ip"><a href="#查看公网ip" class="headerlink" title="查看公网ip"></a>查看公网ip</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl ifconfig.me<br></code></pre></td></tr></table></figure><h1 id="查看内网ip"><a href="#查看内网ip" class="headerlink" title="查看内网ip"></a>查看内网ip</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake配置</title>
    <link href="/2024/01/03/cpp/CMake%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%BA%93%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/01/03/cpp/CMake%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%BA%93%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>本文介绍CMake的常用命令以及库的相关概念</p><p>项目地址：<a href="https://github.com/mrxiad/Cmake_project_template">cmake教程</a></p><h1 id="安装Cmake"><a href="#安装Cmake" class="headerlink" title="安装Cmake"></a>安装Cmake</h1><p>在ubuntu18.04下安装cmake</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install cmake<br></code></pre></td></tr></table></figure><p>安装后查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -version<br></code></pre></td></tr></table></figure><h1 id="CMake编写"><a href="#CMake编写" class="headerlink" title="CMake编写"></a>CMake编写</h1><p><a href="https://blog.csdn.net/weixin_43717839/article/details/128032486?ops_request_misc=%7B%22request_id%22:%22170054364016800222888865%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170054364016800222888865&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-128032486-null-null.142%5Ev96%5Epc_search_result_base3&utm_term=cmake&spm=1018.2226.3001.4187">【C++】Cmake使用教程（看这一篇就够了）_隐居的遮天恶鬼的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43717839/article/details/127991174?spm=1001.2014.3001.5502">【C++】静态库和动态库文件的生成和使用_c++ 生成静态库和动态库命令-CSDN博客</a></p><h2 id="本文项目结构"><a href="#本文项目结构" class="headerlink" title="本文项目结构"></a>本文项目结构</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs makefile">MyProject/<br>|-- CMakeLists.txt          <span class="hljs-comment"># 主CMake文件</span><br>|-- external/               <span class="hljs-comment"># 外部依赖目录</span><br>|   |-- CMakeLists.txt<br>|   `-- libExternal         <span class="hljs-comment"># 模拟的外部库</span><br>|       |-- <span class="hljs-keyword">include</span>/        <span class="hljs-comment"># 外部库的头文件</span><br>|       |   `-- libExternal.h<br>|       `-- src/            <span class="hljs-comment"># 外部库的源文件</span><br>|           `-- libExternal.cpp<br>|-- app/                    <span class="hljs-comment"># 应用程序目录</span><br>|   |-- CMakeLists.txt<br>|   `-- src/<br>|       `-- main.cpp<br>|-- lib/                    <span class="hljs-comment"># 库文件目录</span><br>|   |-- libA/               <span class="hljs-comment"># 静态库A</span><br>|   |   |-- CMakeLists.txt<br>|   |   `-- src/<br>|   |       `-- libA.cpp<br>|   `-- libB/               <span class="hljs-comment"># 动态库B</span><br>|       |-- CMakeLists.txt<br>|       `-- src/<br>|           `-- libB.cpp<br>|-- <span class="hljs-keyword">include</span>/                <span class="hljs-comment"># 公共头文件目录</span><br>|   |-- libA/<br>|   |   `-- libA.h<br>|   `-- libB/<br>|       `-- libB.h<br>|-- tests/                  <span class="hljs-comment"># 测试目录</span><br>|   |-- CMakeLists.txt<br>|   `-- testA/<br>|       |-- CMakeLists.txt<br>|       `-- src/<br>|           `-- testA.cpp<br>|-- docs/                   <span class="hljs-comment"># 文档目录</span><br>|-- README.md<br>`-- .gitignore<br><br></code></pre></td></tr></table></figure><h2 id="需要明确一些点"><a href="#需要明确一些点" class="headerlink" title="需要明确一些点"></a>需要明确一些点</h2><ol><li><p><code>include”head.h”</code>仅仅是将文件内容复制，所以一个项目可以<strong>完全没有</strong>头文件</p></li><li><p>如果指定库文件（或者可执行文件）的头文件<strong>搜索路径</strong>，则首先在库文件搜索路径下找，然后在当前cpp文件目录下，然后在编译器的默认搜索路径中寻找</p></li><li><p>CMake是一个跨平台的自动化构建系统，主要用于生成Makefile，所以一般cmake不会报错，在make的时候会报错</p></li><li><p><strong>无法解析的外部命令</strong></p><ul><li>函数仅在头文件中声明，而没有在任何编译单元（.cpp文件）中实现。</li><li>相应的库文件没有被正确链接到您的项目中。</li><li>如果涉及动态库，可能是动态库没有被正确安装或找不到</li></ul></li><li><p><strong>编译和链接的关系</strong></p><p>每个源文件（.cpp）可以独立编译，生成对象文件。链接阶段将这些对象文件组合成最终的可执行文件或库文件。如果只有函数声明没有实现，编译时不会报错，但链接时会报错，因为链接器找不到这些函数的定义。并且链接器会自动处理依赖关系，不需要指定对象文件的链接顺序。</p></li><li><p><strong>动态库链接的代码执行</strong></p><p> 当您的程序链接了动态库，运行时，操作系统会加载这些库并解析所需的符号。如果您删除了动态库，程序可能无法运行，因为它找不到必要的函数实现。动态库的代码不是写入可执行文件中，而是在运行时动态加载的。</p></li><li><p><strong>库文件和头文件</strong></p><p> 库文件必须包含函数的定义，但<strong>不一定</strong>要包含头文件。头文件通常包含函数声明，使得其他源文件能够知道这些函数的存在。即使不包含头文件，只要函数在库内部定义，链接时就不会报错。</p></li><li><p><strong>动态库搜索</strong>，</p><p> 可执行文件本身不包含库代码，而是包含对库函数的引用。在运行时，操作系统的动态链接器负责找到并加载这些动态库。这通常是通过以下方式实现的：</p><ol><li><strong>链接时信息</strong>: 当可执行文件被创建时，链接器会在可执行文件中存储有关它依赖的动态库的信息（如库的名称和版本）。</li><li><strong>运行时搜索</strong>: 在程序启动时，动态链接器会根据这些信息查找并加载必要的动态库。库的搜索可以基于多个因素，包括操作系统的库搜索路径、环境变量（如 <code>LD_LIBRARY_PATH</code> 在Linux上）等。</li></ol></li></ol><h1 id="cmake知识点"><a href="#cmake知识点" class="headerlink" title="cmake知识点"></a>cmake知识点</h1><h2 id="一些常量"><a href="#一些常量" class="headerlink" title="一些常量"></a>一些常量</h2><ol><li><h3 id="项目和源代码相关"><a href="#项目和源代码相关" class="headerlink" title="项目和源代码相关"></a>项目和源代码相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取包含顶层CMakeLists.txt的目录的路径</span><br><span class="hljs-keyword">set</span>(TOP_LEVEL_SOURCE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取当前处理的CMakeLists.txt的目录的路径</span><br><span class="hljs-keyword">set</span>(CURRENT_LIST_DIR <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取最近通过project()命令定义的子项目的源目录(cmake目录)</span><br><span class="hljs-keyword">set</span>(LAST_PROJECT_SOURCE_DIR <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取包含当前正在处理的列表文件的目录</span><br><span class="hljs-keyword">set</span>(CURRENT_LIST_FILE_DIR <span class="hljs-variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><h3 id="构建和输出相关"><a href="#构建和输出相关" class="headerlink" title="构建和输出相关"></a>构建和输出相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取顶层构建目录的路径(build)</span><br><span class="hljs-keyword">set</span>(TOP_LEVEL_BINARY_DIR <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)<br><br><span class="hljs-comment"># 获取当前处理的CMakeLists.txt对应的构建目录的路径</span><br><span class="hljs-keyword">set</span>(CURRENT_BINARY_DIR <span class="hljs-variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)<br><br><span class="hljs-comment"># 设置可执行文件的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-comment"># 设置库文件（动态）的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><br><span class="hljs-comment"># 设置静态库的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/archive)<br></code></pre></td></tr></table></figure></li><li><h3 id="系统和平台相关"><a href="#系统和平台相关" class="headerlink" title="系统和平台相关"></a>系统和平台相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取系统名称，例如Linux、Windows</span><br><span class="hljs-keyword">set</span>(SYSTEM_NAME <span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>)<br><br><span class="hljs-comment"># 获取系统处理器，例如x86_64、AMD64</span><br><span class="hljs-keyword">set</span>(SYSTEM_PROCESSOR <span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><h3 id="C-和编译器相关"><a href="#C-和编译器相关" class="headerlink" title="C++ 和编译器相关"></a>C++ 和编译器相关</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 设置C++编译器的标志</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall&quot;</span>)<br><br><span class="hljs-comment"># 获取编译器的完整路径</span><br><span class="hljs-keyword">set</span>(COMPILER_PATH <span class="hljs-variable">$&#123;CMAKE_CXX_COMPILER&#125;</span>)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>注意：<br>CMAKE_BINARY_DIR是执行cmake命令的目录，外部构建的时候是build目录<br>CMAKE_SOURCE_DIR是项目的根CMakeLists.txt所在目录<br>CMAKE_CURRENT_SOURCE_DIR是当前CMakeLists.txt所在目录</p></blockquote><h3 id="区分预定义变量和自定义变量"><a href="#区分预定义变量和自定义变量" class="headerlink" title="区分预定义变量和自定义变量"></a>区分预定义变量和自定义变量</h3><ul><li><strong>预定义变量</strong>：这些是CMake系统提供的变量，通常以 <code>CMAKE_</code> 开头。它们用于获取关于构建环境和项目配置的信息。</li><li><strong>自定义变量</strong>：您可以通过 <code>set()</code> 命令创建自己的变量。您可以使用这些变量来存储自己的数据，或者修改和存储预定义变量的值。</li></ul><h2 id="构建camke工程的步骤"><a href="#构建camke工程的步骤" class="headerlink" title="构建camke工程的步骤"></a>构建camke工程的步骤</h2><ol><li><p>首先要在每个目录下创建CMakeLists.txt文件</p></li><li><p>嵌套的目录需要使用<code>add_subdirectory</code>调用</p></li><li><p>动态库链接静态库需要添加**-fPIC编译选项**</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cma"># 添加-fPIC编译选项,libA是静态库名<br>set_property(TARGET libA PROPERTY POSITION_INDEPENDENT_CODE ON)<br></code></pre></td></tr></table></figure></li></ol><h2 id="常用命令大全"><a href="#常用命令大全" class="headerlink" title="常用命令大全"></a>常用命令大全</h2><ol><li><h3 id="设置全局c-标准"><a href="#设置全局c-标准" class="headerlink" title="设置全局c++标准"></a>设置全局c++标准</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置全局C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br></code></pre></td></tr></table></figure></li><li><h3 id="指定文件生成目录"><a href="#指定文件生成目录" class="headerlink" title="指定文件生成目录"></a>指定文件生成目录</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置可执行文件和库文件的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs)<br></code></pre></td></tr></table></figure></li><li><h3 id="添加子目录"><a href="#添加子目录" class="headerlink" title="添加子目录"></a>添加子目录</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 添加子目录,括号内是子目录名称</span><br><span class="hljs-keyword">add_subdirectory</span>(external)<br><span class="hljs-keyword">add_subdirectory</span>(lib)<br><span class="hljs-keyword">add_subdirectory</span>(app)<br><span class="hljs-keyword">add_subdirectory</span>(tests)<br></code></pre></td></tr></table></figure></li><li><h3 id="生成库文件"><a href="#生成库文件" class="headerlink" title="生成库文件"></a>生成库文件</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(libname SHARED src/mylib.cpp)  <span class="hljs-comment">#生成动态库文件libname</span><br><span class="hljs-keyword">add_library</span>(libname STATIC src/mylib.cpp)  <span class="hljs-comment">#生成静态库文件libname</span><br></code></pre></td></tr></table></figure></li><li><h3 id="为目标添加头文件搜索路径"><a href="#为目标添加头文件搜索路径" class="headerlink" title="为目标添加头文件搜索路径"></a>为目标添加头文件搜索路径</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(libA PUBLIC <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libA)<br></code></pre></td></tr></table></figure></li><li><h3 id="为目标添加库文件搜索路径"><a href="#为目标添加库文件搜索路径" class="headerlink" title="为目标添加库文件搜索路径"></a>为目标添加库文件搜索路径</h3> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(libA PRIVATE <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure></li><li><h3 id="为目标链接库"><a href="#为目标链接库" class="headerlink" title="为目标链接库"></a>为目标链接库</h3></li></ol>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(myApp PRIVATE libA libB libExternal)<br><span class="hljs-comment">#myqpp是可执行文件（也可以是库文件）</span><br><span class="hljs-comment">#libA，libB，libExternal是库文件</span><br></code></pre></td></tr></table></figure><ol start="8"><li><h3 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h3><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li><p><strong>file(READ)</strong></p><p> 用于将文件内容读取到变量中。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(READ &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;max-in&gt;] [HEX])<br></code></pre></td></tr></table></figure></li><li><p><strong>file(WRITE)</strong></p><p> 用于将内容写入文件。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(WRITE &lt;filename&gt; <span class="hljs-string">&quot;&lt;content&gt;&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(APPEND)</strong></p><p> 用于向文件中追加内容。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(APPEND &lt;filename&gt; <span class="hljs-string">&quot;&lt;content&gt;&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(TOUCH)</strong></p><p> 用于创建空文件或者更新文件的时间戳。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(TOUCH &lt;filename&gt;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><ol><li><p><strong>file(GLOB)</strong></p><p> 用于匹配规则在指定的目录内匹配到所需要的文件。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="hljs-keyword">true</span>[<span class="hljs-keyword">false</span>]] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expression&gt; ...])<br></code></pre></td></tr></table></figure></li><li><p><strong>file(GLOB_RECURSE)</strong></p><p> 用于递归匹配文件，包括子目录中的文件。</p></li><li><p><strong>file(RENAME)</strong></p><p> 用于重命名文件。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(RENAME &lt;old-name&gt; &lt;new-name&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(REMOVE)</strong></p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(<span class="hljs-keyword">REMOVE</span> &lt;filename&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(MAKE_DIRECTORY)</strong></p><p> 用于创建目录。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(<span class="hljs-keyword">MAKE_DIRECTORY</span> &lt;directory&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(COPY)</strong></p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(COPY &lt;files&gt;... DESTINATION &lt;dir&gt; [...])<br></code></pre></td></tr></table></figure></li><li><p><strong>file(INSTALL)</strong></p><p> 用于将文件安装到指定目录中。</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(<span class="hljs-keyword">INSTALL</span> &lt;files&gt;... DESTINATION &lt;dir&gt; [...])<br></code></pre></td></tr></table></figure></li></ol><h3 id="路径转换"><a href="#路径转换" class="headerlink" title="路径转换"></a>路径转换</h3><ol><li><p><strong>file(RELATIVE_PATH)</strong></p><p> 用于获取相对路径。</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">cmakeCopy code<br><span class="hljs-built_in">file</span>(RELATIVE_PATH &lt;<span class="hljs-built_in">variable</span>&gt; &lt;<span class="hljs-built_in">directory</span>&gt; &lt;<span class="hljs-built_in">file</span>&gt;)<br></code></pre></td></tr></table></figure></li><li><p><strong>file(TO_CMAKE_PATH)</strong></p><p> 用于将路径转换为CMake风格的路径。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cmakeCopy <span class="hljs-selector-tag">code</span><br><span class="hljs-function"><span class="hljs-title">file</span><span class="hljs-params">(TO_CMAKE_PATH &lt;path&gt; &lt;variable&gt;)</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>file(TO_NATIVE_PATH)</strong></p><p> 用于将路径转换为本地操作系统风格的路径。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cmakeCopy <span class="hljs-selector-tag">code</span><br><span class="hljs-function"><span class="hljs-title">file</span><span class="hljs-params">(TO_NATIVE_PATH &lt;path&gt; &lt;variable&gt;)</span></span><br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h3><p> 查ai</p></li></ol><h1 id="添加外部库实战"><a href="#添加外部库实战" class="headerlink" title="添加外部库实战"></a>添加外部库实战</h1><h2 id="boost库"><a href="#boost库" class="headerlink" title="boost库"></a>boost库</h2><ol><li><p>执行命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install libboost-all-dev<br></code></pre></td></tr></table></figure></li><li><p>在CMake中找到Boost库</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(MyComplexProject VERSION <span class="hljs-number">1.0</span>)<br><br><span class="hljs-comment"># 设置全局C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment">#设置可执行文件和库的输出目录</span><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/libs)<span class="hljs-comment">#动态库</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/archive)<span class="hljs-comment">#静态库</span><br><br><span class="hljs-comment"># 找到Boost库</span><br><span class="hljs-keyword">find_package</span>(Boost <span class="hljs-number">1.65</span> REQUIRED COMPONENTS system filesystem)<br><br><span class="hljs-comment"># 如果找到了Boost，包括Boost的头文件目录</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;找到了Boost库 $&#123;Boost_VERSION_MAJOR&#125;.$&#123;Boost_VERSION_MINOR&#125;.$&#123;Boost_VERSION_PATCH&#125; in $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(external)<br><span class="hljs-keyword">add_subdirectory</span>(lib)<br><span class="hljs-keyword">add_subdirectory</span>(app)<br><span class="hljs-keyword">add_subdirectory</span>(tests)<br></code></pre></td></tr></table></figure></li><li><p>链接Boost库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(myApp src/main.cpp)<br><span class="hljs-comment"># 链接Boost库</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;链接成功：Boost_INCLUDE_DIRS: $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">target_link_libraries</span>(myApp PRIVATE <span class="hljs-variable">$&#123;Boost_LIBRARIES&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><span class="hljs-keyword">target_link_libraries</span>(myApp PRIVATE libA libB libExternal)<br><span class="hljs-keyword">target_include_directories</span>(myApp PRIVATE <br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libA <br>    <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/libB<br>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="opencv库"><a href="#opencv库" class="headerlink" title="opencv库"></a>opencv库</h2><h2 id="Json库"><a href="#Json库" class="headerlink" title="Json库"></a>Json库</h2><h1 id="根CMakeLists-txt文件"><a href="#根CMakeLists-txt文件" class="headerlink" title="根CMakeLists.txt文件"></a>根CMakeLists.txt文件</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-comment"># 设置项目名称和版本</span><br><span class="hljs-keyword">project</span>(MyComplexProject VERSION <span class="hljs-number">1.0</span>)<br><br><span class="hljs-comment"># 设置全局 C++ 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-comment"># 如果没有指定构建类型，则默认设置为 Debug</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>    <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;构建类型: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class="hljs-comment"># 设置可执行文件和库的输出目录</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;CMAKE_SOURCE_DIR: $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;可执行文件输出目录: $&#123;CMAKE_SOURCE_DIR&#125;/bin&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;动态库输出目录: $&#123;CMAKE_SOURCE_DIR&#125;/lib&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;静态库输出目录: $&#123;CMAKE_SOURCE_DIR&#125;/archive&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)  <span class="hljs-comment"># 可执行文件</span><br><span class="hljs-keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)  <span class="hljs-comment"># 动态库</span><br><span class="hljs-keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/archive)  <span class="hljs-comment"># 静态库</span><br><br><span class="hljs-comment"># 设置 CMake 以查找 Boost 的动态库</span><br><span class="hljs-keyword">set</span>(Boost_USE_STATIC_LIBS <span class="hljs-keyword">OFF</span>)        <span class="hljs-comment"># 只使用 Boost 的动态库</span><br><span class="hljs-keyword">set</span>(Boost_USE_MULTITHREADED <span class="hljs-keyword">ON</span>)       <span class="hljs-comment"># 使用多线程版本的 Boost</span><br><span class="hljs-keyword">set</span>(Boost_USE_STATIC_RUNTIME <span class="hljs-keyword">OFF</span>)     <span class="hljs-comment"># 不使用 Boost 静态运行时库</span><br><br><span class="hljs-comment"># 查找 Boost 库</span><br><span class="hljs-keyword">find_package</span>(Boost <span class="hljs-number">1.65</span> REQUIRED COMPONENTS system filesystem)<br><br><span class="hljs-comment"># 如果找到了 Boost，则包含 Boost 的头文件目录</span><br><span class="hljs-keyword">if</span>(Boost_FOUND)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;找到了 Boost 库 $&#123;Boost_VERSION_MAJOR&#125;.$&#123;Boost_VERSION_MINOR&#125;.$&#123;Boost_VERSION_PATCH&#125; 在 $&#123;Boost_INCLUDE_DIRS&#125;&quot;</span>)<br>    <span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><br><span class="hljs-comment"># 添加源代码子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(server)<br><span class="hljs-keyword">add_subdirectory</span>(src)<br><br><span class="hljs-comment"># 根据构建类型添加编译器标志</span><br><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Debug&quot;</span>)<br>    <span class="hljs-keyword">add_compile_options</span>(-g -O0 -Wall -Wextra -Werror)  <span class="hljs-comment"># Debug模式的编译器标志</span><br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">add_compile_options</span>(-O2)  <span class="hljs-comment"># 非Debug模式的优化选项</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>Cmake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用指令</title>
    <link href="/2023/12/10/linux/vim/"/>
    <url>/2023/12/10/linux/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="一般命令模式"><a href="#一般命令模式" class="headerlink" title="一般命令模式"></a>一般命令模式</h2><ul><li>0：将光标移动到本行开头</li><li>$：将光标移动到本行末尾</li><li>G：将光标移动到最后一行</li><li>gg：将光标移动到第一行</li><li>:n或者nG(n为数字)：将光标移动到第n行</li><li>n&lt;Space&gt;：将光标向后移动n格（会换行）</li><li>n&lt;Enter&gt;：将光标向下移动n行</li><li>重复前一次操作（结合命令模式的查找）</li></ul><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>无常用操作</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li>&#x2F;word：光标位置下查找第一个word字符串</li><li>?word：光标位置上查找第一个word字符串</li><li>n：重复上一次操作，配合查找使用</li><li>N：反向重复上一次操作</li><li>:noh：关闭查找后的高亮</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：将$[n1,n2]$行所有的word1替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：全文替换，将全文word1替换为word2，并且替换前要求用户确认</li><li>v：选中文本，按两下   Esc  取消选中</li><li>d：剪切选中文本（开启删除模式）</li><li>dd：剪切一行</li><li>y：复制选中文本</li><li>yy：复制一行</li><li>p：将剪切的内容复制到<strong>光标的下一个位置（或者下一行）</strong>，这个取决于是否剪切（复制）一行</li><li>u：撤销</li><li>Ctrl+r：取消撤销</li><li>Shrift+&gt;：将选中的内容向右移动</li><li>Shritf+&lt;：将选中的内容向左移动</li><li>:set paste：设置成粘贴模式</li><li>:set nopaste：设置成非粘贴模式</li><li>:set nu：显示行号</li><li>:set nonu：取消显示行号</li></ul><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><ul><li>gg d G：删除所有内容     行号+d+行号</li><li>5G d 10G：删除$[5,10]$行的所有内容</li><li>gg &#x3D; G：格式化整个文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode配置</title>
    <link href="/2023/12/05/vscode%E8%B0%83%E8%AF%95/"/>
    <url>/2023/12/05/vscode%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>本文介绍vscode里的相关配置</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="对于-词-的操作："><a href="#对于-词-的操作：" class="headerlink" title="对于 词 的操作："></a>对于 <strong>词</strong> 的操作：</h2><ul><li>选中一个词：ctrl<code> + d</code></li></ul><h2 id="搜索或者替换："><a href="#搜索或者替换：" class="headerlink" title="搜索或者替换："></a>搜索或者替换：</h2><ul><li>ctrl<code> + f</code> ：搜索</li><li>ctrl<code> + alt + f</code>： 替换</li><li>ctrl<code> + shift + f</code>：在项目内搜索</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>通过<strong>Ctrl + &#96;</strong> 可以打开或关闭终端</li><li>Ctrl+P 快速打开最近打开的文件</li><li>Ctrl+Shift+N 打开新的编辑器窗口</li><li>Ctrl+Shift+W 关闭编辑器</li><li>Home 光标跳转到行头</li><li>End 光标跳转到行尾</li><li>Ctrl + Home 跳转到页头</li><li>Ctrl + End 跳转到页尾</li><li>Ctrl + Shift + [ 折叠区域代码</li><li>Ctrl + Shift + ] 展开区域代码</li><li>Ctrl + &#x2F; 添加关闭行注释</li><li>Shift + Alt +A 块区域注释</li><li><strong>Ctrl+Shift+P</strong> <strong>强大的</strong>命令窗口</li></ol><h1 id="Json讲解"><a href="#Json讲解" class="headerlink" title="Json讲解"></a>Json讲解</h1><p><strong>牢记</strong><code>&#123; &#125;</code>中的内容表示一个对象，<code>[ ]</code>中的内容表示一个数组。</p><h2 id="task-json"><a href="#task-json" class="headerlink" title="task.json"></a>task.json</h2><p>tasks.json可以编辑多个任务，只需要在tasks后继续添加即可，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;HelloTask&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;echo Hello&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;ByeTask&quot;</span>,<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,<br>            <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;echo bye&quot;</span><br>        &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面分别创建了HelloTask和ByeTask两个任务。</p></blockquote><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫描线</title>
    <link href="/2023/12/01/%E7%AE%97%E6%B3%95/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <url>/2023/12/01/%E7%AE%97%E6%B3%95/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>本文介绍扫描线的几个题目</p><h1 id="二维偏序"><a href="#二维偏序" class="headerlink" title="二维偏序"></a>二维偏序</h1><h2 id="E-World-of-Darkraft-Battle-for-Azathoth"><a href="#E-World-of-Darkraft-Battle-for-Azathoth" class="headerlink" title="E. World of Darkraft: Battle for Azathoth"></a><a href="https://codeforces.com/problemset/problem/1321/E">E. World of Darkraft: Battle for Azathoth</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一些武器和防具，每个武器有<strong>攻击力</strong>，<strong>花费</strong>,每个防具有<strong>防御力</strong>和<strong>花费</strong></p><p>给定一些怪物，每个怪物有<strong>攻击力</strong>，<strong>防御力</strong>，<strong>价值</strong></p><p>你只可以选择一个武器和一个防具，可以获得攻击力小于武器并且防御力小于防具的所有怪物的价值，求最大收益</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将武器和怪物按照攻击力排序，防具自己排序，并且按照防具的防御力防具顺序（id）建立<strong>下标线段树</strong></li><li><strong>双指针</strong>i指向武器，j指向怪物，当i指针向右边移动1个，j指针只会向右边移动，且以后的i一定可以选到当前的怪物j，所以当前的j造成的贡献会一直保留。所以将j的贡献加到线段树中即可</li><li>对于每一个武器i算最大价值，详细见代码</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>ll g;<br>ll c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> A&amp;a)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> g&lt;a.g;<br>&#125;<br>&#125;a[N];<span class="hljs-comment">//gong</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>&#123;<br>ll f;<br>ll c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> B&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> f&lt;b.f;<br>&#125;<br>&#125;b[N];<span class="hljs-comment">//fang</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&#123;<br>ll g,f;<br>ll c;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> C&amp;c)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> g&lt;c.g;<br>&#125;<br>&#125;c[N];<span class="hljs-comment">//monster</span><br><br>ll maxn[N&lt;&lt;<span class="hljs-number">2</span>];<br>ll tag[N&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>ll lx=u&lt;&lt;<span class="hljs-number">1</span>;<br>ll rx=u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>;<br>maxn[u]=<span class="hljs-built_in">max</span>(maxn[lx],maxn[rx]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>ll lx=u&lt;&lt;<span class="hljs-number">1</span>;<br>ll rx=u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(tag[u])&#123;<br>maxn[lx]+=tag[u];<br>maxn[rx]+=tag[u];<br>tag[lx]+=tag[u];<br>tag[rx]+=tag[u];<br>&#125;<br>tag[u]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>maxn[u]=-b[l].c;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R,ll x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)&#123;<br>maxn[u]+=x;<br>tag[u]+=x;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">pushdown</span>(u);<br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)&#123;<br><span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid,L,R,x);<br>&#125;<br><span class="hljs-keyword">if</span>(R&gt;mid)&#123;<br><span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,L,R,x);<br>&#125;<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n,m,p;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;<br>    <span class="hljs-comment">//输入武器属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i].g&gt;&gt;a[i].c;<br>&#125;<br>    <span class="hljs-comment">//输入防具属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;b[i].f&gt;&gt;b[i].c;<br>&#125;<br>    <span class="hljs-comment">//输入怪物属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)&#123;<br>cin&gt;&gt;c[i].g&gt;&gt;c[i].f&gt;&gt;c[i].c;<br>&#125;<br>    <span class="hljs-comment">//排序</span><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);<br><span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+m);<br><span class="hljs-built_in">sort</span>(c+<span class="hljs-number">1</span>,c+<span class="hljs-number">1</span>+p);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m);<br>    <br><span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>ll ans=<span class="hljs-number">-1e18</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//暴力加入怪物的价值</span><br><span class="hljs-keyword">while</span>(j&lt;=p&amp;&amp;c[j].g&lt;a[i].g)&#123;<br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=m;<br><span class="hljs-type">int</span> pos=m+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b[mid].f&gt;c[j].f)&#123;<br>pos=mid;<br>r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>l=mid+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>            <span class="hljs-comment">//[pos,m]下标中所有防具需要加上c价值</span><br><span class="hljs-keyword">if</span>(pos&lt;=m)&#123;<span class="hljs-comment">//update</span><br><span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m,pos,m,c[j].c);<br>&#125;<br>++j;<br>&#125;<br>        <span class="hljs-comment">//计算选择当前武器的答案</span><br>ans=<span class="hljs-built_in">max</span>(ans,maxn[<span class="hljs-number">1</span>]-a[i].c);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Number-of-Groups"><a href="#E-Number-of-Groups" class="headerlink" title="E. Number of Groups"></a><a href="https://codeforces.com/contest/1691/problem/E">E. Number of Groups</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一些线段[x,y]，每个线段有一个颜色（0或者1），如果两个不同颜色的线段有交集，那他们在同一组，问有多少不同的组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>将一个线段的x，y看成时间（time），将插入和删除看成时间（event），显然，一个线段的x是插入，y是删除，这是典型的扫描线想法</li><li>按照(time,event)排序，对于插入操作，我们需要知道可以和哪些线段合并，同时自己要记录自己在那个集合中</li><li>显然并查集</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>开两个集合，存每种颜色的线段<strong>右端点</strong>即可</li><li>按照（time，event）排序后，遍历所有点对，如果是插入操作，查询谁跟他一组，暴力合并，如果是删除操作，删除这个点对即可。但是此时会超时，因为每个线段都可以被合并很多次，复杂度不可以保证。</li><li>考虑贪心，若两个0颜色线段在同一个集合中，此时他们肯定都没有删除，此时遍历到第i个<strong>点对</strong>，那么，如果是插入操作，此时只需要和最后一个合并即可（如果可以的话），因为合并的前提是当前点对的time，也就是<code>另一个线段的左端点&lt;=一个线段的左端点要&lt;=另一个线段的右端点</code>，所以贪心即可，边合并边删除即可，具体看代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br>ll n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> col;<br><span class="hljs-type">int</span> l,r;<br>&#125;a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-type">int</span> pos;<br><span class="hljs-type">bool</span> in;<span class="hljs-comment">//是否需要插入</span><br><span class="hljs-type">int</span> id;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> B&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">if</span>(pos!=b.pos)<span class="hljs-keyword">return</span> pos&lt;b.pos;<br><span class="hljs-keyword">if</span>(in!=b.in)<span class="hljs-keyword">return</span> in&gt;b.in;<br><span class="hljs-keyword">return</span> id&lt;b.id;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;B&gt;v;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>f[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i].col&gt;&gt;a[i].l&gt;&gt;a[i].r;<br>v.<span class="hljs-built_in">push_back</span>(&#123;a[i].l,<span class="hljs-number">1</span>,i&#125;);<br>v.<span class="hljs-built_in">push_back</span>(&#123;a[i].r,<span class="hljs-number">0</span>,i&#125;);<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;p[<span class="hljs-number">2</span>];<span class="hljs-comment">//0表示第一个集合，1表示第二个集合</span><br><span class="hljs-comment">//pos,id</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> qq:v)&#123;<br><span class="hljs-type">int</span> id=qq.id;<span class="hljs-comment">//id</span><br><span class="hljs-type">bool</span> in=qq.in;<span class="hljs-comment">//in</span><br><span class="hljs-type">int</span> pos=qq.pos;<span class="hljs-comment">//pos</span><br><span class="hljs-type">int</span> col=a[id].col;<span class="hljs-comment">//col</span><br><span class="hljs-keyword">if</span>(in)&#123;<br><span class="hljs-comment">//插入到本集合中</span><br>p[col].<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(a[id].r,id));<br><span class="hljs-comment">//匹配另外一个集合的元素，并且保留最后一个</span><br><span class="hljs-keyword">while</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>f[<span class="hljs-built_in">find</span>(id)]=<span class="hljs-built_in">find</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()-&gt;second);<br>p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>());<br>&#125;<br>            <span class="hljs-comment">//最后一个还没验证是否可以合并呢</span><br><span class="hljs-keyword">if</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>f[<span class="hljs-built_in">find</span>(id)]=<span class="hljs-built_in">find</span>(p[col^<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>()-&gt;second);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>p[col].<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">make_pair</span>(a[id].r,id));<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==i)ans++;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="P4137-Rmq-Problem-mex"><a href="#P4137-Rmq-Problem-mex" class="headerlink" title="P4137 Rmq Problem &#x2F; mex"></a><a href="https://www.luogu.com.cn/problem/P4137">P4137 Rmq Problem &#x2F; mex</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个序列，多次询问，区间mex是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol><li>莫队秒了</li><li>权值线段树扫描线，扫描序列，到达第i个位置的时候，处理以第i个位置为右端点的所有询问。转化为求最小的x，满足$pos[x]&lt;l$,x就是第id个询问的答案,显然可以用线段树二分。</li><li>只需要将权值x当成下标就可以，支持更新pos[x]，和区间查询即可</li><li>注意权值从0开始</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>莫队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><p>权值线段树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> minn[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;v[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>minn[u] = <span class="hljs-built_in">min</span>(minn[u &lt;&lt; <span class="hljs-number">1</span>], minn[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">//修改pos为x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>minn[u] = x;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (pos &lt;= mid) &#123;<br><span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, pos, x);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, x);<br>&#125;<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-comment">//在L到R内查询比tar小的最小的下标（pos[x]&lt;tar,最小的x)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> tar)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br><span class="hljs-keyword">if</span> (minn[u] &lt; tar)<br><span class="hljs-keyword">return</span> l;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;<br><span class="hljs-type">int</span> ans = n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span>] &lt; tar) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, tar);<br>&#125;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] &lt; tar) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, tar);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> ans = n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span>] &lt; tar &amp;&amp; L &lt;= mid) &#123;<br>ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, tar));<br>&#125;<br><span class="hljs-keyword">if</span> (minn[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]&lt;tar &amp;&amp; R&gt;mid) &#123;<br>ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, tar));<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i];<br>a[i] = <span class="hljs-built_in">min</span>(a[i], n + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-type">int</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br>v[r].<span class="hljs-built_in">push_back</span>(&#123; l,i &#125;);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>, a[i], i);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> que : v[i]) &#123;<br><span class="hljs-type">int</span> l = que.first;<br><span class="hljs-type">int</span> id = que.second;<br>ans[id] = <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, i, l);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>cout &lt;&lt; ans[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>扫描线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容斥原理</title>
    <link href="/2023/11/30/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/30/%E7%AE%97%E6%B3%95/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="线性容斥"><a href="#线性容斥" class="headerlink" title="线性容斥"></a>线性容斥</h1><h2 id="D-Counting-Rhyme"><a href="#D-Counting-Rhyme" class="headerlink" title="D. Counting Rhyme"></a><a href="https://codeforces.com/contest/1884/problem/D">D. Counting Rhyme</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题目大意：有一个长度为n的数组a，如果对于一个数个(a[i],a[j]）满足不存在a[k]使a[i]%a[k]&#x3D;0且a[j]%a[k]&#x3D;0，则称这个数对是合法的，求合法数对的数量。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>对于任意一个a[k],如果这个数合法,则**没有点对（i，j)**，满足$gcd(a[i],a[j])%a[k]&#x3D;0$</p></li><li><p>考虑单点贡献，因为点对贡献是$O(n^2)$的复杂度</p></li><li><p>考虑dp，设$dp[g]$表示$gcd(a[i],a[j])&#x3D;g$的点对数，则$ans&#x3D;\sum_{a_k\nmid g\forall k\in[1,n]}dp_g$</p></li><li><p>具体如何求$dp[g]$：如果我们知道一个多重集合中，任意两个数的gcd都是g的倍数，那么就好做了</p><p> <code>dp[g]=C(cnt,2)-dp[2*g]-dp[3*g]-…dp[k*g]</code>(C表示组合数，cnt表示集合中的多重集中元素个数)</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br>ll dp[N];<br>ll a[N];<br>ll cnt[N];<br>ll n;<br><span class="hljs-type">bool</span> biaoji[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>dp[i]=cnt[i]=biaoji[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>cnt[a[i]]++;<br>&#125;<br>ll zong=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll g=n;g&gt;=<span class="hljs-number">1</span>;g--)&#123;<br>ll sum=cnt[g];<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">2</span>;k*g&lt;=n;k++)&#123;<br>dp[g]-=dp[k*g];<br>sum+=cnt[k*g];<br>&#125;<br>dp[g]+=sum*(sum<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!cnt[i])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j*i&lt;=n;j++)&#123;<br>biaoji[j*i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//有存在的a[k]使得这个gcd做不了贡献！！</span><br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!biaoji[i])&#123;<br>ans+=dp[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，最后要算点对数，而不是a[k]的数目，所以关键是判断哪些点对合法。</p><p>而dp[g]就是表示gcd恰好等于g的所有点对数，所以只需要判断哪些g合法即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>exgcd</title>
    <link href="/2023/11/30/%E7%AE%97%E6%B3%95/exgcd/"/>
    <url>/2023/11/30/%E7%AE%97%E6%B3%95/exgcd/</url>
    
    <content type="html"><![CDATA[<h1 id="exgcd反向应用"><a href="#exgcd反向应用" class="headerlink" title="exgcd反向应用"></a>exgcd反向应用</h1><h2 id="ICPC2022杭州A-Modulo-Ruins-the-Legend"><a href="#ICPC2022杭州A-Modulo-Ruins-the-Legend" class="headerlink" title="ICPC2022杭州A. Modulo Ruins the Legend"></a><a href="https://codeforces.com/gym/104090/problem/A">ICPC2022杭州A. Modulo Ruins the Legend</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个n和m，给一个数列a，求一个等差数列b，满足$\sum(a_i+b_i)$模m最小，求s和d，s&gt;&#x3D;0,d&gt;&#x3D;0</p><p>其中$b_i&#x3D;s+d*i$.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>假设sum&#x3D;$\sum(a_i)$,则可以看成求$sum+n<em>s+(n+1)<em>n&#x2F;2</em>d&#x3D;k</em>m+ans$</p><p> 其中ans就是我们要求的最小值</p></li><li><p>先<code>sum%=m</code>，设<code>A=n,B=(n+1)*n/2</code>，则利用exgcd化成$A<em>x+B</em>y+sum&#x3D;k*m+ans$</p></li><li><p>设$A<em>x+B</em>y&#x3D;k_1<em>gcd(A,B)$,则化成$k_1</em>gcd(A,B)-k_2*m&#x3D;ans-sum$</p></li><li><p>容易知道$ans\in[0,m-1]$,则$ans-sum\in[-sum,-sum+m-1]$,在确定最小的ans后，解出k1</p></li><li><p>解出k1，反解出x和y，再利用m求解即可，具体看代码</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<br>ll n,m;<br>ll sum;<br><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a,ll b,__int128 &amp;x,__int128 &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)<br>    &#123;<br>        x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    ll d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y-=(a/b*x);<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>ll x;<br>cin&gt;&gt;x;<br>sum+=x;<br>&#125;<br>sum%=m;<br>ll A=n,B=(n+<span class="hljs-number">1</span>)*n/<span class="hljs-number">2</span>;<br>ll g=__gcd(A,B);<br><br><span class="hljs-comment">//k1*g+sum=k2*m+ans;</span><br><span class="hljs-comment">//k1*g-k2*m=ans-sum=k3*gcd(g,m)</span><br><br>__int128 x,y;<br>ll t=<span class="hljs-built_in">exgcd</span>(g,m,x,y);<span class="hljs-comment">//t&gt;0</span><br>ll ans=sum%t;<br>x*=(ans-sum)/t;<span class="hljs-comment">//k1</span><br><br>ll k1=x;<br><span class="hljs-comment">//A*x+B*y=k1g</span><br>t=<span class="hljs-built_in">exgcd</span>(A,B,x,y);<span class="hljs-comment">//t&gt;0</span><br>x*=k1;<br>y*=k1;<br><br><span class="hljs-comment">//A*x+B*y-k*m=ans-sum</span><br>x=(x%m+m)%m;<br>y=(y%m+m)%m;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br>cout&lt;&lt;(ll)x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;(ll)y&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有几点特别重要！！！</p><ol><li>我们注意到，题目要求s和d都为<code>非负数</code>（代码中是x和y），但是我们在求解的过程中，没有管k1，k2的正负，更没有管x和y的正负</li><li>而且x和y最后都利用m缩小到[0,m-1]的范围内，这好像也没什么逻辑</li><li>关于第2点，注意到，<strong>换元k1相当于</strong>$A<em>x+B</em>y-k_2<em>m&#x3D;ans-sum$，第一次求出的x和y一定是方程的解，但是正负不确定。但是，我可以使$x&#x3D;x+k3</em>m,y&#x3D;y+k4*m$,再利用k2削减掉多出来的m，此时方程仍然成立，也就保证了正确性</li><li>注意exgcd只可以处理$A<em>x+B</em>y&#x3D;ans-sum$,不可以处理$A<em>x+B</em>y-k*m&#x3D;ans-sum$,不可以跳步！！</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2023/11/29/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2023/11/29/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍树形dp比较难的状态设计和考虑方式</p><h1 id="边贡献型"><a href="#边贡献型" class="headerlink" title="边贡献型"></a>边贡献型</h1><p>贡献放置到边上</p><h2 id="P3177-HAOI2015-树上染色"><a href="#P3177-HAOI2015-树上染色" class="headerlink" title="P3177 [HAOI2015] 树上染色"></a><a href="https://www.luogu.com.cn/problem/P3177">P3177 [HAOI2015] 树上染色</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵点数为 <em>n</em> 的树，树边有边权。给你一个在 0∼<em>n</em> 之内的正整数 <em>k</em> ，你要在这棵树中选择 <em>k</em> 个点，将其染成黑色，并将其他的 <em>n</em>−<em>k</em> 个点染成白色。将所有点染色后，你会获得<strong>黑点两两之间</strong>的距离加上<strong>白点两两之间</strong>的距离的和的收益。问收益最大值是多少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>设dp[u][j]表示以u为根的子树中，选j个黑色点，获取到的最大价值（这个价值只是在子树<strong>内部</strong>的价值，子树外部的价值不算），答案是dp[root][k]</li><li>可能现在还不理解1，那么看转移方程：<br> <code>dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]+val)</code>,这个val是v子树中选k个点，u和v<strong>直连边</strong>可以贡献的价值，这个价值很好算，看代码即可。</li><li>代码中计算val没有用到j，只是用到了k，那可能会有疑问，为什么要这样设计j这一维度呢？？因为可以转移，背下来即可。</li><li><strong>转移的正确性</strong>:我们说v是u的儿子，但实际上，我们在进行<strong>合并操作</strong>，因为当利用v计算u的时候，<strong>v并没有看成在u中</strong>，所以是合并操作。<strong>这样第3条就解释通了</strong>：我们需要将u”子树“”和v”子树”合并，而合并的之前，u，v内部如何选择黑色点是毫无关系的，而且获取到的最大价值<strong>只</strong>在自己子树内部，而且已经被统计好。dp的含义是<strong>内部边</strong>的价值，所以需要j那一维度。</li><li>注意代码中状态计算的方式，只有这种方式才可以保证复杂度是$O(n^2)$</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=N*<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> idx;<br>ll h[N],e[M],ne[M],w[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>e[++idx]=b;<br>w[idx]=c;<br>ne[idx]=h[a];<br>h[a]=idx;<br>&#125;<br><br>ll n,m;<br>ll siz[N];<br>ll dp[N][N];<span class="hljs-comment">//以u为根的子树，恰好选了j个黑色点的最大收益(收益是内部边的收益)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br><span class="hljs-type">static</span> ll tem[N];<span class="hljs-comment">//辅助数组</span><br>siz[u]=<span class="hljs-number">1</span>;<br>dp[u][<span class="hljs-number">0</span>]=dp[u][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<span class="hljs-comment">//枚举层，所有儿子在同一层，按照访问儿子的先后顺序划分层</span><br><span class="hljs-type">int</span> v=e[i];<br><span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v,u);<span class="hljs-comment">//要siz[j]和dp[j][]数组</span><br><br>        <span class="hljs-comment">//必须先初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=siz[u]+siz[v];i++)&#123;<br>tem[i]=<span class="hljs-number">-1e9</span>;<br>&#125;<br>        <br>        <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=siz[u];j++)&#123;<span class="hljs-comment">//前层子树,一共选j个点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=siz[v];k++)&#123;<span class="hljs-comment">//新子树选k个</span><br><span class="hljs-keyword">if</span>(j+k&lt;=m)&#123;<span class="hljs-comment">//只有合法才可以转移</span><br>ll val=(ll)(k*(m-k)+(siz[v]-k)*(n-m-siz[v]+k))*w[i];  <span class="hljs-comment">//当前情况下连接子节点的边的贡献</span><br>tem[j+k]=<span class="hljs-built_in">max</span>(tem[j+k],dp[u][j]+dp[v][k]+val);<br>&#125;<br>&#125;<br>&#125;<br>        <br><span class="hljs-comment">//合并两颗树</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=siz[u]+siz[v];j++)&#123;<br>dp[u][j]=tem[j];<br>&#125;<br>siz[u]+=siz[v];<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">add</span>(a,b,c);<br><span class="hljs-built_in">add</span>(b,a,c);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][m]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="牛客多校Tree"><a href="#牛客多校Tree" class="headerlink" title="牛客多校Tree"></a><a href="https://ac.nowcoder.com/acm/contest/57360/A">牛客多校Tree</a></h2><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一棵树，每个点选择黑、白有对应的代价，定义一棵树的收益为所有黑白点对间路径边权最大值的和，问如何选择每个点的颜色使得收益-代价最大？</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>因为边权最大值才可以算贡献，所以建立kruskal重构树，这样<strong>边的贡献只会在子树内部</strong>,所以可以用树形dp做</li><li>设dp[u][j]表示以u为根的子树中选j个黑色点的最大价值，此时价值只会统计到u子树的内部</li><li>重构树是二叉堆，这样很好的诠释了“合并”的思想，而且，我们<strong>只需要知道</strong>合并后的那颗树的信息,因为只有这样的信息，才会被后续用到。</li><li>上一题，v一旦被合并到u中，v的信息就再也用不到了，实际上我们也可以将u的信息合并到v中，但是不方便，因为我们还要计算u与它的father的边的贡献。</li><li>注意代码中状态计算的方式，只有这种方式才可以保证复杂度是$O(n^2)$</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=N;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll n;<br>ll a[N];<br>ll cost[N];<br>ll dp[N][N];<span class="hljs-comment">//以u为根的子树中，选择黑色点的个数为j的最大价值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>ll u,v,w;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> A&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> w&lt;b.w;<br>&#125;<br>&#125;ed[M];<br><br><span class="hljs-type">int</span> siz[N];<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ll u,ll v,ll w)</span></span>&#123;<br><span class="hljs-type">static</span> ll tem[N];<br>u=<span class="hljs-built_in">find</span>(u),v=<span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(siz[u]&gt;siz[v])<span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-type">int</span> n=siz[u],m=siz[v];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+m;i++)<br>tem[i]=<span class="hljs-number">-1e9</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//枚举前层子树(v)的黑色点个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//枚举新子树(u)的黑色点个数</span><br>ll cnt=(ll)i*(n-j)+(ll)(m-i)*j;<br>tem[i+j]=<span class="hljs-built_in">max</span>(tem[i+j],dp[v][i]+dp[u][j]+cnt*w);<br>&#125;<br>&#125;<br>f[u]=v;<br>siz[v]+=siz[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n+m;j++)<br>dp[v][j]=tem[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>siz[i]=<span class="hljs-number">1</span>;<br>f[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;cost[i];<br>dp[i][<span class="hljs-number">0</span>]=(a[i]==<span class="hljs-number">0</span>)?<span class="hljs-number">0</span>:-cost[i];<br>dp[i][<span class="hljs-number">1</span>]=(a[i]==<span class="hljs-number">1</span>)?<span class="hljs-number">0</span>:-cost[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>ll a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>ed[i]=&#123;a,b,c&#125;;<br>&#125;<br><span class="hljs-built_in">sort</span>(ed+<span class="hljs-number">1</span>,ed+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>ll u=ed[i].u;<br>ll v=ed[i].v;<br>ll w=ed[i].w;<br><span class="hljs-built_in">merge</span>(u,v,w);<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>ans=<span class="hljs-built_in">max</span>(ans,dp[<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>)][i]);<br>cout&lt;&lt;ans&lt;&lt;endl;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>所有边的贡献必须在子树内部才可以用这种方法，尤其注意第一种，为什么要那样设计状态</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kruskal重构树</title>
    <link href="/2023/11/27/%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    <url>/2023/11/27/%E7%AE%97%E6%B3%95/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="克鲁斯卡尔重构树"><a href="#克鲁斯卡尔重构树" class="headerlink" title="克鲁斯卡尔重构树"></a>克鲁斯卡尔重构树</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>区间点可相互到达时考虑</li><li>连通块题目考虑</li><li>用到的边是“连通块内的最小生成树”时考虑</li></ol><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>所有原节点都为叶子节点</li><li>有<code>2*n-1</code>个节点，<code>叶</code>子是<code>点</code>权，<code>非</code>叶子是<code>边</code>权</li><li>任何两个叶子节点可以相互到达，<code>一定</code>是通过了他们的LCA所代表的那条<code>边</code>到达的。</li><li>重构树一定是小根堆或者大根堆（针对于点的id，针对于点的“边权”）</li><li>选出一些点可以互相到达，且最大边权不可以超过x，则答案是<code>非叶节点</code>中点权<code>大于等于x</code>的所有子树中的点</li></ol><h2 id="注意（性质）"><a href="#注意（性质）" class="headerlink" title="注意（性质）"></a>注意（性质）</h2><ol><li>重构树中的 <code>非叶子</code> 点权不一定都不相同，但是<code>根</code>的点权一定最大</li><li>重构树一定是<code>堆</code></li><li>在重构树上若到达某个<code>非叶</code>子节点 x，则x子树的所有<code>叶子</code>节点，都可以相互到达。</li><li>重构树中，若一个区间的点可以相互到达，求需要经过的边权的<code>最小值</code>？答案为<code>max&#123;LCA(L,L+1),LCA(L+1,L+2),…,LCA(R-2,R-1)&#125;</code>，此时可以用<code>线段树维护区间最大值</code>解决多组询问</li></ol><p><strong>对于4的证明</strong>：</p><p>设4中求出的答案为t，则L和L+1可以相互到达，L+1和L+2可以相互到达…，所以任意两个点都可以相互到达。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="E-Qpwoeirut-and-Vertices"><a href="#E-Qpwoeirut-and-Vertices" class="headerlink" title="E. Qpwoeirut and Vertices"></a><a href="https://codeforces.com/contest/1706/problem/E">E. Qpwoeirut and Vertices</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给我们一个无向无权图（n个点，m条边，边有编号），若干个询问（q组），每次询问给我们一个区间<code>[ l , r ] </code>，问我们只经过前k条边使得该<strong>区间</strong>内任意两点可以互相到达的k的<strong>最小值</strong>。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>将边的id看成边权，建立重构树</li><li>预处理lca数组</li><li>对于区间[l,r]内，若这个区间的点可以相互到达，只需要求出LCA(l,l+1,…r-1)的点权即可</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><br>ll n,m,qq;<br>ll f[N],a[N];<br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><br><span class="hljs-type">int</span> ans[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>e[++idx]=v;<br>ne[idx]=h[u];<span class="hljs-comment">//clear</span><br>h[u]=idx;<br>&#125;<br><br><span class="hljs-comment">//find</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-comment">//LCA</span><br>ll fa[N][<span class="hljs-number">21</span>],deep[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>idx=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxn=<span class="hljs-number">2</span>*n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)&#123;<br>deep[i]=a[i]=h[i]=<span class="hljs-number">0</span>;<br>f[i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">20</span>;j++)&#123;<br>fa[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><br>deep[j]=deep[u]+<span class="hljs-number">1</span>;<br>fa[j][<span class="hljs-number">0</span>]=u;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;<br><span class="hljs-type">int</span> anc=fa[j][k<span class="hljs-number">-1</span>];<br>fa[j][k]=fa[anc][k<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(j);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//lca返回的是点的id</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;  <br><span class="hljs-keyword">if</span>(deep[u]&lt;deep[v])<span class="hljs-built_in">swap</span>(u,v);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br><span class="hljs-type">int</span> anc=fa[u][k];<br><span class="hljs-keyword">if</span>(deep[anc]&gt;=deep[v])&#123;<br>u=anc;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">return</span> u;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br><span class="hljs-type">int</span> anc1=fa[u][k];<br><span class="hljs-type">int</span> anc2=fa[v][k];<br><span class="hljs-keyword">if</span>(anc1!=anc2)&#123;<br>u=anc1;<br>v=anc2;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>&#125;<br><br><br>ll maxn[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>maxn[u]=<span class="hljs-built_in">max</span>(maxn[u&lt;&lt;<span class="hljs-number">1</span>],maxn[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>maxn[u]=ans[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br><span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)&#123;<br><span class="hljs-keyword">return</span> maxn[u];<br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(L&lt;=mid)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">ask</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid,L,R));<br>&#125;<br><span class="hljs-keyword">if</span>(R&gt;mid)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">ask</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,L,R));<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;qq;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>u=<span class="hljs-built_in">find</span>(u),v=<span class="hljs-built_in">find</span>(v);<br>        <br>        <span class="hljs-comment">//注意这句</span><br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">continue</span>;<br>a[++n]=i;<span class="hljs-comment">//val</span><br>f[u]=n,f[v]=n;<br><span class="hljs-built_in">add</span>(n,u),<span class="hljs-built_in">add</span>(n,v);<br>&#125;<br><br>deep[n]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(n);<br><br>    <br>    <span class="hljs-comment">//注意此时叶子节点的编号为[1,n/2+1]，但是最后一个点不参与答案</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)&#123;<br><span class="hljs-type">int</span> zu=<span class="hljs-built_in">lca</span>(i,i+<span class="hljs-number">1</span>);<br>ans[i]=a[zu];<br>&#125;<br><br>    <span class="hljs-comment">//注意区间右端点</span><br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n/<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qq;i++)&#123;<br><span class="hljs-type">int</span> l,r;<br>cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>        <br>        <span class="hljs-comment">//注意区间右端点</span><br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n/<span class="hljs-number">2</span>,l,r<span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意区间右端点</p></blockquote><h1 id="2021ICPC上海站Life-is-a-Game"><a href="#2021ICPC上海站Life-is-a-Game" class="headerlink" title="2021ICPC上海站Life is a Game"></a><a href="https://ac.nowcoder.com/acm/problem/231127">2021ICPC上海站Life is a Game</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>​给我们一个无向有权图。<br>​点有点权，边有边权。。我们可以在图上来回走，走到一个点后会获得该点的价值，能够重复到达一个点但是不能重复获得该点的价值。但是，从一个点走到另一个点需要满足当前带有的价值要大于边权。<br>​若干次询问，每次询问给一个起点和一个价值，问最多可以获得多少价值。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>考虑到可以在一个连通块内随意走，而且走的边一定是这个连通块的“最小生成树边”，所以正好符合重构树</li><li>建立重构树之后，如果可以到达某个<code>非叶子</code>节点x，那么x的子树的<code>叶子节点的权值</code>都可以被收集到</li><li>考虑假设到达了某<code>非叶子</code>节点x，是否可以向上走，只需要此时的价值&gt;父亲节点的点权即可</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br>ll n,m,q;<br>ll a[N];<br><span class="hljs-comment">//kruskal</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> u,v;<br>ll w;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> A&amp;b)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> w&lt;b.w;<br>&#125;<br>&#125;edge[N];<br>ll f[N];<br><span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==f[x])<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-comment">//graph</span><br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>e[++idx]=b;<br>ne[idx]=h[a];<br>h[a]=idx;<br>&#125;<br><br><br><span class="hljs-comment">//lca</span><br>ll fa[N][<span class="hljs-number">21</span>],deep[N];<br>ll dd[N][<span class="hljs-number">21</span>];<span class="hljs-comment">//在i节点跳到i+2^j，至少还需要多少</span><br>ll sum[N];<span class="hljs-comment">//子树中所有叶子的权值和</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">if</span>(u&lt;=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<br>sum[u]=a[u];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<br><span class="hljs-built_in">dfs1</span>(j);<br>sum[u]+=sum[j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i;i=ne[i])&#123;<br><span class="hljs-type">int</span> j=e[i];<span class="hljs-comment">//son</span><br><br>dd[j][<span class="hljs-number">0</span>]=a[u]-sum[j];<br>deep[j]=deep[u]+<span class="hljs-number">1</span>;<br>fa[j][<span class="hljs-number">0</span>]=u;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;<br>ll anc=fa[j][k<span class="hljs-number">-1</span>];<br>fa[j][k]=fa[anc][k<span class="hljs-number">-1</span>];<br>dd[j][k]=<span class="hljs-built_in">max</span>(dd[j][k<span class="hljs-number">-1</span>],dd[anc][k<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-built_in">dfs2</span>(j);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i++)f[i]=i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u,v,w;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>edge[i]=&#123;u,v,w&#125;;<br>&#125;<br><span class="hljs-built_in">sort</span>(edge+<span class="hljs-number">1</span>,edge+m+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> u=edge[i].u,v=edge[i].v;<br>ll w=edge[i].w;<br>u=<span class="hljs-built_in">find</span>(u),v=<span class="hljs-built_in">find</span>(v);<br><span class="hljs-keyword">if</span>(u==v)<span class="hljs-keyword">continue</span>;<br>a[++n]=w;<br>f[u]=f[v]=n;<br><span class="hljs-built_in">add</span>(n,u),<span class="hljs-built_in">add</span>(n,v);<br>&#125;<br><br><span class="hljs-built_in">dfs1</span>(n);<span class="hljs-comment">//cal sum</span><br><br>deep[n]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs2</span>(n);<span class="hljs-comment">//cal fa&amp;dd&amp;deep</span><br><br><span class="hljs-keyword">while</span>(q--)&#123;<br>ll x,k;<br>cin&gt;&gt;x&gt;&gt;k;<br><span class="hljs-comment">//pos:x,val:k</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> jmp=<span class="hljs-number">20</span>;jmp&gt;=<span class="hljs-number">0</span>;jmp--)&#123;<br>            <span class="hljs-keyword">if</span>(fa[x][jmp]==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//不可以跳出去</span><br><span class="hljs-keyword">if</span>(dd[x][jmp]&lt;=k)&#123;<br>x=fa[x][jmp];<br>&#125;<br>&#125;<br>        cout&lt;&lt;sum[x]+k&lt;&lt;endl;<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：dd数组表示至少需要k才可以跳，那么如果最开始在x位置额外拥有k，无论跳到哪里，都额外拥有k，k不会变化</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>重构树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后缀dp</title>
    <link href="/2023/11/21/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80dp/"/>
    <url>/2023/11/21/%E7%AE%97%E6%B3%95/%E5%90%8E%E7%BC%80dp/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍一种dp的设计状态（后缀）"><a href="#本文介绍一种dp的设计状态（后缀）" class="headerlink" title="本文介绍一种dp的设计状态（后缀）"></a>本文介绍一种dp的设计状态（后缀）</h1><h2 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h2><p>一个序列中 “<code>任意一段区间</code> “满足某个性质，这个时候应该想到 “ 后缀dp”</p><h1 id="Qu’est-ce-Que-C’est"><a href="#Qu’est-ce-Que-C’est" class="headerlink" title="Qu’est-ce Que C’est?"></a><a href="https://ac.nowcoder.com/acm/contest/57358/J">Qu’est-ce Que C’est?</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定长度为 n 的数列 ，要求每个数都在 [ − m , m ]  范围，且任意长度大于等于 2 的区间和都大于等于 0 ，问方案数。</p><p><code>1 ≤ n , m ≤ 5e3 </code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>后缀dp秒杀，设<code>dp[i][j]</code>表示第<code>i</code>个数字选完后，所有后缀中<code>最小值</code>是<code>j</code>的合法方案数目（<strong>j可以是负数</strong>）</li><li>如果以i为结尾时，所有后缀最小值满足&gt;&#x3D;0,那么<code>以i为结尾的方案</code>一定是合法方案</li><li>计算<code>dp[i][j]</code>的时候，利用的i-1层的信息，假设i-1层是正确的，那么第i层肯定是正确的，那么后面都正确。</li><li>遍历完所有的i，说明一个很重要的信息：以i为结尾的<strong>任意</strong>后缀都满足“<code>任意长度&gt;=2的区间满足sum&gt;=0</code>”,那么任意一段长度大于等于2的区间都满足！！</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><span class="hljs-type">const</span> ll mol=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P=<span class="hljs-number">5001</span>;<br>ll a[N],n,m;<br>ll dp[<span class="hljs-number">2</span>][N];<span class="hljs-comment">//表示前i个，最小后缀和为j的方案数目 </span><br>ll dpsum[<span class="hljs-number">2</span>][N];<span class="hljs-comment">//dp的前缀和数组 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>    <br>    <span class="hljs-comment">//初始化dp[1][j],注意偏移量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-m;j&lt;=m;j++)<br>dp[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j+P]=<span class="hljs-number">1</span>,dpsum[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j+P]=(dpsum[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>+P]+dp[<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>][j+P])%mol;<br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-m;j&lt;=m;j++)&#123;<span class="hljs-comment">//枚举这一层的最小后缀</span><br><span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//dp[i&amp;1][j+P]=dp[i-1&amp;1][j-m+P]+...+dp[i-1&amp;1][j+m+P]; </span><br>                <br>                <span class="hljs-comment">//当前为j，上一层可以是[j-m,j+m],注意边界</span><br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=dpsum[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(m,j+m)+P]-dpsum[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j-m<span class="hljs-number">-1</span>+P];<br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=(dp[i&amp;<span class="hljs-number">1</span>][j+P]%mol+mol)%mol;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//dp[i&amp;1][j+P]=dp[i-1&amp;1][-j+P]+...+dp[i-1&amp;1][-j+m+P];</span><br>                <br>                <span class="hljs-comment">//当前为j，上一层可以是[-j,-j+m]，否则此时出现区间&lt;0的情况，注意边界</span><br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=dpsum[i<span class="hljs-number">-1</span>&amp;<span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(-j+m,m)+P]-dpsum[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][-j<span class="hljs-number">-1</span>+P];<br>dp[i&amp;<span class="hljs-number">1</span>][j+P]=(dp[i&amp;<span class="hljs-number">1</span>][j+P]%mol+mol)%mol;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//前缀和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=-m;j&lt;=m;j++)&#123;<br>dpsum[i&amp;<span class="hljs-number">1</span>][j+P]=(dpsum[i&amp;<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>+P]+dp[i&amp;<span class="hljs-number">1</span>][j+P])%mol;<br>&#125;<br>&#125;<br>cout&lt;&lt;dpsum[n&amp;<span class="hljs-number">1</span>][m+P];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>当前层<code>j&gt;=0</code>，上一层可以是负数（这个时候本位置一定选正数，可以满足题意），但是<code>j&lt;0</code>时，上一层必须是正数，而且<code> k&gt;=-j</code>,否则，此时一定存在某个以i为结尾的后缀(len&gt;&#x3D;2)，使得这个后缀的sum&lt;0，不符合题意</li><li><strong>边界问题</strong>：为什么当前层为<code>j(j&gt;=0)</code>的时候,上一层<code>最大</code>从<code>k=m</code>转移<strong>而不是</strong><code>k=m+j</code>呢？<br> 因为以i结尾的任意一个后缀的最小值不可能超过m</li></ol><h1 id="P2592-ZJOI2008-生日聚会"><a href="#P2592-ZJOI2008-生日聚会" class="headerlink" title="P2592 [ZJOI2008] 生日聚会"></a><a href="https://www.luogu.com.cn/problem/P2592">P2592 [ZJOI2008] 生日聚会</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定n，m，k。<br>n，m表示有n个男孩和m个女孩，对于任意连续的一段，男孩与女孩的数目之差不超过k，求方案数。<br><code>n , m ≤ 150，k ≤ 20</code></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li>设<code>dp[i][j][w][t]</code>表示选i个男孩，j个女孩，且<code>此时</code>任意后缀中男孩比女孩<code>最多</code>多w个，女孩比男孩<code>最多</code>多t个的方案数目</li><li>显然，增加一个男孩或者增加一个女孩，如果上一个状态合法，那此轮状态也一定合法。</li><li>具体转移见代码</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">152</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">22</span>;<br><span class="hljs-type">const</span> ll mol=<span class="hljs-number">12345678</span>;<br>ll dp[N][N][M][M];<br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;w++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;=k;t++)&#123;<br><span class="hljs-keyword">if</span>(dp[i][j][w][t])&#123;<br>ll tem=dp[i][j][w][t];<br>(dp[i+<span class="hljs-number">1</span>][j][w+<span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,t<span class="hljs-number">-1</span>)]+=tem)%=mol;<br>(dp[i][j+<span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,w<span class="hljs-number">-1</span>)][t+<span class="hljs-number">1</span>]+=tem)%=mol;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w=<span class="hljs-number">0</span>;w&lt;=k;w++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;=k;t++)&#123;<br>ans+=dp[n][m][w][t];<br>ans%=mol;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><blockquote><p><strong>是由当前层转移到下一层，并不是由前一层转移到当前层</strong>，原因如下：</p><p>1.若由前一层转移到当前层,那么其中肯定有这样的转移方程：<code>dp[i][j][w][t]+=dp[i-1][j][max(0,w-1)][t+1]</code>，这是错的，如何确定选（i-1，j)这个状态下，女生一定比男生多t+1个呢？？如果j为0呢？那是不是可以不需要多t+1个，多t个好像也可以，此时t为0。</p><p>2.理论上从前一层转移到当前层也是可以的，只不过需要特判？？这个作者没有严格证明，可以自己尝试</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面两个题，发现，任意一段需要满足某一性质，则需要后缀dp。</p><p>dp定义：在<code>某个状态</code>下，<code>任意后缀</code>的<code>最</code>大属性（或者最小属性）为k   的方案数</p><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><blockquote><p>一定是在某个状态下</p><p>任意后缀</p><p>最大（最小）属性为k</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++单例模式和CRTP</title>
    <link href="/2023/11/21/cpp/c++%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/21/cpp/c++%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍c-的单例模式以及注意事项"><a href="#本文介绍c-的单例模式以及注意事项" class="headerlink" title="本文介绍c++的单例模式以及注意事项"></a>本文介绍c++的单例模式以及注意事项</h1><h1 id="简单的单例模式"><a href="#简单的单例模式" class="headerlink" title="简单的单例模式"></a>简单的单例模式</h1><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><strong>私有化构造函数</strong>：确保不能从类外部直接构造对象。</li><li><strong>静态成员函数</strong>：提供一个全局访问点，用于获取这个唯一的实例。</li><li><strong>静态成员变量</strong>：存储类的唯一实例。</li><li><strong>删除复制构造函数和赋值操作符</strong>：防止复制和赋值实例。</li><li><strong>可选的私有析构函数</strong>：如果类管理资源，明确声明析构函数有助于资源的正确释放。</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供全局访问点</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> A* <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; name &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 禁止外部删除单例对象</span><br>    ~<span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> A* m_instance;<br>    string name;<br><br>    <span class="hljs-comment">// 私有化构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;a&quot;</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 私有化拷贝和赋值</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)&#123;&#125;<br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp;)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员变量</span><br>A* A::m_instance=<span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A::<span class="hljs-built_in">instance</span>()-&gt;<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模板单例"><a href="#模板单例" class="headerlink" title="模板单例"></a>模板单例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T* <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            m_instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m_instance;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">//注意这句是protected</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <br>    <span class="hljs-comment">//注意参数</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">//注意返回值和参数</span><br>    Singleton&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br>    <span class="hljs-type">static</span> T* m_instance;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T* Singleton&lt;T&gt;::m_instance = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Singleton&lt;A&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">// 让Singleton类模板访问A的私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;A&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A&#x27;s instance method called.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他 A 类的成员函数和变量</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有化构造函数，确保外部不能直接创建A的实例</span><br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* a = A::<span class="hljs-built_in">instance</span>();<br>a-&gt;<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p><ul><li>构造函数必须是类名，不允许加模板</li><li>其他函数需要加模板</li><li>基类类型是Singleton&lt;T&gt;,子类类型是T   ！！！！！！！！！！！！！！</li></ul></blockquote><h1 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>CRTP的全称是<strong>C</strong>uriously <strong>R</strong>ecurring <strong>T</strong>emplate <strong>P</strong>attern，即奇异递归模板模式。</p><p><strong>特点：</strong></p><ol><li>基类是一个模板类</li><li>派生类继承该基类时，<strong>将派生类自身作为模板参数传递给基类</strong></li></ol><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类是模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(<span class="hljs-keyword">this</span>))<br>        &#123;<br>            t-&gt;<span class="hljs-built_in">op</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-comment">// 派生类Derived继承自Base，并以自身作为模板参数传递给基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::op()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>通过使用static_cast，将this指针转换为模板参数类型T的指针，然后调用类型T的方法,这种方法是安全的</p></blockquote><h2 id="CRTP的特点"><a href="#CRTP的特点" class="headerlink" title="CRTP的特点"></a>CRTP的特点</h2><ul><li><strong>优点</strong>：省去动态绑定、查询虚函数表带来的开销。通过CRTP，<code>基类</code>可以<code>获得</code>到<code>派生类</code>的类型，提供各种操作，比普通的继承更加灵活。但<code>CRTP</code>基类并不会单独使用，只是作为一个模板的功能。</li><li><strong>缺点</strong>：模板的通病，即影响代码的可读性。</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="1-静态分发（“静态多态”）"><a href="#1-静态分发（“静态多态”）" class="headerlink" title="1. 静态分发（“静态多态”）"></a>1. 静态分发（“静态多态”）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">static_cast</span>&lt;T *&gt;(<span class="hljs-keyword">this</span>))<br>        &#123;<br>            t-&gt;<span class="hljs-built_in">op</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">public</span> Base&lt;Derived1&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived1</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived1::op()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">public</span> Base&lt;Derived2&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived2</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived2::op()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-comment">// 辅助函数：完成静态分发</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DerivedClass&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helperFunc</span><span class="hljs-params">(Base&lt;DerivedClass&gt;&amp; d)</span><span class="hljs-comment">//注意参数d的类型</span></span><br><span class="hljs-function"></span>&#123;<br>    d.<span class="hljs-built_in">func</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Derived1 d1;<br>    Derived2 d2;<br>    <span class="hljs-built_in">helperFunc</span>(d1);<br>    <span class="hljs-built_in">helperFunc</span>(d2);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Base<Derived1>和Base<Derived2>不算同一个类型</p></blockquote><p><strong>注意：</strong></p><ul><li>模板类或模板函数在<code>调用</code>时才会实例化。因此当<code>Base&lt;Derived1&gt;::func()</code>被调用时，<code>Base&lt;Derived1&gt;</code>已经知道<code>Derived1::op()</code>的存在</li></ul><h3 id="2-计数器"><a href="#2-计数器" class="headerlink" title="2. 计数器"></a>2. 计数器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">Counter</span>()<br>    &#123;<br>        <span class="hljs-comment">//注意类型</span><br>        ++Counter&lt;T&gt;::count;<br>    &#125;<br>    ~<span class="hljs-built_in">Counter</span>() <br>    &#123;<br>        <span class="hljs-comment">//注意类型</span><br>        --Counter&lt;T&gt;::count;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> Counter&lt;T&gt;::count = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DogCounter</span> : <span class="hljs-keyword">public</span> Counter&lt;DogCounter&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;count;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatCounter</span> : <span class="hljs-keyword">public</span> Counter&lt;CatCounter&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;count;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    DogCounter d1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;DogCount : &quot;</span> &lt;&lt; d1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br>    &#123;<br>        DogCounter d2;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;DogCount : &quot;</span> &lt;&lt; d1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//2</span><br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;DogCount : &quot;</span> &lt;&lt; d1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br> <br>    CatCounter c1, c2, c3, c4, c5[<span class="hljs-number">3</span>];<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;CatCount : &quot;</span> &lt;&lt; c1.<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;<span class="hljs-comment">//7</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">DogCount : <span class="hljs-number">1</span><br>DogCount : <span class="hljs-number">2</span><br>DogCount : <span class="hljs-number">1</span><br>CatCount : <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h3><p>见模板单例</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>单例模式下，<code>构造函数</code><strong>不</strong>允许加模板，<code>其他函数</code>需要<strong>加</strong>模板</li><li>单例模式下访问权限：子类需要基类的<code>友元</code>（用于基类访问子类构造函数），基类需要使用<code>protected</code>（用于子类访问基类的构造函数）</li><li>子类需要<code>私有化构造函数</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑层设计</title>
    <link href="/2023/11/20/cpp/%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/11/20/cpp/%E9%80%BB%E8%BE%91%E5%B1%82%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文概述基于<code>boost::asio</code>实现的服务器逻辑层结构，并且完善之前设计的消息结构。因为为了简化粘包处理，我们简化了发送数据的结构,这次我们给出完整的消息设计，以及服务器架构设计。</p><h1 id="服务层设计"><a href="#服务层设计" class="headerlink" title="服务层设计"></a>服务层设计</h1><p>之前我们设计了Session(会话层)，并且给大家讲述了Asio底层的通信过程，如下图</p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20231120183243232.png" alt="image-20231120183243232"></p><p>我们接下来要设计的服务器结构是这样的</p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/image-20231120183405074.png" alt="image-20231120183405074"></p><h1 id="消息头完善"><a href="#消息头完善" class="headerlink" title="消息头完善"></a>消息头完善</h1><p>我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。</p><p>为了减少耦合和歧义，我们重新设计消息节点</p><ol><li><code>MsgNode</code>表示消息节点的基类，头部的消息用这个结构存储。</li><li><code>RecvNode</code>表示接收消息的节点。</li><li><code>SendNode</code>表示发送消息的节点。</li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>_data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>~<span class="hljs-built_in">MsgNode</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;destruct MsgNode&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">delete</span>[] _data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>&#123;<br>::std::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, _total_len);<br>&#125;<br><span class="hljs-type">short</span> _cur_len;<br><span class="hljs-type">short</span> _total_len;<br><span class="hljs-type">char</span>* _data;<br>&#125;;<br><br><span class="hljs-comment">//接受消息 id+内容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecvNode</span> :<span class="hljs-keyword">public</span> MsgNode &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">RecvNode</span>(<span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id);<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">short</span> _msg_id;<br>&#125;;<br><br><span class="hljs-comment">//发送消息，id+len+内容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendNode</span> :<span class="hljs-keyword">public</span> MsgNode &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SendNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id);<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">short</span> _msg_id;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RecvNode::<span class="hljs-built_in">RecvNode</span>(<span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id) :<span class="hljs-built_in">MsgNode</span>(max_len),<br>_msg_id(msg_id) &#123;<br>&#125;<br><br><span class="hljs-comment">//注意，头部有（id+data_len）两个字段</span><br>SendNode::<span class="hljs-built_in">SendNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len, <span class="hljs-type">short</span> msg_id) :<span class="hljs-built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN)<br>, _msg_id(msg_id) &#123;<br>    <span class="hljs-comment">//先发送id, 转为网络字节序</span><br>    <span class="hljs-type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(msg_id);<br><br>    <span class="hljs-comment">//这里是HEAD_ID_LEN，不是HEAD_TOTAL_LEN</span><br>    <span class="hljs-built_in">memcpy</span>(_data, &amp;msg_id_host, HEAD_ID_LEN);<br>    <span class="hljs-comment">//转为网络字节序</span><br>    <span class="hljs-type">short</span> max_len_host = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(max_len);<br><br>    <span class="hljs-comment">//这里是HEAD_DATA_LEN，不是HEAD_TOTAL_LEN</span><br>    <span class="hljs-built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;max_len_host, HEAD_DATA_LEN);<br><br>    <span class="hljs-comment">//消息内容</span><br>    <span class="hljs-built_in">memcpy</span>(_data + HEAD_ID_LEN + HEAD_DATA_LEN, msg, max_len);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">SendNode`发送节点构造时，先将id转为网络字节序，然后写入`_data`数据域。<br>然后将要发送数据的长度转为大端字节序，写入`_data`数据域，注意要偏移`HEAD_ID_LEN`长度。<br>最后将要发送的数据`msg`写入`_data`数据域，注意要偏移`HEAD_ID_LEN`+`HEAD_DAT<span class="hljs-built_in">A_LEN</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="Session类改写"><a href="#Session类改写" class="headerlink" title="Session类改写"></a>Session类改写</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>~<span class="hljs-built_in">CSession</span>();<br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_length, <span class="hljs-type">short</span> msgid)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(std::string msg, <span class="hljs-type">short</span> msgid)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;CSession&gt; <span class="hljs-title">SharedSelf</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>tcp::socket _socket;<br>std::string _uuid;<br><span class="hljs-type">char</span> _data[MAX_LENGTH];<br>CServer* _server;<br><span class="hljs-type">bool</span> _b_close;<br>std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>std::mutex _send_lock;<br><br><br><span class="hljs-comment">//收到的消息结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br><span class="hljs-type">bool</span> _b_head_parse;<br><span class="hljs-comment">//收到的头部结构</span><br>std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/json.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/value.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/reader.h&gt;</span></span><br><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server), _b_close(<span class="hljs-literal">false</span>), _b_head_parse(<span class="hljs-literal">false</span>) &#123;<br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br>_recv_head_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);<br>&#125;<br>CSession::~<span class="hljs-built_in">CSession</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(std::string msg, <span class="hljs-type">short</span> msgid)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;SendNode&gt;(msg.<span class="hljs-built_in">c_str</span>(), msg.<span class="hljs-built_in">length</span>(), msgid));<br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_length, <span class="hljs-type">short</span> msgid)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msgid));<br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Close</span><span class="hljs-params">()</span> </span>&#123;<br>_socket.<span class="hljs-built_in">close</span>();<br>_b_close = <span class="hljs-literal">true</span>;<br>&#125;<br><br>std::shared_ptr&lt;CSession&gt;CSession::<span class="hljs-built_in">SharedSelf</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-comment">//增加异常处理</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-comment">//cout &lt;&lt; &quot;send data &quot; &lt;&lt; _send_que.front()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span><br>_send_que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, shared_self));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception code : &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-comment">//已经移动的字符数</span><br><span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (bytes_transferred &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br><span class="hljs-comment">//收到的数据不足头部大小</span><br><span class="hljs-keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LEN) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_head_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空缓冲区</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//收到的数据比头部多</span><br><span class="hljs-comment">//头部剩余未复制的长度</span><br><span class="hljs-type">int</span> head_remain = HEAD_TOTAL_LEN - _recv_head_node-&gt;_cur_len;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);<br><span class="hljs-comment">//更新已处理的data长度和剩余未处理的长度</span><br>copy_len += head_remain;<br>bytes_transferred -= head_remain;<br><span class="hljs-comment">//获取头部MSGID数据</span><br><span class="hljs-type">short</span> msg_id = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>msg_id = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(msg_id);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;<br><span class="hljs-comment">//id非法</span><br><span class="hljs-keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">short</span> msg_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>msg_len = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(msg_len);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;msg_len is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;<br><br><span class="hljs-comment">//len非法</span><br><span class="hljs-keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid data length is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//构造接收节点</span><br>_recv_msg_node = <span class="hljs-built_in">make_shared</span>&lt;RecvNode&gt;(msg_len, msg_id);<br><br><span class="hljs-comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; msg_len) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-comment">//头部处理完成</span><br>_b_head_parse = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//处理这一轮的消息体</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len);<br>_recv_msg_node-&gt;_cur_len += msg_len;<br>copy_len += msg_len;<br>bytes_transferred -= msg_len;<br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span><br><br><span class="hljs-comment">//构造数据和发送数据</span><br>Json::Reader reader;<br>Json::Value root;<br>reader.<span class="hljs-built_in">parse</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span><br>&lt;&lt; root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>() &lt;&lt; endl;<br>root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>();<br>std::string return_str = root.<span class="hljs-built_in">toStyledString</span>();<br><span class="hljs-built_in">Send</span>(return_str, root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>());<br><br><span class="hljs-comment">//处理下一轮的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">//已经处理完头部，处理上次未接受完的消息数据</span><br><span class="hljs-comment">//接收的数据仍不足剩余未处理的</span><br><span class="hljs-type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br><span class="hljs-keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);<br>_recv_msg_node-&gt;_cur_len += remain_msg;<br>bytes_transferred -= remain_msg;<br>copy_len += remain_msg;<br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br><span class="hljs-comment">//构造数据和发送数据</span><br>Json::Reader reader;<br>Json::Value root;<br>reader.<span class="hljs-built_in">parse</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span><br>&lt;&lt; root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>() &lt;&lt; endl;<br>root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="hljs-string">&quot;data&quot;</span>].<span class="hljs-built_in">asString</span>();<br>std::string return_str = root.<span class="hljs-built_in">toStyledString</span>();<br><span class="hljs-built_in">Send</span>(return_str, root[<span class="hljs-string">&quot;id&quot;</span>].<span class="hljs-built_in">asInt</span>());<br><br><br><span class="hljs-comment">//处理下一轮的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="单例模板类"><a href="#单例模板类" class="headerlink" title="单例模板类"></a>单例模板类</h1><p>因为服务器的逻辑处理需要单例模式，后期可能还会有一些模块的设计也需要单例模式，所以先实现一个单例模板类，然后其他想实现单例类只需要继承这个模板类即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt;&amp; st) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; _instance;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//获取指针</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;T&gt; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> std::once_flag s_flag;<br>        std::<span class="hljs-built_in">call_once</span>(s_flag, [&amp;]() &#123;<br>            _instance = <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T);<br>            &#125;);<br>        <span class="hljs-keyword">return</span> _instance;<br>    &#125;<br><br>    <span class="hljs-comment">//输出地址</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; _instance.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">//析构</span><br>    ~<span class="hljs-built_in">Singleton</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is singleton destruct&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::shared_ptr&lt;T&gt; Singleton&lt;T&gt;::_instance = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><h1 id="LogicNode类"><a href="#LogicNode类" class="headerlink" title="LogicNode类"></a>LogicNode类</h1><p><code>LogicNode</code>定义在CSession.h中</p><p>其包含算了会话类的智能指针，主要是为了实现伪闭包，防止session被释放。<br>其次包含了接收消息的节点类的智能指针。<br>实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//session和recvnode</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicNode</span> &#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicSystem</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">LogicNode</span>(shared_ptr&lt;CSession&gt;Sesson, shared_ptr&lt;RecvNode&gt;Recvnode) :_session(Sesson), _recvnode(Recvnode) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;CSession&gt; _session;<br>shared_ptr&lt;RecvNode&gt; _recvnode;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="LogicSystem单例类"><a href="#LogicSystem单例类" class="headerlink" title="LogicSystem单例类"></a>LogicSystem单例类</h1><p>我们实现逻辑系统的单例类，继承自<code>Singleton&lt;LogicSystem&gt;</code>，这样LogicSystem的构造函数和拷贝构造函数就都变为私有的了，因为基类的构造函数和拷贝构造函数都是私有的。另外<code>LogicSystem</code>也用了基类的成员<code>_instance</code>和<code>GetInstance</code>函数。从而达到单例效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这是回调函数的类型定义。它接受一个会话对象的智能指针、一个消息ID和消息内容作为参数。</span><br><span class="hljs-keyword">typedef</span>  function&lt;<span class="hljs-type">void</span>(shared_ptr&lt;CSession&gt;, <span class="hljs-type">short</span> msg_id, string msg_data)&gt; FunCallBack;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicSystem</span> :<span class="hljs-keyword">public</span> Singleton&lt;LogicSystem&gt;<br>&#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;LogicSystem&gt;;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">LogicSystem</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostMsgToQue</span><span class="hljs-params">(shared_ptr &lt; LogicNode&gt; msg)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">LogicSystem</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DealMsg</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterCallBacks</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloWordCallBack</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">short</span> msg_id, string msg_data)</span></span>;<br>    std::thread _worker_thread;<br>    std::queue&lt;shared_ptr&lt;LogicNode&gt;&gt; _msg_que;         <span class="hljs-comment">//消息队列</span><br>    std::mutex _mutex;<br>    std::condition_variable _consume;<br>    <span class="hljs-type">bool</span> _b_stop;<br>    std::map&lt;<span class="hljs-type">short</span>, FunCallBack&gt; _fun_callbacks;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>FunCallBack</code>为要注册的回调函数类型，其参数为绘画类智能指针，消息id，以及消息内容。</li><li><code>_msg_que</code>为逻辑队列</li><li><code>_mutex</code> 为保证逻辑队列安全的互斥量</li><li><code>_consume</code>表示消费者条件变量，用来控制当逻辑队列为空时<code>保证线程暂时挂起等待</code>，不要干扰其他线程。</li><li><code>_fun_callbacks</code>表示回调函数的map，根据id查找对应的逻辑处理函数。</li><li><code>_worker_thread</code>表示工作线程，用来从逻辑队列中取数据并执行回调函数。</li><li><code>_b_stop</code>表示收到外部的停止信号，逻辑类要中止工作线程并优雅退出。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中位数第k大二分法</title>
    <link href="/2023/11/19/%E7%AE%97%E6%B3%95/%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AC%ACk%E5%A4%A7%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2023/11/19/%E7%AE%97%E6%B3%95/%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AC%ACk%E5%A4%A7%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="本文介绍利用二分法求中位数的一般思路"><a href="#本文介绍利用二分法求中位数的一般思路" class="headerlink" title="本文介绍利用二分法求中位数的一般思路"></a>本文介绍利用二分法求中位数的一般思路</h1><p>如果一个题目要求中位数，二分答案，判定是否符合条件即可</p><h1 id="D-Max-Median"><a href="#D-Max-Median" class="headerlink" title="D. Max Median"></a><a href="https://codeforces.com/contest/1486/problem/D">D. Max Median</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n和一个k，n表示有一个数组有n个元素，求所有“区间长度大于等于k”的区间中，中位数最大的多少</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>二分答案，检查是否存在一个大于等于k的区间满足即可，显然此时原数组元素<code>具体值</code>是多少已经不重要，重要的是元素的<code>相对大小</code>，设新数组b，若<code>a[i]&gt;=x</code>,则<code>b[i]=1</code>，否则<code>b[i]=0</code>，设s为b的前缀和。</p><p>然后考虑对于每一个<code>i</code>，是否存在<code>j (0&lt;=j&lt;=i-k)</code>,满足<code>s[i]-s[j]&gt;0</code>,这是一个很常见的处理方式（称之为划分集合法），具体见代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> ll mol=<span class="hljs-number">12345678</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> b[N];<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-comment">//处理b数组</span><br><span class="hljs-keyword">if</span>(a[i]&gt;=x)&#123;<br>b[i]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> b[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//前缀和数组</span><br>s[i]=s[i<span class="hljs-number">-1</span>]+b[i];<br>&#125;<br><span class="hljs-comment">//s[i]-s[j]&gt;0即可，i-j&gt;=k </span><br><span class="hljs-type">int</span> minn=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;=n;i++)&#123;<br>minn=<span class="hljs-built_in">min</span>(minn,s[i-k]);<br>        <br>        <span class="hljs-comment">//注意是&gt;0，想想为什么</span><br><span class="hljs-keyword">if</span>(s[i]-minn&gt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125; <br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=n;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>ans=mid;<br>l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Chat-Program"><a href="#D-Chat-Program" class="headerlink" title="D. Chat Program"></a><a href="https://codeforces.com/gym/104128/problem/D">D. Chat Program</a></h1><blockquote><p>icpc银牌题</p></blockquote><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的数组，问最多给<code>一段</code>区间添加等差数列后,序列第 k 大最大是多少。</p><p>等差数列首项为c， 公差为d，长度为m。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题虽然不是中位数，其实也差不多。都是二分答案检查是否符合即可</p><ol><li>设二分答案x，若序列中某个数<code>a[i]&lt;x</code>，若使这个数<code>&gt;=x</code>，则必须选一个位置作为开头，加等差数列。</li><li>对于所有数操作完后，我们<code>只可以</code>选一个位置作为开头，那么要满足更多的<code>a[i]&gt;=x</code>。很容易想到，<strong>对于每一个小于x的位置，这个开头是一段区间</strong>，我们差分维护即可，这样对所有数字操作完后，对差分数组求前缀和</li><li>最后，选出一个满足尽可能多的<code>a[i]</code>的位置，如果此时可以满足的<code>a[i]&gt;=x</code>还是大于等于k个，那么符合要求，否则不符合要求</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br> <br>ll a[N];<br>ll n,m;<br>ll k,c,d;<span class="hljs-comment">//c+d[i]</span><br>ll cha[N];<span class="hljs-comment">//差分数组</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-comment">//第k大至少是x,大于等于x的数目需要大于等于k</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>; <span class="hljs-comment">//符合的数目</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">if</span>(a[i]&lt;x) &#123;<br><span class="hljs-comment">//c+ (i-pos)*d +a[i] &gt;= x//最右边的pos</span><br><span class="hljs-comment">//pos=(c+a[i]-x+i*d)/d</span><br> <br><span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span>(a[i]+c&gt;=x) &#123;<br>cha[<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,i-m+<span class="hljs-number">1</span>)]++;<br>cha[i+<span class="hljs-number">1</span>]--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ll ans=(c+a[i]-x+i*d)/d;<span class="hljs-comment">//寻找起始位置</span><br>ans=<span class="hljs-built_in">min</span>(ans,(ll)i);<br><span class="hljs-keyword">if</span>(ans&gt;=<span class="hljs-number">1</span>&amp;&amp;ans&gt;=i-m+<span class="hljs-number">1</span>) &#123;<br>cha[<span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>,i-m+<span class="hljs-number">1</span>)]++;<br>cha[ans+<span class="hljs-number">1</span>]--;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> num++;<br>&#125;<br>ll maxn=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cha[i]+=cha[i<span class="hljs-number">-1</span>];<br>maxn=<span class="hljs-built_in">max</span>(maxn,cha[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n+<span class="hljs-number">1</span>; i++)cha[i]=<span class="hljs-number">0</span>;<br>num+=maxn;<br><span class="hljs-keyword">return</span> num&gt;=k;<br> <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;m&gt;&gt;c&gt;&gt;d;<br> <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>&#125;<br> <br>ll ans=<span class="hljs-number">0</span>;<br>ll begin=<span class="hljs-number">1</span>,end=<span class="hljs-number">2e15</span>;<br><span class="hljs-keyword">while</span>(begin&lt;=end) &#123;<br>ll mid=begin+end&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) &#123;<br>ans=mid;<br>begin=mid+<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> end=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br> <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//关闭C++和C的输入输出流的同步，提高C++的输入输出效率</span><br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//解除cin和cout的绑定，让它们可以独立缓冲</span><br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//这一句可以不要，效果一样</span><br><span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//cin&gt;&gt;t;</span><br><span class="hljs-keyword">while</span>(t--) &#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>碰到这种题先考虑二分吧，中位数，第k大</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节序大小端问题</title>
    <link href="/2023/11/16/cpp/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/16/cpp/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="字节序的问题"><a href="#字节序的问题" class="headerlink" title="字节序的问题"></a>字节序的问题</h1><p>字节序问题，通常被称为大小端问题（Endianess），涉及到数据在计算机内存中的存储方式，尤其是多字节值（如整数、浮点数）的存储顺序。这个问题在不同架构的计算机系统中尤为重要，因为它会影响数据的解释和处理。主要有两种类型的字节序：</p><ol><li><strong>大端序（Big Endian）</strong>：在这种方式下，多字节值的最高有效字节（MSB）存储在最低的内存地址，随后是次高有效字节，以此类推。例如，数值 <code>0x12345678</code> 在内存中会被存储为 <code>12 34 56 78</code>（地址由低到高排列）。</li><li><strong>小端序（Little Endian）</strong>：与大端序相反，小端序将多字节值的最低有效字节（LSB）存储在最低的内存地址。同样的数值 <code>0x12345678</code> 在小端序系统中将被存储为 <code>78 56 34 12</code>。</li></ol><p>字节序问题在跨平台数据交换时尤为重要。如果两个交流数据的系统采用不同的字节序，没有适当的转换，数据可能会被错误地解释，导致问题。例如，在网络编程中，通常采用大端序（网络字节序），因此在数据发送和接收时，可能需要在小端序和大端序之间进行转换。</p><p><strong>产生问题的原因</strong>：</p><p>在网络通信中，如果数字（如整数或浮点数）的字节序没有从<code>发送方</code>的主机序转换为统一的网络字节序（大端序），那么<code>接收方</code>可能无法正确解释接收到的数据。这是因为<strong>不同的计算机架构可能采用不同的字节序</strong>，导致相同的数字在不同系统上的内存表示不同</p><h1 id="如何区分本机字节序"><a href="#如何区分本机字节序" class="headerlink" title="如何区分本机字节序"></a>如何区分本机字节序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 判断当前系统的字节序是大端序还是小端序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 当前系统为小端序</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 当前系统为大端序</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0x12345678</span>;<br><span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;num;<br>cout &lt;&lt; <span class="hljs-string">&quot;原始数据：&quot;</span> &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_big_endian</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统为大端序&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(num); i++) &#123;<br>cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统为小端序&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">sizeof</span>(num) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务器使用网络字节序"><a href="#服务器使用网络字节序" class="headerlink" title="服务器使用网络字节序"></a>服务器使用网络字节序</h1><p>为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。</p><p>可以使用<br><code> boost::asio::detail::socket_ops::host_to_network_long()</code> 和 <code>boost::asio::detail::socket_ops::host_to_network_short()</code> 函数</p><p><strong>将主机字节序转换为网络字节序</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> host_long_value = <span class="hljs-number">0x12345678</span>;<br>    <span class="hljs-type">uint16_t</span> host_short_value = <span class="hljs-number">0x5678</span>;<br>    <span class="hljs-type">uint32_t</span> network_long_value = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_long</span>(host_long_value);<br>    <span class="hljs-type">uint16_t</span> network_short_value = boost::asio::detail::socket_ops::<span class="hljs-built_in">host_to_network_short</span>(host_short_value);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Host long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_long_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Network long value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_long_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Host short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; host_short_value &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Network short value: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; network_short_value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host long value: 0x12345678<br>Network long value: 0x78563412<br>Host short value: 0x5678<br>Network short value: 0x7856<br></code></pre></td></tr></table></figure><hr><blockquote><p>注意：在使用这些函数时，应该确保输入参数和返回结果都是无符号整数类型，否则可能会出现错误。</p></blockquote><p>服务器<code>发送数据</code>时，将数据长度转化为<code>网络字节序</code>，<br>在<code>接收数据</code>时，将长度转为<code>本机字节序</code>。</p><p><strong>将网络字节序转换为主机字节序</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len=boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br></code></pre></td></tr></table></figure><hr><h1 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h1><p>发送时我们会将发送的消息放入队列里以保证发送的时序性，每个session都有一个发送队列，因为有的时候发送的频率过高会导致队列增大，所以要对队列的大小做限制，当队列大于指定数量的长度时，就丢弃要发送的数据包，以保证消息的快速收发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br>    <span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-comment">//如果大于&quot;队列size允许的容量&quot;,则不允许发送</span><br>    <span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br>    <span class="hljs-keyword">if</span> (send_que_size&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>    boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), <br>        std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字节序问题的解决需要程序员显示的调用函数，asio不会自动帮我们实现</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>处理网络粘包问题</title>
    <link href="/2023/11/15/cpp/%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/15/cpp/%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h1><p>原因：</p><p>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！</p><p>其他的原因:<br>1   客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！。<br>2   tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法。<br>3   再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连。</p><h1 id="处理粘包"><a href="#处理粘包" class="headerlink" title="处理粘包"></a>处理粘包</h1><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议：</p><p><code>消息id</code>+<code>消息长度</code>+<code>消息内容</code></p><h1 id="MsgNode类"><a href="#MsgNode类" class="headerlink" title="MsgNode类"></a>MsgNode类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br>    <span class="hljs-comment">//Csession可以访问私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span>;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//(发送msg)，数组长度为（max_len+头长度+1)，结尾&quot;\0&quot;,当前长度为0</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span>* msg, <span class="hljs-type">short</span> max_len) :_total_len(max_len + HEAD_LENGTH), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>        <span class="hljs-built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);<br>        <span class="hljs-built_in">memcpy</span>(_data + HEAD_LENGTH, msg, max_len);<br>        _data[_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//(读取msg)，数组为（max_len+1），，结尾&quot;\0&quot;,当前长度为0</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[_total_len + <span class="hljs-number">1</span>]();<br>    &#125;<br><br>    ~<span class="hljs-built_in">MsgNode</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] _data;<br>    &#125;<br><br>    <span class="hljs-comment">//清空消息内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clear</span><span class="hljs-params">()</span> </span>&#123;<br>        ::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, _total_len);<br>        _cur_len = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">short</span> _cur_len;  <span class="hljs-comment">//当前消息长度</span><br>    <span class="hljs-type">short</span> _total_len;<span class="hljs-comment">//消息总长度</span><br>    <span class="hljs-type">char</span>* _data;     <span class="hljs-comment">//消息内容</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>_cur_len;  &#x2F;&#x2F;当前消息长度</li><li>_total_len;&#x2F;&#x2F;消息总长度</li><li>_data;     &#x2F;&#x2F;消息内容</li><li>MsgNode(short max_len)           接受消息（read)的话需要这个构造</li><li>MsgNode(char* msg, short max_len)  发送消息（wrire）的话需要找个构造</li></ul><h1 id="CSession"><a href="#CSession" class="headerlink" title="CSession"></a>CSession</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为能够对收到的数据切包处理，需要定义一个消息接收节点，一个bool类型的变量表示头部是否解析完成，以及将处理好的头部先缓存起来的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    ~<span class="hljs-built_in">CSession</span>();<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开始接收消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<span class="hljs-comment">//发送消息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//关闭会话</span><br>    <span class="hljs-function">std::shared_ptr&lt;CSession&gt; <span class="hljs-title">SharedSelf</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//获取this指针</span><br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读回调</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>    <span class="hljs-comment">//写回调</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;<br>    tcp::socket _socket;<br>    std::string _uuid;<br><br>    <span class="hljs-comment">//接收数据的缓冲区</span><br>    <span class="hljs-type">char</span> _data[MAX_LENGTH];<br><br>    <span class="hljs-comment">//对应的服务器</span><br>    CServer* _server;<br><br><br>    <span class="hljs-type">bool</span> _b_close;<span class="hljs-comment">//是否关闭</span><br><br>    <span class="hljs-comment">//发送队列</span><br>    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br>    std::mutex _send_lock;<span class="hljs-comment">//发送锁，防止多线程同时发送</span><br><br><br>    <span class="hljs-comment">//收到的消息结构</span><br>    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;<br>    <span class="hljs-type">bool</span> _b_head_parse;<span class="hljs-comment">//是否解析到头部</span><br>    <span class="hljs-comment">//收到的头部结构</span><br>    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//构造会话，_socket，服务器指针，关闭标志位，头部解析标志位，接收头部节点</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server), _b_close(<span class="hljs-literal">false</span>), _b_head_parse(<span class="hljs-literal">false</span>) &#123;<br><br><span class="hljs-comment">//生成uuid</span><br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br><br><span class="hljs-comment">//初始化接收头部节点</span><br>_recv_head_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);<br>&#125;<br>CSession::~<span class="hljs-built_in">CSession</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Close</span><span class="hljs-params">()</span> </span>&#123;<br>_socket.<span class="hljs-built_in">close</span>();<span class="hljs-comment">//关闭socket</span><br>_b_close = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置关闭标志位</span><br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><span class="hljs-comment">//获取this指针</span><br>std::shared_ptr&lt;CSession&gt;CSession::<span class="hljs-built_in">SharedSelf</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//开始接收数据</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//异步读取数据</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-comment">//发送消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<span class="hljs-comment">//加锁</span><br><br><span class="hljs-type">int</span> send_que_size = _send_que.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获取当前发送队列大小</span><br><span class="hljs-keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="hljs-string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//将消息放入发送队列</span><br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><br><span class="hljs-comment">//如果当前发送队列不为空，则说明有消息正在发送，不需要再次发送</span><br><span class="hljs-keyword">if</span> (send_que_size &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//发送消息</span><br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">SharedSelf</span>()));<br>&#125;<br><br><span class="hljs-comment">//写回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<span class="hljs-comment">//加锁</span><br>cout &lt;&lt; <span class="hljs-string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="hljs-built_in">front</span>()-&gt;_data + HEAD_LENGTH &lt;&lt; endl;<br><br>_send_que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//write成功，一定发送完一条数据，所以直接pop</span><br><br><span class="hljs-comment">//如果发送队列不为空，则继续发送</span><br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, shared_self));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<span class="hljs-comment">//关闭会话</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">//从服务器中移除</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//读回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-comment">//已经移动的字符数</span><br><span class="hljs-type">int</span> copy_len = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//如果接受到了数据，则继续接收</span><br><span class="hljs-keyword">while</span> (bytes_transferred &gt; <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-comment">//如果未处理头部，则先处理头部</span><br><span class="hljs-keyword">if</span> (!_b_head_parse) &#123;<br><span class="hljs-comment">//情况1：收到的数据不足头部大小</span><br><span class="hljs-keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;<br><br><span class="hljs-comment">//将数据复制到头部节点</span><br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_head_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//情况2：收到的数据比头部多</span><br><br><span class="hljs-comment">//头部剩余未复制的长度</span><br><span class="hljs-type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;<br><span class="hljs-built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);<br><br><span class="hljs-comment">//更新已处理的data长度和剩余未处理的长度</span><br>copy_len += head_remain;<br>bytes_transferred -= head_remain;<br><br><span class="hljs-comment">//获取头部数据（应该接受到的消息，而不是真正接受到的消息）</span><br><span class="hljs-type">short</span> data_len = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);<br><br><span class="hljs-comment">//网络字节序转化为本地字节序</span><br>data_len = boost::asio::detail::socket_ops::<span class="hljs-built_in">network_to_host_short</span>(data_len);<br>cout &lt;&lt; <span class="hljs-string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br><br><span class="hljs-comment">//头部长度非法</span><br><span class="hljs-keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;<br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);    <span class="hljs-comment">//从服务器中移除</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//创建接收消息节点</span><br>_recv_msg_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(data_len);<br><br><span class="hljs-comment">//情况3：消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; data_len) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续接收</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><br><span class="hljs-comment">//头部处理完成,下一个回调处理头部。</span><br>_b_head_parse = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//情况4：接受的长度 &gt; 头部规定的长度，说明数据已经收全，则将消息放到接收节点里</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);<br>_recv_msg_node-&gt;_cur_len += data_len;<br>copy_len += data_len;<br>bytes_transferred -= data_len;<br><br><span class="hljs-comment">//将最后一个位置置为&#x27;\0&#x27;，表示一个消息的结束(其实也不需要)</span><br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><span class="hljs-comment">//情况5:继续轮询剩余未处理数据(下一个头部）</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<span class="hljs-comment">//清空头部节点</span><br><br><span class="hljs-comment">//如果剩余数据没有了，则继续接收</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续接收</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//否则处理头部</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">//已经处理完头部，处理上次未接受完的消息数据</span><br><br><br><span class="hljs-comment">//获取应该处理的长度</span><br><span class="hljs-type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;<br><br><span class="hljs-comment">//情况1：接受的数据&lt;应该接受的数据</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;<br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);<br>_recv_msg_node-&gt;_cur_len += bytes_transferred;<br><br><span class="hljs-comment">//清空消息缓冲区，继续接收</span><br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//情况2：接受的数据&gt;应该接受的数据</span><br><span class="hljs-built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);<br>_recv_msg_node-&gt;_cur_len += remain_msg;<br>bytes_transferred -= remain_msg;<br>copy_len += remain_msg;<br><br><span class="hljs-comment">//将最后一个位置置为&#x27;\0&#x27;，表示一个消息的结束(其实也不需要)</span><br>_recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;<br><span class="hljs-comment">//此处可以调用Send发送测试</span><br><span class="hljs-built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);<br><br><br><span class="hljs-comment">//处理下一个消息的头部</span><br>_b_head_parse = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//清空头部节点</span><br>_recv_head_node-&gt;<span class="hljs-built_in">Clear</span>();<br><br><span class="hljs-comment">//如果剩余数据没有了，则继续接收</span><br><span class="hljs-keyword">if</span> (bytes_transferred &lt;= <span class="hljs-number">0</span>) &#123;<br>::<span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//否则处理头部</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-built_in">Close</span>();<span class="hljs-comment">//关闭会话</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<span class="hljs-comment">//从服务器中移除</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>处理粘包具体步骤：</strong></p><ol><li>判断是否在读头部，分为两种情况</li><li>读头部：<ul><li>收到的数据还不够2字节，那么头部构造不出来，继续异步接受，return</li><li>收到的数据够头部，解析出头部，然后将剩余的数据与解析出的数据对比</li><li>如果剩余的数据<code>少于</code>解析出的头部，那么接着读，并且下一次读到（内容区）</li><li>如果剩余的数据<code>大于</code>解析出的头部，构造完整消息，如果还有数据，continue，否则接着监听</li></ul></li><li>读内容：<ul><li>收到的数据不够装满内容区，则接着监听，return</li><li>收到的数据<code>大于</code>内容区域,内容数据构造完后，下一次需要读，如果剩余数据为0，则接着监听，如果还有数据，则continue</li></ul></li></ol><h1 id="Cserver类"><a href="#Cserver类" class="headerlink" title="Cserver类"></a>Cserver类</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//端口号</span><br><span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//接受回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br><span class="hljs-comment">//开始接受</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>;<br><br><br>boost::asio::io_context&amp; _io_context;<br><span class="hljs-type">short</span> _port;<br>tcp::acceptor _acceptor;<span class="hljs-comment">//接收器（需要端点）</span><br><br><span class="hljs-comment">//会话列表</span><br>std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port) :_io_context(io_context), _port(port),<br>_acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br>shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该服务虽然实现了粘包处理，但是服务器仍存在不足，比如当客户端和服务器处于不同平台时收发数据会出现异常，根本原因是未处理大小端模式的问题</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio健壮的异步服务器</title>
    <link href="/2023/11/13/cpp/asio%E5%BB%B6%E9%95%BFsession%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/11/13/cpp/asio%E5%BB%B6%E9%95%BFsession%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>asio异步应答服务器存在隐患，就是因为使用了delete删除session对象，而本章使用智能指针防止重复delete对象session，使用智能指针构造成一个伪闭包的状态延长session的生命周期。</p><h1 id="智能指针管理Session"><a href="#智能指针管理Session" class="headerlink" title="智能指针管理Session"></a>智能指针管理Session</h1><p>我们可以通过智能指针的方式管理Session类，将<code>acceptor</code>接收的链接保存在<code>Session类型</code>的<code>智能指针</code>里。由于智能指针会在引用计数为0时自动析构，所以为了防止其被自动回收，也方便Server管理Session。因为我们后期会做一些重连踢人等业务逻辑，我们在Server类中添加成员变量，该变量为一个map类型，<code>key为Session的uid</code>，<code>value为该Session的智能指针</code>,此时也会增加引用计数</p><h1 id="session类"><a href="#session类" class="headerlink" title="session类"></a>session类</h1><h2 id="session类定义"><a href="#session类定义" class="headerlink" title="session类定义"></a>session类定义</h2><ul><li>首先定义一个消息节点，表示接受或者发送的消息</li><li>定义session类，继承std::enable_shared_from_this&lt;CSession&gt;</li><li>session存储socket，server，消息队列，uuid</li><li>回调函数中多一个参数，shared_ptr&lt;CSession&gt; _self_shared，传入_self_shared保证引用计数+1，从而防止隐患</li></ul><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENGTH  1024</span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span>;<br><br><br><span class="hljs-comment">//定义消息节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgNode</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_len) &#123;<br>_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[max_len];<br><span class="hljs-built_in">memcpy</span>(_data, msg, max_len);<br>&#125;<br><br>~<span class="hljs-built_in">MsgNode</span>() &#123;<br><span class="hljs-keyword">delete</span>[] _data;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _cur_len;<span class="hljs-comment">//当前发送（接受）消息长度</span><br><span class="hljs-type">int</span> _max_len;<span class="hljs-comment">//最大消息长度</span><br><span class="hljs-type">char</span>* _data;<span class="hljs-comment">//消息内容</span><br>&#125;;<br><br><span class="hljs-comment">//定义会话类，继承自enable_shared_from_this，用于在异步操作中获取this指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSession</span> :<span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数只需要io_context，不需要ip、端口，因为是服务器方，accecptor才会有ip和端口</span><br><span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);<br>    <br>~<span class="hljs-built_in">CSession</span>() &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Ssession destruct&quot;</span> &lt;&lt; endl;<br>&#125;<br>    <br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">GetSocket</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function">std::string&amp; <span class="hljs-title">GetUuid</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//开启监听状态</span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span></span>;<span class="hljs-comment">//开启写状态</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读回调，注意最后一个参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br>    <br>    <span class="hljs-comment">//写回调，不需要指定bytes_transferred，注意最后一个参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;<br><br><br><span class="hljs-comment">//会话的socket</span><br>tcp::socket _socket;<br><span class="hljs-comment">//每个会话都有一个唯一的uuid</span><br>std::string _uuid;<br><br><span class="hljs-comment">//接收数据的缓冲区</span><br><span class="hljs-type">char</span> _data[MAX_LENGTH];<br><br><span class="hljs-comment">//对应的服务器</span><br>CServer* _server;<br><br><span class="hljs-comment">//发送队列</span><br>std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;<br><br><span class="hljs-comment">//发送锁，防止多线程同时发送</span><br>std::mutex _send_lock;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="session实现"><a href="#session实现" class="headerlink" title="session实现"></a>session实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//构造函数，初始化socket对象，初始化server，同时初始化随机数uuid，用于标识每个连接</span><br>CSession::<span class="hljs-built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server) :<br>_socket(io_context), _server(server) &#123;<br>boost::uuids::uuid  a_uuid = boost::uuids::<span class="hljs-built_in">random_generator</span>()();<br>_uuid = boost::uuids::<span class="hljs-built_in">to_string</span>(a_uuid);<br>&#125;<br><br><span class="hljs-function">tcp::socket&amp; <span class="hljs-title">CSession::GetSocket</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _socket;<br>&#125;<br><br><span class="hljs-function">std::string&amp; <span class="hljs-title">CSession::GetUuid</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> _uuid;<br>&#125;<br><br><br><br><span class="hljs-comment">//开始监听读取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//注意绑定的是shared_from_this()！！</span><br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><span class="hljs-comment">//读回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleRead</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;read data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><br><span class="hljs-comment">//将读取到的数据发送给客户端</span><br><span class="hljs-built_in">Send</span>(_data, bytes_transferred);<br><span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br><br><span class="hljs-comment">//继续监听读取</span><br>_socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>,<br>std::placeholders::_1, std::placeholders::_2, _self_shared));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//如果读取失败，清除session</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//填入消息队列发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否有待发送的数据</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果有待发送的数据，将数据放入队列，等待发送</span><br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><span class="hljs-keyword">if</span> (pending) &#123;<span class="hljs-comment">//如果有待发送的数据，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果没有待发送的数据，直接发送</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br><br><span class="hljs-comment">//写回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::HandleWrite</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-comment">//由于async_write一次发送数据完整，所以可以直接pop</span><br>_send_que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!_send_que.<span class="hljs-built_in">empty</span>()) &#123;<span class="hljs-comment">//如果还有待发送的数据，继续发送</span><br><span class="hljs-keyword">auto</span>&amp; msgnode = _send_que.<span class="hljs-built_in">front</span>();<br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_max_len),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, _self_shared));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><span class="hljs-comment">//如果写入失败，清除session</span><br>_server-&gt;<span class="hljs-built_in">ClearSession</span>(_uuid);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>start中开始异步读，读回调有send函数（异步写），然后接着开始异步读，继续监听</li><li>send函数开始异步写（如果此时没有在发送消息），写回调中开始异步写，直到全部写完</li></ul><blockquote><p>注意，此方式中:</p><p>异步读-&gt;读回调（这个里面调用send，开启异步写）-&gt;异步读</p><p>异步写-&gt;写回调-&gt;异步写</p></blockquote><p>如果回调函数中不增加引用计数，就会存在风险，假设异步读<strong>之后</strong>，客户端关闭连接，此时读回调<code>调用</code>send开启异步写，然后读回调<code>开启</code>异步读，会Clearsesson（uuid）两次，这样可能会导致：shared_ptr引用计数变为0，最后一次调用的时候，访问不存在的内存</p><h1 id="Cserver类"><a href="#Cserver类" class="headerlink" title="Cserver类"></a>Cserver类</h1><h2 id="Cserver类定义"><a href="#Cserver类定义" class="headerlink" title="Cserver类定义"></a>Cserver类定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CSession.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CServer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//accecptor需要端口</span><br><span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port);<br>    <br>    <span class="hljs-comment">//删除map中的session</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearSession</span><span class="hljs-params">(std::string)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <br>    <span class="hljs-comment">//接受回调，第一个参数是智能指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt;, <span class="hljs-type">const</span> boost::system::error_code &amp; error)</span></span>;<br>   <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartAccept</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//开启接受服务器（接受状态）</span><br>    <br>boost::asio::io_context &amp;_io_context;<br><span class="hljs-type">short</span> _port;<br>tcp::acceptor _acceptor;<br>std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Cserver实现"><a href="#Cserver实现" class="headerlink" title="Cserver实现"></a>Cserver实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>CServer::<span class="hljs-built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="hljs-type">short</span> port):_io_context(io_context), _port(port),<br>_acceptor(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(),port))<br>&#123;<br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><span class="hljs-comment">//接受回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::HandleAccept</span><span class="hljs-params">(shared_ptr&lt;CSession&gt; new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>&#123;<br><span class="hljs-keyword">if</span> (!error) &#123;<br>new_session-&gt;<span class="hljs-built_in">Start</span>();<span class="hljs-comment">//开启监听</span><br>_sessions.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_session-&gt;<span class="hljs-built_in">GetUuid</span>(), new_session));<span class="hljs-comment">//插入map中</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br><br>    <span class="hljs-comment">//继续开启服务器</span><br><span class="hljs-built_in">StartAccept</span>();<br>&#125;<br><br><br><span class="hljs-comment">//开启接受状态，注意，session必须是智能指针！！</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::StartAccept</span><span class="hljs-params">()</span> </span>&#123;<br>shared_ptr&lt;CSession&gt; new_session = <span class="hljs-built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="hljs-keyword">this</span>);<br>    <br>    <span class="hljs-comment">//接受到新的连接，此时new_session-&gt;GetSocket()是被绑定到一个会话了，然后回调，注意传参是shared_ptr</span><br>_acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">GetSocket</span>(), std::<span class="hljs-built_in">bind</span>(&amp;CServer::HandleAccept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>    <br>    <span class="hljs-comment">//此函数结束后，new_session销毁，引用计数-1，但是回调函数中还在使用，所以没释放内存</span><br>&#125;<br><br><span class="hljs-comment">//map中删除这个session，引用计数-1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CServer::ClearSession</span><span class="hljs-params">(std::string uuid)</span> </span>&#123;<br>_sessions.<span class="hljs-built_in">erase</span>(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><h2 id="shared-ptr的初始化问题"><a href="#shared-ptr的初始化问题" class="headerlink" title="shared_ptr的初始化问题"></a>shared_ptr的初始化问题</h2><p>不能用两个智能指针管理同一块内存，如下用法是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_ptr</span>&lt;CSession&gt;(<span class="hljs-keyword">this</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>shared_ptr&lt;CSession&gt;(this)生成的新智能指针和this之前绑定的智能指针并不共享引用计数，所以要通过shared_from_this()函数返回智能指针，该智能指针和其他管理这块内存的智能指针共享引用计数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Start</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, MAX_LENGTH);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleRead, <span class="hljs-keyword">this</span>, <br>        std::placeholders::_1, std::placeholders::_2, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，send函数中第一次发送也要绑定shared_from_this()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//填入消息队列发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CSession::Send</span><span class="hljs-params">(<span class="hljs-type">char</span>* msg, <span class="hljs-type">int</span> max_length)</span> </span>&#123;<br><span class="hljs-type">bool</span> pending = <span class="hljs-literal">false</span>;<span class="hljs-comment">//是否有待发送的数据</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_send_lock)</span></span>;<br><span class="hljs-keyword">if</span> (_send_que.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果有待发送的数据，将数据放入队列，等待发送</span><br>pending = <span class="hljs-literal">true</span>;<br>&#125;<br>_send_que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));<br><span class="hljs-keyword">if</span> (pending) &#123;<span class="hljs-comment">//如果有待发送的数据，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果没有待发送的数据，直接发送</span><br>boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(msg, max_length),<br>std::<span class="hljs-built_in">bind</span>(&amp;CSession::HandleWrite, <span class="hljs-keyword">this</span>, std::placeholders::_1, <span class="hljs-built_in">shared_from_this</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this()"></a>shared_from_this()</h2><p><code>shared_from_this()</code> 方法来获取当前对象的 <code>shared_ptr</code> 实例。这样可以确保你得到的 <code>shared_ptr</code> 与最初用于创建当前对象的 <code>shared_ptr</code> 共享相同的控制块。</p><blockquote><p>注意，使用shared_from_this(),必须保证这个类对象是用make_shared方式创建的！！！</p></blockquote><h1 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h1><ul><li>服务器 (<code>Server</code>) 初始化一个新的会话 (<code>Session</code>)，并为该会话分配一个网络套接字 (<code>Socket</code>)。</li><li>接受<code>session</code>后，回调函数中开启监听(<code>async_read_some</code>),然后回调函数中继续开启接受状态（<code>StartAccept()</code>)</li><li>监听到消息，<code>读</code>回调中调用<code>send</code>（开启写），然后<code>读</code>回调中继续开启监听（<code>async_read_some</code>）</li><li>send开启写(<code>async_write</code>),<code>写</code>回调中继续<code>写</code>，直到写完</li><li>sesson有问题，直接删除即可，整个异步过程的所有函数都有此对象的引用，直到所有函数执行完毕，引用计数才会清0</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio普通的异步服务器</title>
    <link href="/2023/11/13/cpp/asio%E6%99%AE%E9%80%9A%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/13/cpp/asio%E6%99%AE%E9%80%9A%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要实现一个异步应答服务器</p></blockquote><blockquote><p>分文两个类</p><p>session：session类主要是处理客户端消息收发的会话类，属于服务端</p><p>server：server类为服务器接收连接的管理类，用于管理多个session，属于服务端</p></blockquote><h1 id="session类"><a href="#session类" class="headerlink" title="session类"></a>session类</h1><p><strong>成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(boost::asio::io_context&amp; ioc):_socket(ioc)&#123;<br>    &#125;<br>    <span class="hljs-function">tcp::socket&amp; <span class="hljs-title">Socket</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> _socket;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//读操作回调函数需要2个参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span></span>;<br>    <span class="hljs-comment">//写操作只需要1个参数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br>    tcp::socket _socket;<br>    <span class="hljs-keyword">enum</span> &#123;max_length = <span class="hljs-number">1024</span>&#125;;<br>    <span class="hljs-type">char</span> _data[max_length];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>_data用来接收客户端传递的数据</li><li>_socket为单独处理客户端读写的socket。</li><li>handle_read和handle_write分别为读回调函数和写回调函数。</li></ul><blockquote><p>注意，读写回调函数的参数数量不同</p></blockquote><p><strong>具体实现</strong></p><h2 id="1-start函数"><a href="#1-start函数" class="headerlink" title="(1)start函数"></a>(1)<code>start函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    <span class="hljs-comment">//读操作，读完调用handle_read</span><br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1,<br>            placeholders::_2)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在Start方法中我们调用异步读操作，监听对端发送的消息。当对端发送数据后，触发handle_read函数</p><h2 id="2-handle-read函数"><a href="#2-handle-read函数" class="headerlink" title="(2)handle_read函数"></a>(2)<code>handle_read函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transfered)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br><br>        <span class="hljs-comment">//读完后，异步调用写操作，返回消息给发送者，返回后，调用handle_write函数</span><br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transfered),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handle_read函数内将收到的数据发送给对端，当发送完成后触发handle_write回调函数。</p><h2 id="3-handle-write函数"><a href="#3-handle-write函数" class="headerlink" title="(3)handle_write函数"></a>(3)<code>handle_write函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br><br>        <span class="hljs-comment">//发送完后，调用异步读操作，读取发送者发送的消息，读取完后，再次调用handle_read函数，形成循环</span><br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length), std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read,<br>            <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>handle_write函数内又一次监听了读事件，如果对端有数据发送过来则触发handle_read，我们再将收到的数据发回去。从而达到应答式服务的效果。</p><h1 id="server类"><a href="#server类" class="headerlink" title="server类"></a>server类</h1><p>server类是服务器接收连接的管理类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">server</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数，初始化acceptor对象</span><br>    <span class="hljs-built_in">server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port);<br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-comment">//服务器开始接受连接</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_accept</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//新连接触发后的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_accept</span><span class="hljs-params">(session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span></span>;<br><br>    boost::asio::io_context&amp; _ioc;<br>    tcp::acceptor _acceptor;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>start_accept将要接收连接的acceptor绑定到服务上，其内部就是将accpeptor对应的socket描述符绑定到epoll或iocp模型上，实现事件驱动。</li><li>handle_accept为新连接到来后触发的回调函数。</li></ul><h2 id="（a-构造函数"><a href="#（a-构造函数" class="headerlink" title="（a) 构造函数"></a>（a) <code>构造函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">server::<span class="hljs-built_in">server</span>(boost::asio::io_context&amp; ioc, <span class="hljs-type">short</span> port) :_ioc(ioc),<br><span class="hljs-comment">//初始化acceptor对象（协议+监听端口，表示监听主机上的所有 IPv4 地址上的指定端口）</span><br>_acceptor(ioc, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)) &#123;<br>    <span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//启动接受连接</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始化ioc和accecptor</li><li>启动接受连接</li></ul><h2 id="b-start-accept函数"><a href="#b-start-accept函数" class="headerlink" title="(b)start_accept函数"></a>(b)<code>start_accept函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//保存新连接的socket对象</span><br>    session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">session</span>(_ioc);<br><br>    <span class="hljs-comment">//异步接受连接，调用handle_accept函数</span><br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>        std::<span class="hljs-built_in">bind</span>(&amp;server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>保存socket对象</li><li>异步接受连接，然后调用<code>handle_accecpt函数</code></li><li>使用异步接受连接，因为防止阻塞</li></ul><blockquote><p>注意：开启异步接受连接，不代表立马会有客户端连接过来，而是等客户端连接过来才触发async_accept函数，连接完后调用handle_accept函数！！！！</p></blockquote><h2 id="c-handle-accept函数"><a href="#c-handle-accept函数" class="headerlink" title="(c)handle_accept函数"></a>(c)<code>handle_accept函数</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::handle_accept</span><span class="hljs-params">(Session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-comment">//开启异步监听客户端的消息，这一步不会阻塞</span><br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br>    <span class="hljs-comment">//继续接受新连接</span><br>    <span class="hljs-built_in">start_accept</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意，start是异步读操作，不会阻塞</p></blockquote><h1 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h1><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/array.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;server.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;session.h&quot;</span></span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>asio::io_context io_context;<br><span class="hljs-function">server <span class="hljs-title">s</span><span class="hljs-params">(io_context, <span class="hljs-number">8080</span>)</span></span>;<br>io_context.<span class="hljs-built_in">run</span>();<br>&#125;<br><span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>io_context.run()的作用</strong></p><ol><li><strong>启动事件循环</strong>：<ul><li><code>io_context.run()</code> 调用开始一个事件处理循环，负责执行所有排队的异步操作的处理程序。</li></ul></li><li><strong>执行异步操作处理程序</strong>：<ul><li>这个循环处理由异步操作（如异步读取、写入、连接接受）触发的处理程序（handlers）。</li></ul></li><li><strong>阻塞行为</strong>：<ul><li>函数执行时是阻塞的，意味着它会持续运行，直到所有异步操作完成或 <code>io_context</code> 被停止。</li></ul></li><li><strong>确保线程安全</strong>：<ul><li>所有异步操作的处理程序都在 <code>io_context.run()</code> 提供的上下文中安全地执行，这有助于维护线程安全。</li></ul></li><li><strong>驱动程序的核心</strong>：<ul><li><code>io_context.run()</code> 是 Boost.Asio 应用程序的驱动力，没有它，异步操作不会执行。</li></ul></li><li><strong>处理所有异步事件</strong>：<ul><li>包括网络 I&#x2F;O 操作、定时器事件等，都是在 <code>io_context.run()</code> 的循环中被处理。</li></ul></li><li><strong>应用程序的持续运行</strong>：<ul><li>主线程在调用 <code>run</code> 后会在事件循环中阻塞，这保证了应用程序可以持续处理异步事件，直到不再需要处理或被显式停止。</li></ul></li></ol><h1 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h1><p>该demo示例为仿照asio官网编写的，其中存在隐患，就是当服务器即将发送数据前(调用async_write前)，此刻客户端中断，服务器此时调用async_write会触发发送回调函数，判断ec为非0进而执行delete this逻辑回收session。但要注意的是客户端关闭后，在tcp层面会触发读就绪事件，服务器会触发读事件回调函数。在读事件回调函数中判断错误码ec为非0，进而再次执行delete操作，从而造成二次析构，这是极度危险的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个demo介绍了异步读写的相关操作，下面是对于常用函数的总结，以及对异步的理解</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="（a-开启异步读"><a href="#（a-开启异步读" class="headerlink" title="（a)开启异步读"></a><strong>（a)开启异步读</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启异步读就好，然后结束start</li></ul><h3 id="b-异步读async-read-some"><a href="#b-异步读async-read-some" class="headerlink" title="(b)异步读async_read_some"></a><strong>(b)异步读</strong>async_read_some</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::Start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>    <span class="hljs-comment">//指定读到哪，读多少</span><br>    _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>                            <span class="hljs-comment">//读完后回调，去写</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//回调函数处理异步写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transferred),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>开启异步读</li><li>参数（buffer，回调函数）</li><li>buffer需要数组首地址，以及读取的<strong>最大长度</strong>(并不是读完max_lengtg才会回调！！)</li><li>回调函数需要两个参数error和bytes_transferred，因为不能保证数据一次性发完</li></ul><h3 id="c-异步写async-write"><a href="#c-异步写async-write" class="headerlink" title="(c)异步写async_write"></a><strong>(c)异步写async_write</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_read</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error, <span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;<br>        <span class="hljs-comment">//异步发送数据给客户端，发送完回调</span><br>        boost::asio::<span class="hljs-built_in">async_write</span>(_socket, boost::asio::<span class="hljs-built_in">buffer</span>(_data, bytes_transferred),<br>                                 <span class="hljs-comment">//回调，开启异步读</span><br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_write, <span class="hljs-keyword">this</span>, placeholders::_1));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">session::handle_write</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">memset</span>(_data, <span class="hljs-number">0</span>, max_length);<br>        <span class="hljs-comment">//异步读</span><br>        _socket.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(_data, max_length),<br>            std::<span class="hljs-built_in">bind</span>(&amp;session::handle_read, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>异步写函数在异步读的回调函数中</li><li>异步写发送数据给客户端，然后回调函数中调用异步读</li><li>参数（buffer，回调函数）</li><li>buffer需要首地址，以及要发送的长度</li><li>回调函数只需要一个参数，那就是error，因为write一定会发送完的</li></ul><h3 id="d-异步接受连接async-accept"><a href="#d-异步接受连接async-accept" class="headerlink" title="(d)异步接受连接async_accept"></a><strong>(d)异步接受连接async_accept</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::start_accept</span><span class="hljs-params">()</span> </span>&#123;<br>    session* new_session = <span class="hljs-keyword">new</span> <span class="hljs-built_in">session</span>(_ioc);<br>    _acceptor.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>                           <span class="hljs-comment">//创建新连接后，回调</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;server::handle_accept, <span class="hljs-keyword">this</span>, new_session, placeholders::_1));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">server::handle_accept</span><span class="hljs-params">(session* new_session, <span class="hljs-type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        new_session-&gt;<span class="hljs-built_in">Start</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> new_session;<br>    &#125;<br>    <span class="hljs-built_in">start_accept</span>();<span class="hljs-comment">//接着等待接受新连接</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建一个新的 <code>session</code> 对象，准备处理新连接。</li><li>使用 <code>_acceptor.async_accept</code> 异步等待新的连接请求。</li><li>当有新的连接时，<code>handle_accept</code> 会被调用。</li></ul><h2 id="e-bind绑定回调函数的参数问题"><a href="#e-bind绑定回调函数的参数问题" class="headerlink" title="(e)bind绑定回调函数的参数问题"></a>(e)bind绑定回调函数的参数问题</h2><blockquote><h3 id="Boost-Asio-异步操作的回调函数"><a href="#Boost-Asio-异步操作的回调函数" class="headerlink" title="Boost Asio 异步操作的回调函数"></a>Boost Asio 异步操作的回调函数</h3><p>Boost Asio 的异步操作，如 <code>async_read</code>、<code>async_write</code> 等，通常要求你提供一个回调函数。这个回调函数通常接受两个参数：</p><p><strong>Error Code</strong> (<code>boost::system::error_code</code>)：表明异步操作成功或失败的错误码。</p><p><strong>Bytes Transferred</strong> (<code>size_t</code>)：传输的字节数。</p></blockquote><ol><li><p><strong>绑定所有参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>, placeholders::_1, placeholders::_2)<br></code></pre></td></tr></table></figure></li><li><p><strong>绑定部分参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>, placeholders::_1)<br><span class="hljs-comment">//只有错误码会被传递给回调函数。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不绑定任何参数</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">bind</span>(&amp;YourClass::YourCallbackFunction, <span class="hljs-keyword">this</span>)<br></code></pre></td></tr></table></figure><hr></li></ol><h2 id="对异步的理解"><a href="#对异步的理解" class="headerlink" title="对异步的理解"></a>对异步的理解</h2><ul><li><h3 id="异步操作的特点"><a href="#异步操作的特点" class="headerlink" title="异步操作的特点"></a>异步操作的特点</h3><ol><li><strong>事件驱动</strong>：<ul><li>异步操作是基于事件的。这意味着操作（如读取、写入、接受连接等）等待特定的网络事件发生，如数据到达或连接建立。</li></ul></li><li><strong>非阻塞行为</strong>：<ul><li>异步操作不会阻塞程序的其余部分。它们在后台“监听”或等待事件发生，而程序可以继续执行其他任务。</li></ul></li><li><strong>回调函数</strong>：<ul><li>当相应的事件发生（例如，数据到达用于读取的套接字），异步操作完成，并触发定义好的回调函数。</li><li>回调函数通常用于处理事件结果，如读取数据或发送响应。</li></ul></li></ol><h3 id="异步读取和写入的循环"><a href="#异步读取和写入的循环" class="headerlink" title="异步读取和写入的循环"></a>异步读取和写入的循环</h3><ul><li>当 <code>async_read_some</code> 或类似函数被调用时，它开始监听数据到达事件。如果没有数据到达，这个函数不会执行其回调。</li><li>在异步读取的回调函数中启动异步写入是一种常见的模式。这确保了服务器在处理完一个请求后立即准备发送响应。</li><li>完成异步写入后，通常会再次启动异步读取操作，维持与客户端的持续通信。</li></ul><h3 id="异步接受连接"><a href="#异步接受连接" class="headerlink" title="异步接受连接"></a>异步接受连接</h3><ul><li><code>async_accept</code> 类似地监听新的连接请求。如果没有新的连接尝试，它会保持在监听状态，直到有新的连接请求到达。</li><li>一旦接受到新的连接，将调用 <code>async_accept</code> 指定的回调函数来处理这个新连接。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio异步读写操作及注意事项</title>
    <link href="/2023/11/12/cpp/asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/11/12/cpp/asio%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍异步读写操作。</p><p>定义个session类，这个session类表示服务器处理客户端连接的管理类</p><p>其中有socket对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(std::shared_ptr&lt;asio::ip::tcp::socket&gt; socket);<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::ip::tcp::endpoint&amp; ep)</span></span>;<span class="hljs-comment">//连接端点</span><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<span class="hljs-comment">//智能指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>session类定义了一个socket成员变量，负责处理对端的连接读写，封装了Connect函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::Connect</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::ip::tcp::endpoint &amp;ep)</span> </span>&#123;<br>    _socket-&gt;<span class="hljs-built_in">connect</span>(ep);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步写操作"><a href="#异步写操作" class="headerlink" title="异步写操作"></a>异步写操作</h1><p>在写操作前，我们先封装一个MsgNode结构，用来管理要<code>发送和接收</code>的数据，该结构包含<code>数据域首地址</code>，<code>数据的总长度</code>，以及<code>已经处理的长度</code>(已读的长度或者已写的长度)</p><h2 id="async-write-some方式"><a href="#async-write-some方式" class="headerlink" title="async_write_some方式"></a>async_write_some方式</h2><blockquote><p>一次性不一定发送完数据</p></blockquote><h3 id="定义MsgNode类用于封装数据"><a href="#定义MsgNode类用于封装数据" class="headerlink" title="定义MsgNode类用于封装数据"></a>定义MsgNode类用于封装数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最大报文接收大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> RECVSIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MsgNode</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-comment">//发送数据的构造函数</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg,  <span class="hljs-type">int</span> total_len): _total_len(total_len), _cur_len(<span class="hljs-number">0</span>)&#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>        <span class="hljs-built_in">memcpy</span>(_msg, msg, total_len);<br>    &#125;<br>    <span class="hljs-comment">//接受数据的构造函数</span><br>    <span class="hljs-built_in">MsgNode</span>(<span class="hljs-type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="hljs-number">0</span>) &#123;<br>        _msg = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[total_len];<br>    &#125;<br>    ~<span class="hljs-built_in">MsgNode</span>()&#123;<br>        <span class="hljs-keyword">delete</span>[]_msg;<br>    &#125;<br>    <span class="hljs-comment">//消息首地址</span><br>    <span class="hljs-type">char</span>* _msg;<br>    <span class="hljs-comment">//总长度</span><br>    <span class="hljs-type">int</span> _total_len;<br>    <span class="hljs-comment">//当前长度</span><br>    <span class="hljs-type">int</span> _cur_len;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="为Session添加异步写操作"><a href="#为Session添加异步写操作" class="headerlink" title="为Session添加异步写操作"></a>为Session添加异步写操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred,</span></span><br><span class="hljs-params"><span class="hljs-function">    std::shared_ptr&lt;MsgNode&gt;)</span></span>;<br>    <span class="hljs-comment">//写函数（传入需要写的数据）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;MsgNode&gt; _send_node;<span class="hljs-comment">//定义需要发送的数据</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现void-WriteToSocketErr函数"><a href="#实现void-WriteToSocketErr函数" class="headerlink" title="实现void WriteToSocketErr函数"></a>实现<code>void WriteToSocketErr函数</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//构造发送数据</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>async_wirte_some函数第一个参数是buffer，第二个参数是回调函数）</p></blockquote><h3 id="实现WriteCallBackErr函数"><a href="#实现WriteCallBackErr函数" class="headerlink" title="实现WriteCallBackErr函数"></a>实现<code>WriteCallBackErr</code>函数</h3><p>因为WriteCallBackErr函数为三个参数且为成员函数，而<strong>async_write_some需要的回调函数为两个参数</strong>，所以我们通过bind将三个参数转换为两个参数的普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, </span></span><br><span class="hljs-params"><span class="hljs-function">    std::<span class="hljs-type">size_t</span> bytes_transferred, std::shared_ptr&lt;MsgNode&gt; msg_node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bytes_transferred + msg_node-&gt;_cur_len <br>        &lt; msg_node-&gt;_total_len) &#123;<br>        _send_node-&gt;_cur_len += bytes_transferred;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg+_send_node-&gt;_cur_len,<br>            _send_node-&gt;_total_len-_send_node-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单凭这两个不可以投入使用，具体原因是</p></blockquote><p>我们可以通过队列保证应用层的发送顺序。我们在Session中定义一个发送队列，然后重新定义正确的异步发送函数和回调处理</p><h3 id="定义queue写入消息（重点）"><a href="#定义queue写入消息（重点）" class="headerlink" title="定义queue写入消息（重点）"></a>定义queue写入消息（重点）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;buf)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue;<span class="hljs-comment">//用来缓存要发送的消息节点</span><br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    <span class="hljs-type">bool</span> _send_pending;<span class="hljs-comment">//该变量为true表示一个节点还未发送完。</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现queue异步写入功能"><a href="#实现queue异步写入功能" class="headerlink" title="实现queue异步写入功能"></a><strong>实现queue异步写入功能</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span></span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf), std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack, <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标志正在发送消息...</span><br>&#125;<br><br><span class="hljs-comment">//回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code &amp; ec,  std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error , code is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; . Message is &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//取出队首元素即当前未发送完数据</span><br>    <span class="hljs-keyword">auto</span> &amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>    send_data-&gt;_cur_len += bytes_transferred;<br>    <br>    <span class="hljs-comment">//数据未发送完， 则继续发送（相当于递归）</span><br>    <span class="hljs-keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len-send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>    _send_pending=<span class="hljs-literal">false</span>;<span class="hljs-comment">//消息发送完毕</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="async-send方式"><a href="#async-send方式" class="headerlink" title="async_send方式"></a>async_send方式</h2><blockquote><p>一次性发送完数据</p></blockquote><p>其内部的实现原理就是帮我们不断的调用async_write_some直到完成发送，<code>async_send不能和async_write_some混合使用</code>，我们基于async_send封装另外一个发送函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不能与async_write_some混合使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">//插入发送队列</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">//pending状态说明上一次有未发送完的数据</span><br>    <span class="hljs-keyword">if</span> (_send_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>    _send_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span><br>            &lt;&lt; ec.<span class="hljs-built_in">value</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果发送完，此时一定发送完，则pop出队首元素</span><br>    _send_queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">//如果队列为空，则说明所有数据都发送完,将pending设置为false</span><br>    <span class="hljs-keyword">if</span> (_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        _send_pending = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果队列不是空，则继续将队首元素发送</span><br>    <span class="hljs-keyword">if</span> (!_send_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; send_data = _send_queue.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),<br>            std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<br>                <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步读操作"><a href="#异步读操作" class="headerlink" title="异步读操作"></a>异步读操作</h1><h2 id="async-read-some方式"><a href="#async-read-some方式" class="headerlink" title="async_read_some方式"></a>async_read_some方式</h2><blockquote><p>触发的回调函数获取的读数据的长度可能会小于要求读取的总长度</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadFromSocket</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;asio::ip::tcp::socket&gt; _socket;<br>    std::shared_ptr&lt;MsgNode&gt; _recv_node;<br>    <span class="hljs-type">bool</span> _recv_pending;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>recv_node用来缓存接收的数据，_recv_pending为true表示节点正在接收数据，还未接受完。</code></p><p><strong>具体实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不考虑粘包情况， 先用固定的字节接收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    <br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span></span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//没读完继续读</span><br>    <span class="hljs-keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;<br>        _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len,<br>            _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="async-receive方式"><a href="#async-receive方式" class="headerlink" title="async_receive方式"></a>async_receive方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (_recv_pending) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//可以调用构造函数直接构造，但不可用已经构造好的智能指针赋值</span><br>    <span class="hljs-comment">/*auto _recv_nodez = std::make_unique&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="hljs-comment">    _recv_node = _recv_nodez;*/</span><br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>    _recv_pending = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllCallBack</span><span class="hljs-params">(<span class="hljs-type">const</span> boost::system::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes_transferred)</span> </span>&#123;<br>    _recv_node-&gt;_cur_len += bytes_transferred;<br>    <span class="hljs-comment">//将数据投递到队列里交给逻辑线程处理，此处略去</span><br>    <span class="hljs-comment">//如果读完了则将标记置为false</span><br>    _recv_pending = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//指针置空</span><br>    _recv_node = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，async_read_some和async_receive不能混合使用，否则会出现逻辑问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>（a）对于异步写操作，流程如下</p><ol><li>设置队列</li><li>将需要写的放入队列里</li><li>如果此时在写，则return</li><li>否则开启写操作，绑定回调函数,然后标志”正在写“</li><li>回调函数实现递归逻辑，按照顺序完成队列中所有的写操作</li></ol><p>（b）对于异步读操作，流程如下</p><ol><li>如果此时在读，则return</li><li>否则开启读操作，绑定回调函数，然后标志”正在读“</li><li>回调函数实现递归逻辑，读完为止</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>对于写操作，尽量使用async_send<br>对于读操作，尽量使用async_read_some</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//async_write_some</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造发送数据</span><br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">// 异步发送数据</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br><br><span class="hljs-comment">//async_send</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteAllToSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造发送数据</span><br>    _send_queue.<span class="hljs-built_in">emplace</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MsgNode</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br>    <span class="hljs-comment">// 异步发送数据</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(buf), <span class="hljs-comment">//注意，这个一定是直接发完了，所以不需要指定长度******</span><br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//async_read_some</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadFromSocket</span><span class="hljs-params">()</span> </span>&#123;<br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    <span class="hljs-comment">// 异步读取数据</span><br>    _socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), <br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br><span class="hljs-comment">//async_receive</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::ReadAllFromSocket</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    _recv_node = std::<span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);<br>    <span class="hljs-comment">// 异步读取数据必须指定大小，表示接受多少数据</span><br>    _socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,<br>        std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio socket同步读写</title>
    <link href="/2023/11/12/cpp/asio%20socket%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99/"/>
    <url>/2023/11/12/cpp/asio%20socket%E5%90%8C%E6%AD%A5%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="同步写write-some"><a href="#同步写write-some" class="headerlink" title="同步写write_some"></a>同步写write_some</h1><p>write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wirte_to_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>std::string buf = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::<span class="hljs-type">size_t</span> total_bytes_written = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (total_bytes_written != buf.<span class="hljs-built_in">length</span>()) &#123;<br>total_bytes_written += sock.<span class="hljs-built_in">write_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>() + total_bytes_written, buf.<span class="hljs-built_in">length</span>() - total_bytes_written)<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步写send"><a href="#同步写send" class="headerlink" title="同步写send"></a>同步写send</h1><p>send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_send</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br>std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-type">int</span> send_length = sock.<span class="hljs-built_in">send</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步写write"><a href="#同步写write" class="headerlink" title="同步写write"></a>同步写write</h1><p>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_data_by_wirte</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br>std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-comment">//发送数据</span><br><span class="hljs-type">int</span> send_length = asio::<span class="hljs-built_in">write</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">if</span> (send_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;send failed&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读read-some"><a href="#同步读read-some" class="headerlink" title="同步读read_some"></a>同步读read_some</h1><p>同步读和同步写类似，提供了读取指定字节数的接口read_some</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">read_from_socket</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MESSAGE_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buf[MESSAGE_SIZE];<br>std::<span class="hljs-type">size_t</span> total_bytes_read = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//如果没有读到7个字节，那么一直阻塞</span><br><span class="hljs-keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;<br>total_bytes_read += sock.<span class="hljs-built_in">read_some</span>(<br>asio::<span class="hljs-built_in">buffer</span>(buf + total_bytes_read,<br>MESSAGE_SIZE - total_bytes_read));<br>&#125;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(buf, total_bytes_read);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read_some</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-comment">//读取数据</span><br><span class="hljs-built_in">read_from_socket</span>(sock);<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读receive"><a href="#同步读receive" class="headerlink" title="同步读receive"></a>同步读receive</h1><p>可以一次性同步读取对方发送的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_receive</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = sock.<span class="hljs-built_in">receive</span>(asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br><span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同步读read"><a href="#同步读read" class="headerlink" title="同步读read"></a>同步读read</h1><p>可以一次性同步接收对方发送的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_data_by_read</span><span class="hljs-params">()</span> </span>&#123;<br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//创建端点</span><br>asio::ip::<span class="hljs-function">tcp::endpoint</span><br><span class="hljs-function"><span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),</span></span><br><span class="hljs-params"><span class="hljs-function">port_num)</span></span>;<br>asio::io_service ios;<br><span class="hljs-comment">//打开套接字</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><span class="hljs-comment">//连接套接字</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = asio::<span class="hljs-built_in">read</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br><span class="hljs-keyword">if</span> (receive_length &lt;= <span class="hljs-number">0</span>) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br><span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>&lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br><span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读取直到指定字符"><a href="#读取直到指定字符" class="headerlink" title="读取直到指定字符"></a>读取直到指定字符</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string  <span class="hljs-title">read_data_by_until</span><span class="hljs-params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;<br>    asio::streambuf buf;<br>    <span class="hljs-comment">// Synchronously read data from the socket until</span><br>    <span class="hljs-comment">// &#x27;\n&#x27; symbol is encountered.  </span><br>    asio::<span class="hljs-built_in">read_until</span>(sock, buf, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    std::string message;<br>    <span class="hljs-comment">// Because buffer &#x27;buf&#x27; may contain some other data</span><br>    <span class="hljs-comment">// after &#x27;\n&#x27; symbol, we have to parse the buffer and</span><br>    <span class="hljs-comment">// extract only symbols before the delimiter. </span><br>    <span class="hljs-function">std::istream <span class="hljs-title">input_stream</span><span class="hljs-params">(&amp;buf)</span></span>;<br>    std::<span class="hljs-built_in">getline</span>(input_stream, message);<br>    <span class="hljs-keyword">return</span> message;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限制+修改单调队列（Ropeway）</title>
    <link href="/2023/11/11/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%B8%A6%E4%BF%AE%E6%94%B9/"/>
    <url>/2023/11/11/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%B8%A6%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/104128/problem/B">2022ICPC 南京B.Ropeway</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>n+2个点编号0到n+1，每个点有点权，要求选若干个点使得总点权最小，其中编号为0 和n + 1的点必须选且点权为0 ，同时满足任意两个被选的点之间的距离不超过k 。</p><p>此外还会给一个01串，表示1到n这些点是否为必选的点，1为必选，0为可选可不选</p><p>现在会给m个询问，每个询问为如果将<code>编号为x</code>的点权修改为v,答案是多少？每次询问互不影响</p><p>n&lt;&#x3D;5e5,m,k&lt;&#x3D;3e3</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>一眼单调队列，但是和普通单调队列不同，有些位置必须选，而且0，n+1都有一个点权为0的点，普通的单调队列是：0位置点权为0，而且每个点可选可不选</li><li>位置0和n+1容易处理，只需要设pre[i]为从前往后扫描，而且选i的最小花费，suf[i]表示从后往前扫描，而且选i的最小花费</li><li>有些位置必须选，可以这样思考，处理pre[i]的时候，枚举j的位置，j的区间为[i-m,i-1],表示上一个选的什么，但是如果i的前面有必须选的，那么j的范围就要改变，变成[k,i-1],k表示上一个必须选的位置，具体实现见代码</li><li>现在考虑修改，如果将位置x的值修改，那么会影响到pre和suf数组，会影响多少呢？对于pre来说，x到n全部被影响到，suf同理。</li><li>考虑答案是如何产生的，任选一个长度为k的区间，遍历这个区间所有的点，答案为min(pre[i]+suf[i]-a[i])</li><li>所以修改一个位置，保证suf不动，那么答案可以在[i,i+k]中产生，此时需要修改pre数组</li><li>但是6无法保证i+k&lt;&#x3D;n，但好像也没有关系，因为n+1这个点必选，那么从答案从n+1更新即可</li></ol><blockquote><p>第5点十分重要！！！</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> q[N],hh,tt;<span class="hljs-comment">//单调队列，存数组下标 </span><br><br><span class="hljs-type">int</span> n,k;<br>ll a[N];<span class="hljs-comment">//权值 </span><br><span class="hljs-type">char</span> s[N];<span class="hljs-comment">//s数组是01串，1表示必须选</span><br><br><span class="hljs-comment">//pre和suf表示分别从前后遍历，结尾为i的最小花费</span><br>ll pre[N],suf[N],tem[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//初始化队头队尾</span><br>hh=<span class="hljs-number">1</span>,tt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">(ll f[])</span> </span>&#123;<br><span class="hljs-built_in">init</span>();<br>q[++tt]=<span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n+<span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k) &#123;<br>hh++;<br>&#125;<br>f[i]=f[q[hh]]+a[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;f[q[tt]]&gt;=f[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//处理presuf数组</span><br><span class="hljs-built_in">get</span>(pre);<br><span class="hljs-built_in">reverse</span>(a,a+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">reverse</span>(s,s+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">get</span>(suf);<br><span class="hljs-built_in">reverse</span>(suf,suf+n+<span class="hljs-number">2</span>);<span class="hljs-comment">//反转suf数组</span><br><span class="hljs-comment">//复原</span><br><span class="hljs-built_in">reverse</span>(a,a+n+<span class="hljs-number">2</span>);<br><span class="hljs-built_in">reverse</span>(s,s+n+<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br><span class="hljs-comment">//利用[pos+1,pos+k]更新答案</span><br><span class="hljs-built_in">init</span>();<br>ll ans=<span class="hljs-number">1e18</span>;<br><br><span class="hljs-comment">//对[pos-k,pos-1]做一遍单调队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,pos-k); i&lt;pos; i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k)hh++;<br>tem[i]=pre[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;pre[q[tt]]&gt;=pre[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>&#125;<br> <br><span class="hljs-comment">//更新答案[pos,pos+k-1] </span><br>    <br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此时suf数组在pos位置是不准确的，但是为什么还可以用来更新答案呢？？</span><br><span class="hljs-comment">因为suf数组表示以pos为结尾，选上pos但是不计算pos的答案，也就是说，pos位置的数无论是多少，都不影响suf</span><br><span class="hljs-comment">那么此时suf值在pos位置就是准确的。</span><br><span class="hljs-comment">此时，修改pos位置，影响到suf的区间[0,pos-1]!!!!!</span><br><span class="hljs-comment">    */</span><br>    <br>    <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos; i&lt;=<span class="hljs-built_in">min</span>(n+<span class="hljs-number">1</span>,pos+k<span class="hljs-number">-1</span>); i++) &#123;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;i-q[hh]&gt;k)hh++;<br>tem[i]=tem[q[hh]]+a[i];<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br><span class="hljs-built_in">init</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;tem[q[tt]]&gt;=tem[i]) &#123;<br>tt--;<br>&#125;<br>q[++tt]=i;<br>ans=<span class="hljs-built_in">min</span>(ans,tem[i]+suf[i]);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">init</span>();<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>a[<span class="hljs-number">0</span>]=a[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>cin&gt;&gt;s+<span class="hljs-number">1</span>;<br>s[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;1&#x27;</span>,s[n+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;1&#x27;</span>;<span class="hljs-comment">//必须选</span><br><span class="hljs-built_in">get</span>();<span class="hljs-comment">//处理pre，suf数组</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)&#123;<br>suf[i]-=a[i];<br>        <br>        <br><span class="hljs-comment">/*需要做这个处理</span><br><span class="hljs-comment">suf数组表示选第i个，但是第i个权值并没有算进去</span><br><span class="hljs-comment">这样ask询问好算，而且此处理后，pos修改只会影响[0,pos-1]的suf值，具体见ask处</span><br><span class="hljs-comment">*/</span><br>        <br>        <br>&#125;<br><br><span class="hljs-type">int</span> m;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--) &#123;<br><span class="hljs-type">int</span> pos,val;<br>cin&gt;&gt;pos&gt;&gt;val;<br><span class="hljs-type">int</span> back=a[pos];<br>a[pos]=val;<br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(pos)&lt;&lt;endl;<span class="hljs-comment">//计算答案</span><br>a[pos]=back;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> t;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>a.对于本题目的答案ans</p><blockquote><ol><li>对于任何一个必须选的点x，ans&#x3D;pre[x]+suf[x]-a[x]</li><li>特殊的，ans&#x3D;suf[0]+pre[n+1]</li><li>对于任何一个非必选的x，在一个长度为k的区间内，假设区间内的所有位置都非必选，则ans&#x3D;min(pre[i]+suf[i]-a[i])</li><li>第3条，假设区间内存在必须选的位置，ans&#x3D;min(pre[i]+suf[i]-a[i])&#x3D;pre[pos]+suf[pos]-a[pos]，(pos是必须要选的位置)</li></ol></blockquote><p>b.代码中，如果x+k-1&gt;n+1，也没事，因为答案会在n+1处取得</p><p>c.     注意本题目的suf数组的具体含义（见代码注释），因为这样处理，在ask询问中比较容易做，而且改变了<code>a[pos]的修改</code>对suf的影响！！！。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有限制的背包（No Bug No Game）</title>
    <link href="/2023/11/11/%E7%AE%97%E6%B3%95/%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%83%8C%E5%8C%85/"/>
    <url>/2023/11/11/%E7%AE%97%E6%B3%95/%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/gym/104090/problem/C">2022 ICPC杭州 C. No Bug No Game</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有n个物品，背包容量为k，给出n组物品，每一组物品有pi个，每个物品的体积从1到pi递增，取的体积不同，获得的价值也不同，体积从1到pi(连续），价值从w1到wj   （j&#x3D;pi）</p><p>如果当前背包容量足够，则必须取完整的重量</p><p>否则必须可以取部分体积来填满剩余的背包容量，问能取得的最大价值是多少</p><p>数据范围：<code>n，k&lt;=3000,  pi&lt;=10 , wj&lt;=1e5</code></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>对于每一组物品，如果此时剩余容量大于pi，则必须取最后一个，否则必须取相应体积的物品，此时容量为0</li><li>而且，体积小的物体可能有更大的价值</li><li>显然，取的顺序有所谓，前面组必须取最后，最后一组必须取中间的某个</li><li>我们无法贪心的排序，但是可以这样想，只有一组取中间，其他组取最后，可以dp</li><li>设dp[i][j][0\1]表示前i组，且此时恰好装了j体积的最大价值，0和1表示，恰好装到j时，前i组有没有取到中间的某个物品</li></ol><p>我们发现，这样设转移方程是可以转移的，因为可以表示所有状态，第i组刚结束，并且恰好取到了j，还知道此时是否可以取中间</p><p>转移方程见代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e3</span>+<span class="hljs-number">10</span>;<br><br>ll dp[N][N][<span class="hljs-number">2</span>];<br>ll w[N][<span class="hljs-number">15</span>];<br>ll p[N];<br>ll n,k;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br>ll sum0=<span class="hljs-number">0</span>,sum1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;p[i];<br>sum0+=p[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=p[i]; j++) &#123;<br>cin&gt;&gt;w[i][j]; <br>&#125;<br>sum1+=w[i][p[i]];<br>&#125;<br><br><span class="hljs-keyword">if</span>(sum0&lt;=k)&#123;<br>cout&lt;&lt;sum1&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=k; j++) &#123;<br>dp[i][j][<span class="hljs-number">0</span>]=dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-number">-1e18</span>;<br>&#125;<br>&#125;<br><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//前0个物品,恰好选0体积，而且没有选中间某个物品,最大价值为0</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=k; j++) &#123;<br><span class="hljs-comment">//可以选择不选当前组</span><br>dp[i][j][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>];<br>dp[i][j][<span class="hljs-number">1</span>]=dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">1</span>];<br><br><br><span class="hljs-comment">//选当前组最后一个物品</span><br><span class="hljs-comment">//更新dp[i][j][0],dp[i][j][1]</span><br><span class="hljs-keyword">if</span>(j&gt;=p[i]) &#123;<br>dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][j-p[i]][<span class="hljs-number">0</span>]+w[i][p[i]]);<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][j-p[i]][<span class="hljs-number">1</span>]+w[i][p[i]]);<br>&#125;<br><br><span class="hljs-comment">//选当前组的中间物品</span><br><span class="hljs-comment">//更新dp[i][j][1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">1</span>; t&lt;p[i]; t++) &#123;<br><span class="hljs-keyword">if</span>(j&gt;=t) &#123;<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],dp[i<span class="hljs-number">-1</span>][j-t][<span class="hljs-number">0</span>]+w[i][t]);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">千万不可以这样写！！！ </span><br><span class="hljs-comment">ans=max(ans,max(dp[i][j][0],dp[i][j][1]));</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//cout&lt;&lt;ans&lt;&lt;endl; </span><br>cout&lt;&lt;<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>,<span class="hljs-built_in">max</span>(dp[n][k][<span class="hljs-number">0</span>],dp[n][k][<span class="hljs-number">1</span>]));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">千万不可以这样写！！！ </span><br><span class="hljs-comment">ans=max(ans,max(dp[i][j][0],dp[i][j][1]));</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 为什么不可以这样做？？</li></ul><p>设想这样一个情景，假设有一组，其中物品价值是 1， 1，INF，1，1</p><p>此时，dp[i][j][1]可以是前i组，容量恰好选完j，且此时选到了中间的INF，此时价值是正无穷，可是，如果实际情况是永远也不可能选到INF，这样更新会导致答案错误。</p><p>下面证明实际情况存在可能选不到INF：</p><ol><li>前i-1层遍历完，并且仅<code>dp[i-1][j][0]</code>有值，<code>dp[i-1][[j][1]</code>为-INF，实际上，不需要考虑<code>dp[i-1][j][1]</code></li><li>遍历第i层，<code>dp[i][j][1]</code>用<code>dp[i-1][j’][0]</code>更新，此时遇到了INF,被更新为INF，导致答案错误</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asio socket的创建和连接</title>
    <link href="/2023/11/11/cpp/asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/11/cpp/asio%20socket%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="TCP和IP协议"><a href="#TCP和IP协议" class="headerlink" title="TCP和IP协议"></a>TCP和IP协议</h3><ol><li><strong>TCP（传输控制协议）</strong>：TCP是一种网络通信协议，它在互联网协议套件（TCP&#x2F;IP）中负责确保数据的可靠传输。TCP提供了一种可靠的、面向连接的通信方式。这意味着在数据开始传输之前，两个网络设备（比如计算机）之间必须首先建立一个连接。TCP还负责确保数据的完整性和顺序正确。</li><li><strong>IP协议（互联网协议）</strong>：IP协议是另一种关键的网络通信协议，负责在网络上路由和传输数据包。IP有两个主要版本：IPv4和IPv6。IPv4是目前最广泛使用的版本，但由于地址空间限制，IPv6正在逐渐被采用。</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul><li><strong>Socket是什么</strong>：Socket是网络通信的端点。您可以将其想象为电话插座，它是网络上两个程序（运行在不同计算机上或同一计算机上的不同进程）进行数据交换的接口。</li><li><strong>Socket的用途</strong>：Socket使得程序可以读写网络上的数据。在创建Socket时，您需要指定使用的协议（如TCP）。一旦建立了Socket连接，数据就可以通过这个连接在网络上进行传输。</li></ul><h3 id="TCP连接和IP协议的关系"><a href="#TCP连接和IP协议的关系" class="headerlink" title="TCP连接和IP协议的关系"></a>TCP连接和IP协议的关系</h3><ul><li>在进行TCP网络通信时，通常会使用IP协议（无论是IPv4还是IPv6）。这是因为TCP负责在两个端点之间建立一个稳定的连接，并确保数据可靠地传输，而IP协议负责将数据包路由到正确的目的地。</li><li>当您在编程中创建一个TCP Socket时，您需要指定使用的IP协议版本。例如，在Boost.Asio中，您可以创建一个使用IPv4的TCP Socket（<code>asio::ip::tcp::socket</code>），这意味着它将使用IPv4协议来路由数据。</li></ul><h1 id="网络编程基本流程"><a href="#网络编程基本流程" class="headerlink" title="网络编程基本流程"></a>网络编程基本流程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>1）socket——创建socket对象。</p><p>2）bind——绑定本机ip+port。</p><p>3）listen——监听来电，若在监听到来电，则建立起连接。</p><p>4）accept——再创建一个socket对象给其收发消息。原因是现实中服务端都是面对多个客户端，那么为了区分各个客户端，则每个客户端都需再分配一个socket对象进行收发消息。</p><p>5）read、write——就是收发消息了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>1）socket——创建socket对象。</p><p>2）connect——根据服务端ip+port，发起连接请求。</p><p>3）write、read——建立连接后，就可发收消息了。</p><h1 id="终端节点的创建"><a href="#终端节点的创建" class="headerlink" title="终端节点的创建"></a>终端节点的创建</h1><h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><p><code>客户端</code>可以通过对端的ip和端口构造一个endpoint，用这个endpoint和<code>服务端</code>通信。</p><p>步骤如下：</p><ol><li>设置服务器<code>IP地址</code>（string）和 <code>PORT</code>（unsigned short）</li><li>定义<code> boost::system::error_code</code>状态码，用于存储解析<code> IP</code>时候可能发生的错误</li><li>解析IP地址,获取<code>asio::ip::address</code>对象</li><li>如果解析失败，反悔错误码</li><li>解析成功，根据<code>ip::address</code>和<code>PORT</code>建立TCP连接，获取<code>asio::ip::tcp::endpoint</code>对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义client_end_point函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">client_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 设置服务器IP地址和端口号</span><br>    <span class="hljs-comment">// 使用本地回环地址127.0.0.1进行测试</span><br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;           <br><br>    <span class="hljs-comment">// Step 2: 用于存储解析IP地址时可能发生的错误的变量</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 3: 解析IP地址</span><br>    asio::ip::address ip_address = asio::ip::address::<span class="hljs-built_in">from_string</span>(raw_ip_address, ec);<br><br>    <span class="hljs-comment">// Step 4: 检查IP地址是否正确解析</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果解析出错，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to parse the IP address. Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Step 5: 使用解析好的IP地址和端口号创建TCP端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 6: 输出端点信息，验证创建是否成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Endpoint created: IP Address = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">address</span>() <br>              &lt;&lt; <span class="hljs-string">&quot;, Port = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">port</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用client_end_point函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">client_end_point</span>();<br><br>    <span class="hljs-comment">// 检查client_end_point函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during endpoint creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 端点创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Endpoint creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p>步骤如下：</p><ol><li>定义端口号（unsigned short）</li><li>根据本机IPv6<code>asio::ip::address_v6::any()</code>协议创建<code>asio::ip::address</code>对象</li><li>根据<code>ip::address</code>和<code>Port</code>创建<code>asio::ip::tcp::endpoint</code>对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;endpoint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义server_end_point函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">server_end_point</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-comment">// 这里我们假设服务器应用程序已经获取了端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个特殊的asio::ip::address对象</span><br>    <span class="hljs-comment">// 它指定了主机上所有可用的IP地址</span><br>    <span class="hljs-comment">// 注意，这里我们假设服务器工作在IPv6协议上</span><br>    asio::ip::address ip_address = asio::ip::address_v6::<span class="hljs-built_in">any</span>();<br><br>    <span class="hljs-comment">// Step 3: 使用指定的IP地址和端口号创建TCP端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 端点创建完成，可以用来指定服务器应用程序希望监听传入连接的IP地址和端口号</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server endpoint created: IP Address = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">address</span>() <br>              &lt;&lt; <span class="hljs-string">&quot;, Port = &quot;</span> &lt;&lt; ep.<span class="hljs-built_in">port</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用server_end_point函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">server_end_point</span>();<br><br>    <span class="hljs-comment">// 检查server_end_point函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during server endpoint creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 服务器端点创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server endpoint creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Socket-1"><a href="#Socket-1" class="headerlink" title="Socket"></a>Socket</h1><h2 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h2><p>步骤：</p><ol><li>创建<code>asio::io_context</code>对象</li><li>创建一个代表TCP协议的<code>asio::ip::tcp</code>对象protocol</li><li>创建TCP套接字对象<code>asio::ip::tcp::socket</code>,将它与<code>asio::io_context</code>对象关联</li><li>定义一个<code>boost::system::error_code</code>变量</li><li>打开套接字（使用TCP协议protocol，错误码error_code)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义create_tcp_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_tcp_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 创建asio::io_context对象</span><br>    <span class="hljs-comment">// io_service（或io_context）是Boost.Asio中的核心类，用于处理所有I/O操作</span><br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// Step 2: 创建一个代表TCP协议的asio::ip::tcp对象</span><br>    <span class="hljs-comment">// 这里我们使用IPv4作为底层协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><br>    <span class="hljs-comment">// Step 3: 实例化一个活动的TCP套接字对象</span><br>    <span class="hljs-comment">// 套接字用于网络通信，这里我们将它与io_service对象关联</span><br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储打开套接字时可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 打开套接字</span><br>    <span class="hljs-comment">// 使用之前定义的TCP协议（IPv4）打开套接字</span><br>    sock.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查套接字是否成功打开</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果打开失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to open the socket! Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用create_tcp_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_tcp_socket</span>();<br><br>    <span class="hljs-comment">// 检查create_tcp_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during socket creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 套接字创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Socket creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h2><p>需要生成一个acceptor的socket，用来接收新的连接。</p><p>步骤：</p><ol><li>创建<code>asio::io_context</code>对象</li><li>创建一个代表TCP协议的<code>asio::ip::tcp</code>对象protocol</li><li>实例化一个接收器（Acceptor） 套接字对象<code>asio::ip::tcp::acceptor</code>,参数是ios</li><li>定义一个<code>boost::system::error_code</code>变量</li><li>打开套接字（使用TCP协议protocol，错误码error_code)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义create_acceptor_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 创建asio::io_context对象</span><br>    <span class="hljs-comment">// io_service（或io_context）是Boost.Asio中的核心类，用于处理所有I/O操作</span><br>    asio::io_context ios;<br><br>    <span class="hljs-comment">// Step 2: 创建一个代表TCP协议的asio::ip::tcp对象</span><br>    <span class="hljs-comment">// 这里我们使用IPv6作为底层协议</span><br>    asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v6</span>();<br><br>    <span class="hljs-comment">// Step 3: 实例化一个接收器（Acceptor）套接字对象</span><br>    <span class="hljs-comment">// 接收器套接字用于监听和接受传入的TCP连接</span><br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios)</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储打开接收器套接字时可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 打开接收器套接字</span><br>    <span class="hljs-comment">// 使用之前定义的TCP协议（IPv6）打开接收器</span><br>    acceptor.<span class="hljs-built_in">open</span>(protocol, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查接收器套接字是否成功打开</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果打开失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to open the acceptor socket! Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用create_acceptor_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">create_acceptor_socket</span>();<br><br>    <span class="hljs-comment">// 检查create_acceptor_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during acceptor socket creation. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收器套接字创建成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Acceptor socket creation successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="绑定acceptor"><a href="#绑定acceptor" class="headerlink" title="绑定acceptor"></a>绑定acceptor</h1><p>acceptor类型的socket，服务器要将其绑定到指定的端点,所有连接这个端点的连接都可以被接收到</p><p>步骤：</p><ol><li>设置端口号port</li><li>创建一个端点 <code>asio::ip::tcp::endpoint</code>,利用IP，prot</li><li>创建并打开一个接收器套接字<code>asio::ip::tcp::acceptor</code>，根据<code>ios</code>和<code>协议</code></li><li>定义一个error_code变量</li><li>将接收器套接字（accecptor）绑定到端点（endpoint）， <code>acceptor.bind(ep, ec)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义bind_acceptor_socket函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind_acceptor_socket</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-comment">// 这里我们假设服务器应用程序已经获取了端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个端点</span><br>    <span class="hljs-comment">// 使用asio::ip::address_v4::any()表示服务器将接受发送到本机任何IPv4地址的连接</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(), port_num)</span></span>;<br><br>    <span class="hljs-comment">// Step 3: 创建并打开一个接收器套接字</span><br>    asio::io_context ios;<br>    asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>    <span class="hljs-comment">// Step 4: 定义一个error_code变量，用于存储绑定操作过程中可能发生的错误</span><br>    boost::system::error_code ec;<br><br>    <span class="hljs-comment">// Step 5: 将接收器套接字绑定到端点</span><br>    acceptor.<span class="hljs-built_in">bind</span>(ep, ec);<br><br>    <span class="hljs-comment">// Step 6: 检查接收器套接字是否成功绑定</span><br>    <span class="hljs-keyword">if</span> (ec.<span class="hljs-built_in">value</span>() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果绑定失败，输出错误信息并返回错误码</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to bind the acceptor socket. Error code = &quot;</span><br>                  &lt;&lt; ec.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; ec.<span class="hljs-built_in">message</span>();<br>        <span class="hljs-keyword">return</span> ec.<span class="hljs-built_in">value</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果一切正常，返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用bind_acceptor_socket函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">bind_acceptor_socket</span>();<br><br>    <span class="hljs-comment">// 检查bind_acceptor_socket函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during acceptor socket binding. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收器套接字绑定成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Acceptor socket binding successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="客户端连接到指定的端点"><a href="#客户端连接到指定的端点" class="headerlink" title="客户端连接到指定的端点"></a>客户端连接到指定的端点</h1><p>步骤：</p><ol><li>获取目标服务器的IP地址和端口号</li><li>创建一个指向目标应用程序的端点endpoint，需要ip和端口号</li><li>创建并打开一个套接字socket，需要ios和IP协议</li><li>socket连接endpoint</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义connect_to_end函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect_to_end</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Step 1: 获取目标服务器的IP地址和端口号</span><br>    std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Step 2: 创建一个指向目标服务器应用程序的端点</span><br>        asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;<br><br>        asio::io_context ios;<br><br>        <span class="hljs-comment">// Step 3: 创建并打开一个套接字</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>        <span class="hljs-comment">// Step 4: 连接套接字</span><br>        sock.<span class="hljs-built_in">connect</span>(ep);<br><br>        <span class="hljs-comment">// 连接成功，套接字现在可以用于发送和接收数据</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occurred! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>                  &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用connect_to_end函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">connect_to_end</span>();<br><br>    <span class="hljs-comment">// 检查connect_to_end函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during connection. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 连接成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Connection successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="服务端接收连接"><a href="#服务端接收连接" class="headerlink" title="服务端接收连接"></a>服务端接收连接</h1><p>步骤：</p><ol><li>设置端口号</li><li>创建端点endpoint，需要IP地址和Port</li><li>创建<code>接收器套接字</code>，需要ios和IP协议</li><li>接收器套接字<code>accecptor</code>绑定指定<code>endpoint</code></li><li>开始监听传入的连接请求 <code>acceptor.listen(BACKLOG_SIZE)</code></li><li>创建一个活动套接字sock,需要ios</li><li>接收连接请求，将活动套接字连接到客户端<code>acceptor.accept(sock)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/system/error_code.hpp&gt;</span></span><br><br><span class="hljs-comment">// 使用命名空间别名，简化Boost.Asio的使用</span><br><span class="hljs-keyword">namespace</span> asio = boost::asio;<br><br><span class="hljs-comment">// 定义accept_new_connection函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept_new_connection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BACKLOG_SIZE = <span class="hljs-number">30</span>; <span class="hljs-comment">// 等待连接请求的队列大小</span><br><br>    <span class="hljs-comment">// Step 1: 获取协议端口号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br><br>    <span class="hljs-comment">// Step 2: 创建一个服务器端点</span><br>    asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address_v4::any(), port_num)</span></span>;<br><br>    asio::io_context ios;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Step 3: 实例化并打开一个接收器套接字</span><br>        asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, ep.protocol())</span></span>;<br><br>        <span class="hljs-comment">// Step 4: 将接收器套接字绑定到服务器端点</span><br>        acceptor.<span class="hljs-built_in">bind</span>(ep);<br><br>        <span class="hljs-comment">// Step 5: 开始监听传入的连接请求</span><br>        acceptor.<span class="hljs-built_in">listen</span>(BACKLOG_SIZE);<br><br>        <span class="hljs-comment">// Step 6: 创建一个活动套接字</span><br>        asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ios)</span></span>;<br><br>        <span class="hljs-comment">// Step 7: 接收连接请求，将活动套接字连接到客户端</span><br>        acceptor.<span class="hljs-built_in">accept</span>(sock);<br><br>        <span class="hljs-comment">// 连接成功，套接字现在可以用于与客户端进行数据交换</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (boost::system::system_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error occurred! Error code = &quot;</span> &lt;&lt; e.<span class="hljs-built_in">code</span>()<br>                  &lt;&lt; <span class="hljs-string">&quot;. Message: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>        <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">code</span>().<span class="hljs-built_in">value</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用accept_new_connection函数并处理返回结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">accept_new_connection</span>();<br><br>    <span class="hljs-comment">// 检查accept_new_connection函数的返回值，确定是否出错</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error occurred during accepting connection. Error code: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收连接成功</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Accepting connection successful.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 正常结束程序</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="概念和疑问"><a href="#概念和疑问" class="headerlink" title="概念和疑问"></a>概念和疑问</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p><input disabled="" type="checkbox"> 端点，套接字，接收器套接字对于客户端和服务端的作用</p></li><li><p><strong>客户端端点创建</strong> (<code>client_end_point</code>):</p><ul><li>设置目标服务器的IP和端口，创建客户端端点以连接服务器。</li></ul></li><li><p><strong>服务器端点创建</strong> (<code>server_end_point</code>):</p><ul><li>设置端口号，创建服务器端点以便监听来自客户端的连接。</li></ul></li><li><p><strong>创建TCP套接字</strong> (<code>create_tcp_socket</code>):</p><ul><li>创建套接字，用于客户端的连接或服务器的通信。</li></ul></li><li><p><strong>创建接收器套接字</strong> (<code>create_acceptor_socket</code>):</p><ul><li>创建接收器套接字，用于服务器端接受客户端的连接请求。</li></ul></li><li><p><strong>绑定接收器套接字</strong> (<code>bind_acceptor_socket</code>):</p><ul><li>将接收器套接字绑定到一个特定的端点，用于监听来自该端点的连接请求。</li></ul></li><li><p><strong>连接到端点</strong> (<code>connect_to_end</code>):</p><ul><li>客户端使用套接字连接到指定的服务器端点。</li></ul></li><li><p><strong>接收新连接</strong> (<code>accept_new_connection</code>):</p><ul><li>服务端监听并接受来自客户端的新连接请求。<strong>创建一个新的套接字与客户端进行通信</strong>。（注意，创建新的套接字通信）</li></ul></li><li><p><input disabled="" type="checkbox"> 端点，套接字，接收器套接字代码</p></li></ul><table><thead><tr><th>组件</th><th>功能</th><th>参数</th><th>示例代码</th><th>应用场景</th></tr></thead><tbody><tr><td>boost::system::error_code</td><td>错误代码对象</td><td>-</td><td>boost::system::error_code ec;</td><td>用于处理网络操作中的错误，如套接字打开或绑定失败。</td></tr><tr><td>asio::ip::address</td><td>表示一个IP地址</td><td>1.IP地址字符串<br />2.错误代码对象</td><td>asio::ip::address ip_address &#x3D; asio::ip::address::from_string(“127.0.0.1”, ec);</td><td>定义网络通信的IP地址，用于创建端点。</td></tr><tr><td>asio::ip::tcp::endpoint</td><td>表示一个TCP网络端点</td><td>1.ip_address<br />2.port_num</td><td>asio::ip::tcp::endpoint ep(ip_address, port_num);</td><td>用于定义TCP连接的目标地址和端口，客户端和服务器都会使用。</td></tr><tr><td>asio::io_context</td><td>提供I&#x2F;O功能</td><td>-</td><td>asio::io_context ios;</td><td>用于管理异步I&#x2F;O操作，是Boost.Asio程序的核心。</td></tr><tr><td>asio::ip::tcp::socket</td><td>TCP套接字，用于网络通信</td><td>1.<code>io_context</code>对象<br />2.协议</td><td>asio::ip::tcp::socket sock(ios);</td><td>用于客户端发起连接和服务器与客户端之间的数据交换。</td></tr><tr><td>asio::ip::tcp::acceptor</td><td>接收器套接字，用于接受连接</td><td>1.<code>io_context</code>对象<br />2.协议</td><td>asio::ip::tcp::acceptor acceptor(ios, protocol);</td><td>服务器端使用，用于监听和接受来自客户端的连接。</td></tr></tbody></table><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h4 id="1-关于地址解析"><a href="#1-关于地址解析" class="headerlink" title="1. 关于地址解析"></a>1. 关于地址解析</h4><p><strong>问题</strong>：根据string类型的ip地址解析，创建address对象，如果这个ip不是本机ip，是别的服务器的ip，就有可能解析不成功。如果是本机ip，一定可以成功。</p><p><strong>答案</strong>：当你使用一个字符串类型的IP地址来创建<code>asio::ip::address</code>对象时，如果IP地址格式正确，它应该能够成功解析，无论这个IP是否属于本机。解析失败通常是由于格式错误或不支持的地址类型。</p><h4 id="2-创建端点endpoint对象需要address对象和端口"><a href="#2-创建端点endpoint对象需要address对象和端口" class="headerlink" title="2. 创建端点endpoint对象需要address对象和端口"></a>2. 创建端点endpoint对象需要address对象和端口</h4><p><strong>问题</strong>：创建端点endpoint对象需要address对象和端口。</p><p><strong>答案</strong>：正确，<code>asio::ip::tcp::endpoint</code>对象的创建需要一个IP地址（<code>asio::ip::address</code>对象）和一个端口号。</p><h4 id="3-关于创建和打开socket"><a href="#3-关于创建和打开socket" class="headerlink" title="3. 关于创建和打开socket"></a>3. 关于创建和打开<code>socket</code></h4><p><strong>问题</strong>：创建socket对象需要ios，打开socket需要protocol和error_code?为啥需要打开呢？打开的时候在什么情况下会出错呢？</p><p><strong>答案</strong>：<code>asio::ip::tcp::socket</code>对象需要一个<code>asio::io_context</code>对象来处理I&#x2F;O操作。打开<code>socket</code>指的是使其准备好进行网络通信。如果指定的协议不支持，或者系统资源不足（如端口号被占用），打开<code>socket</code>可能会出错。</p><h4 id="4-关于acceptor"><a href="#4-关于acceptor" class="headerlink" title="4. 关于acceptor"></a>4. 关于<code>acceptor</code></h4><p><strong>问题</strong>：accecptor也是一个接收器socket，也需要打开，并且流程跟socket一样？</p><p><strong>答案</strong>：<code>asio::ip::tcp::acceptor</code>类似于一个特殊的<code>socket</code>，专门用于监听和接受来自客户端的连接。它也需要被打开和绑定到一个端点上，以便知道在哪个端口上监听。</p><h4 id="5-绑定acceptor"><a href="#5-绑定acceptor" class="headerlink" title="5. 绑定acceptor"></a>5. 绑定<code>acceptor</code></h4><p><strong>问题</strong>：绑定accecptor，是先创建，然后在将他绑定到endpoint上么？然后listen，就可以接受ip：port的消息了？</p><p><strong>答案</strong>：你需要先创建一个<code>acceptor</code>，然后将其绑定到一个<code>endpoint</code>上（一个IP地址和端口号的组合）。一旦绑定并调用了<code>listen()</code>，它就开始监听该端点上的入站连接。</p><h4 id="6-客户端访问服务端"><a href="#6-客户端访问服务端" class="headerlink" title="6. 客户端访问服务端"></a>6. 客户端访问服务端</h4><p><strong>问题</strong>：客户端访问服务端，需要socket绑定endpoint（服务器的ip:port）。</p><p><strong>答案</strong>：客户端的<code>socket</code>需要连接到服务器的<code>endpoint</code>（服务器的IP地址和端口号）。</p><h4 id="7-关于asio-ip-address-v6-any"><a href="#7-关于asio-ip-address-v6-any" class="headerlink" title="7. 关于asio::ip::address_v6::any()"></a>7. 关于<code>asio::ip::address_v6::any()</code></h4><p><strong>问题</strong>：asio::ip::address_v6::any()，这种代码只会在服务器上创建endpoint上使用，而且基本不会出错？</p><p><strong>答案</strong>：<code>asio::ip::address_v6::any()</code>在服务器上创建一个可以接受任何IPv6地址的端点，这意味着它可以从任何IPv6地址接收连接。这通常不会出错，除非有底层网络配置问题。</p><h4 id="8-关于接收器端点的访问"><a href="#8-关于接收器端点的访问" class="headerlink" title="8. 关于接收器端点的访问"></a>8. 关于接收器端点的访问</h4><p><strong>问题</strong>：接收器接受服务器的端点，此时是不是只用（端点的ip，和端口号）访问？比如开放了公网ip，那只可以用“公网ip:端口”访问，如果用“127.0.0.1：3333”就不可以（如果服务器在本地）。</p><p><strong>答案</strong>：如果服务器监听公网IP和端口，那么客户端必须使用这个公网IP和端口来连接。如果服务器监听的是本地地址（如127.0.0.1），那么只有本地客户端（在同一台机器上）可以使用这个地址和端口连接。</p><h4 id="9-理解asio-io-context的重要性"><a href="#9-理解asio-io-context的重要性" class="headerlink" title="9. 理解asio::io_context的重要性"></a>9. 理解<code>asio::io_context</code>的重要性</h4><p><strong>问题</strong>：如果不理解asio::io_context，是不是可以先跳过？</p><p><strong>答案</strong>：<code>asio::io_context</code>是Boost Asio库的核心，负责管理所有I&#x2F;O服务。虽然一开始可能不容易理解，但它在Asio编程中非常重要，建议不要跳过。随着实践的增加，你会逐渐理解它的用途和重要性。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树逆序对（Master of Both）</title>
    <link href="/2023/11/07/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2023/11/07/%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p> <a href="https://codeforces.com/gym/104090/problem/K">2022ICPC杭州K题 Master of Both</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定n和m，表示n个字符串和m组询问</p><p>字符串长度1e5，总长度不超过1e6</p><p>m组询问中，每次给定一个字符串（只含有26个不同的小写字母），表示比较规则（前面小于后面），求n个字符串中的逆序对个数</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>首先发现，对于n个字符串中任意两个字符串a,b，只有两种情况</p><ul><li><input disabled="" type="checkbox"> a是b的前缀，那么此时a&lt;b一定成立，在任何比较规则下</li><li><input disabled="" type="checkbox"> a不是b的前缀，那么，首先找到<code>最长公共前缀的下一个字符</code>，这俩字符即可决定a和b的大小关系，并且a和b的大小关系只由这一对字符决定</li></ul><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><ol><li>字典树</li><li>插入字符串的时候维护res数组和cnt数组。</li><li>设res[i][j]表示 字母i&gt;字母j的情况下，产生的逆序对个数</li><li>设cnt数组表示字典树中节点i的字数中有多少个单词</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> t[N][<span class="hljs-number">26</span>],idx;<br>ll cnt[N];<span class="hljs-comment">//trie中每个节点的权值 </span><br>ll res[<span class="hljs-number">26</span>][<span class="hljs-number">26</span>];<span class="hljs-comment">//在i&gt;j的规则下，整个序列产生的逆序对 </span><br>ll chushi;<span class="hljs-comment">//表示一定会产生的逆序对个数 </span><br>ll n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_res</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br><span class="hljs-comment">//当前在p节点，要经过边q</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br><span class="hljs-comment">//当i&gt;q的时候，产生的逆序对个数增加 cnt个 </span><br>res[i][q]+=cnt[t[p][i]];<br>&#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>&#123;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前节点 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-type">int</span> q=s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//边的方向</span><br><span class="hljs-keyword">if</span>(!t[p][q])t[p][q]=++idx;<br><br><span class="hljs-built_in">update_res</span>(p,q);<br><br>p=t[p][q];<br><br>cnt[p]++; <br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>chushi+=cnt[t[p][i]];<span class="hljs-comment">//一定会产生的逆序对 </span><br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span></span>&#123;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br><span class="hljs-comment">//注意j在i前面，因为s[j]&gt;s[i] </span><br>ans+=res[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>][s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">insert</span>(s);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>string s;<br>cin&gt;&gt;s;<br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(s)+chushi&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>字典树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>悬线法dp(玉蟾宫+ICPC银川K)</title>
    <link href="/2023/11/07/%E7%AE%97%E6%B3%95/%E6%82%AC%E7%BA%BF%E6%B3%95dp/"/>
    <url>/2023/11/07/%E7%AE%97%E6%B3%95/%E6%82%AC%E7%BA%BF%E6%B3%95dp/</url>
    
    <content type="html"><![CDATA[<h1 id="玉蟾宫"><a href="#玉蟾宫" class="headerlink" title="玉蟾宫"></a>玉蟾宫</h1><p><a href="https://www.luogu.com.cn/problem/P4147">洛谷P4147玉蟾宫</a></p><p>给一个矩阵，一些点有障碍物，求最大子矩阵</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p><code>悬线法dp</code>，第一次听说。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>（1）结论：答案一定是一个矩形（废话。。。）<br>（2）最大矩形一定是：由其中<code>某个点</code>，<code>先</code>向上扩展到最大，<code>然后</code>再分别向左、向右走到最远。<br>（3）由于（2）的结论对所有点这样操作，一定可以找到最大矩形<br>  (4)  注意<code>先初始化h，L，R</code>，然后在<code>h=1的时候预处理L,R</code>，然后<code>再更新h，同时更新L，R</code>，并且统计答案   </p><h2 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">char</span> a[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][N];<span class="hljs-comment">//每个点往上延申的最大长度</span><br><span class="hljs-type">int</span> L[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往左走最远到哪</span><br><span class="hljs-type">int</span> R[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往右走最远到哪</span><br><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)h[i][j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//自己</span><br>L[i][j]=R[i][j]=j;<span class="hljs-comment">//自己 </span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//在h=1的情况下处理L和R </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//处理L </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>L[i][j]=L[i][j<span class="hljs-number">-1</span>];<br>&#125; <br>&#125; <br><span class="hljs-comment">//处理R </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>R[i][j]=R[i][j+<span class="hljs-number">1</span>];<br>&#125; <br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>&amp;&amp;a[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<span class="hljs-comment">//h数组扩展 </span><br><br><span class="hljs-comment">//L、R向内收缩 </span><br>L[i][j]=<span class="hljs-built_in">max</span>(L[i][j],L[i<span class="hljs-number">-1</span>][j]);<br>R[i][j]=<span class="hljs-built_in">min</span>(R[i][j],R[i<span class="hljs-number">-1</span>][j]); <br>&#125;<br><br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>ans=<span class="hljs-built_in">max</span>(ans,h[i][j]*(R[i][j]-L[i][j]+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>&#125; <br>cout&lt;&lt;ans*<span class="hljs-number">3</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="ICPC银川"><a href="#ICPC银川" class="headerlink" title="ICPC银川"></a>ICPC银川</h1><p><a href="https://codeforces.com/gym/104021/problem/K">Largest Common Submatrix</a></p><p>给定一个矩阵A和一个矩阵B，求最大子矩阵，满足最大子矩阵同时是A的最大子矩阵和B的最大子矩阵</p><h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>悬线法dp，注意转移条件，以及<code>边界问题</code>！！！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> b[N][N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> h[N][N];<span class="hljs-comment">//每个点往上延申的最大长度</span><br><span class="hljs-type">int</span> L[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往左走最远到哪</span><br><span class="hljs-type">int</span> R[N][N];<span class="hljs-comment">//在h保证的情况下，每个点往右走最远到哪</span><br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;pos[N*N];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br>cin&gt;&gt;a[i][j];<br>h[i][j]=<span class="hljs-number">1</span>;<br>L[i][j]=R[i][j]=j;<span class="hljs-comment">//自己</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br>cin&gt;&gt;b[i][j];<br>pos[b[i][j]]= &#123;i,j&#125;;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//在h=1的情况下处理L和R</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-comment">//处理L</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j&lt;=m; j++) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//a中当前数字的左边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[x].first;<br><span class="hljs-type">int</span> by=pos[x].second;<br><br><span class="hljs-comment">//如果可以向左边扩展</span><br><span class="hljs-keyword">if</span>(b[bx][by<span class="hljs-number">-1</span>]==y) &#123;<br>L[i][j]=L[i][j<span class="hljs-number">-1</span>];<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//处理R</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">1</span>; j--) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i][j+<span class="hljs-number">1</span>];<span class="hljs-comment">//a中当前数字的右边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[x].first;<br><span class="hljs-type">int</span> by=pos[x].second;<br><br><span class="hljs-comment">//如果可以向右边扩展</span><br><span class="hljs-keyword">if</span>(b[bx][by+<span class="hljs-number">1</span>]==y) &#123;<br>R[i][j]=R[i][j+<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//更新h,L,R ，统计答案</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++) &#123;<br><span class="hljs-type">int</span> x=a[i][j];<span class="hljs-comment">//a中当前数字</span><br><span class="hljs-type">int</span> y=a[i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">//a中当前数字的上边那个数字</span><br><br><br><span class="hljs-comment">//当前数字在b数组中的位置</span><br><span class="hljs-type">int</span> bx=pos[a[i][j]].first;<br><span class="hljs-type">int</span> by=pos[a[i][j]].second;<br><br><span class="hljs-comment">//如果可以向上边扩展</span><br><span class="hljs-keyword">if</span>(y&amp;&amp;b[bx<span class="hljs-number">-1</span>][by]==y) &#123;<br>h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>L[i][j]=<span class="hljs-built_in">max</span>(L[i][j],L[i<span class="hljs-number">-1</span>][j]);<br>R[i][j]=<span class="hljs-built_in">min</span>(R[i][j],R[i<span class="hljs-number">-1</span>][j]);<br>&#125;<br>ans=<span class="hljs-built_in">max</span>(ans,h[i][j]*(R[i][j]-L[i][j]+<span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
