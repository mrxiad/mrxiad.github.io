---
title: 计算机网络基础篇
date: 2024-3-19 12:33:12
tags: 计算机网络
categories: 
- 计算机网络
---



# 应用层

而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。





# 传输层

在传输层会有两个传输协议，分别是 TCP 和 UDP。

TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。



应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中**途有一个分块丢失或损坏了，只需要重新发送这一个分块**，而不用重新发送整个数据包。



当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

由于传输层的**报文中会携带端口号**，因此接收方可以识别出该报文是发送给哪个应用。



> TCP头部包含端口号、序列号、确认号



# 网络层

网络层最常使用的是 IP 协议（*Internet Protocol*），IP 协议会将**传输层的报文作为数据部分**，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是**寻址**起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。

因此，需要将 IP 地址分成两种意义：

- 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- 一个是**主机号**，负责标识同一「子网」下的不同主机；



除了**寻址**能力， IP 协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。



> IP头部包含了源IP地址、目的IP地址以及其他控制信息





# DNS

一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS` 服务器。

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

在域名中，**越靠右**的位置表示其层级**越高**。



实际上域名最后还有一个点，比如 `www.server.com.`，这个最后的一个点代表根域名。

也就是，`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）



# 真实地址查询 —— DNS

## DNS解析

1. 客户端向本地DNS服务器发送请求
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。否则去向根DNS服务器发送请求
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，返回 .com 顶级域名服务器地址
4. 本地DNS服务器收到地址后，向顶级域名服务器发送请求
5. 顶级域名服务器返回权威DNS服务器地址
6. 本地DNS服务器向权威DNS服务器发送请求
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。



##  协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。





# TCP格式

首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序**号，这个是为了解决包乱序的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。`流量控制是TCP协议中用来防止发送方过快发送数据导致接收方处理不过来的机制`

除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。`是发送方为了避免网络中的过度拥塞而调整发送速度的机制`。





# TCP三次握手

- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。



所以三次握手目的是**保证双方都有发送和接收的能力**。



> TCP 报文生成

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。





# 出口 —— 网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。







# 总结



### 1. HTTP层的数据封装

HTTP（超文本传输协议）位于OSI模型的应用层，负责定义客户端与服务器之间的请求和响应格式。当你浏览网页时，浏览器（客户端）会通过HTTP协议向服务器发送一个请求。这个请求包含了请求行（例如，`GET /index.html HTTP/1.1`）、请求头（包含用户代理、接受的内容类型等信息）和请求体（在POST请求中使用）。

### 2. TCP层的数据封装

TCP（传输控制协议）位于传输层，负责在数据发送之前将HTTP数据分割成TCP报文段，并在这些数据到达目的地时重组。TCP为HTTP提供了一种可靠的数据传输服务，确保数据按顺序且完整无误地到达目的地。每个TCP报文段包含了源端口和目的端口信息、序列号（用于确保数据按正确顺序重组）、确认应答号（用于确认接收）以及控制信息（如同步SYN和结束FIN标志）。

### 3. IP层的数据封装

IP（互联网协议）位于网络层，负责将TCP报文段进一步封装成IP数据包，添加上源IP地址和目的IP地址等信息，并通过网络将数据包发送给目的地。IP协议负责寻找从源到目的地的最佳路径，但不保证数据包的顺序或完整性（这是TCP协议的任务）。



- 传输层，给应用数据前面增加了 TCP 头；
- 网络层，给 TCP 数据包前面增加了 IP 头；
- 网络接口层，给 IP 数据包前后分别增加了帧头和帧尾；